00010000*PROCESS     OPTIONS,SOURCE,LINECOUNT(60),NOMARGINI,MARGINS(010,100,009),NEST;
00020000*PROCESS     FLAG(I),NOCOMPILE(E),LMESSAGE;
00030000*PROCESS     AGGREGATE,ATTRIBUTES(SHORT),MAP,OFFSET,STORAGE,XREF(SHORT);
00040000*PROCESS     GOSTMT,OPTIMIZE(TIME);
00050000*PROCESS     COUNT,FLOW(25,10);
00060000 SMPSCAN:  /*COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY PROGRAM*/
00070000 PROC(SYSPARM) OPTIONS(MAIN) REORDER;
00080000    /*******************************************************************************/
00090000    /*   NAME      .SMPSCAN   VERSION 02.00                                        */
00100000    /*                                                                             */
00110000    /*                                                                             */
00120000    /*   TITLE     .COMMERCIAL UNION SMP/E LIST ENTRY SELECTION UTILITY.           */
00130000    /*                                                                             */
00140000    /*                                                                             */
00150000    /*   PROGRAM OBJECTIVES                                                        */
00160000    /*                                                                             */
00170000    /*             .COMPENSATE FOR SOME OF THE LIMITATIONS OF THE SMP/E "LIST"     */
00180000    /*              COMMAND, ESPECIALLY IN THE AREAS OF CROSS-ZONE ENTRY           */
00190000    /*              MATCHING, DATE/TIME RANGE CONTROL OF LISTINGS, AND FMID        */
00200000    /*              ASSOCIATION FOR ASSEMBLER AND LOAD MODULE ENTRIES.             */
00210000    /*                                                                             */
00220000    /*             .PROVIDE A UTILITY PROGRAM WRITTEN IN A HIGH LEVEL LANGUAGE     */
00230000    /*              TO PROCESS THE "SMPLIST" OUTPUT FROM AN SMP/E                  */
00240000    /*              "SET_BDY(ZONENAME)./LIST." EXECUTION FOR ONE OR MORE ZONES     */
00250000    /*              AND, USING A USER-SUPPLIED CONTROL VARIABLE INPUT FILE:        */
00260000    /*                                                                             */
00270000    /*                -PROVIDE CROSS-ZONE ENTRY MATCHING BASED ON SMP/E ENTRY      */
00280000    /*                 TYPE, ENTRY NAME, AND ON CHARACTER STRING SCAN SELECTION.   */
00290000    /*                                                                             */
00300000    /*                -IDENTIFY ENTRIES SATISFYING SPECIFIED ENTRY TYPE/NAME       */
00310000    /*                 MATCHING AND CHARACTER STRING SCAN SELECTION CRITERIA.      */
00320000    /*                                                                             */
00330000    /*                -GENERATE A RUN-TIME REPORT TO IDENTIFY EXECUTION CONTROL    */
00340000    /*                 VALUES AND MATCH/SELECTION CRITERIA, PROVIDE A DIRECTORY    */
00350000    /*                 TO MATCHING ENTRIES IN THE INPUT AND OUTPUT DATA SETS,      */
00360000    /*                 AND REPORT FINAL PROCESSING TOTALS ONCE EXECUTION IS        */
00370000    /*                 COMPLETE.                                                   */
00380000    /*                                                                             */
00390000    /*                -GENERATE LISTINGS OF THE MATCHING ENTRIES, BY FILE,         */
00400000    /*                 SHOWING HOW CHARACTER STRING SELECTION CRITERIA HAVE BEEN   */
00410000    /*                 APPLIED, AND IDENTIFYING WHERE THE SELECTION CRITERIA       */
00420000    /*                 HAVE BEEN SATISFIED.                                        */
00430000    /*                                                                             */
00440000    /*                -GENERATE OUTPUT DATA SETS, ONE FOR EACH SMP/E LIST INPUT    */
00450000    /*                 FILE, HAVING THE SAME FORMAT AND ATTRIBUTES AS THE          */
00460000    /*                 "SMPLIST" INPUT DATA SET, TO ALLOW REPROCESSING OF THE      */
00470000    /*                 MATCHING ENTRIES BY SMPSCAN WITH DIFFERENT SELECTION        */
00480000    /*                 CRITERIA, OR TO PROVIDE INPUT TO ANY PROGRAM WHICH          */
00490000    /*                 PROCESSES SMP/E LIST COMMAND OUTPUT AS INPUT.               */
00500000    /*                                                                             */
00510000    /*                -GENERATE 80-BYTE CARD-IMAGE OUTPUT DATA SETS, ONE FOR       */
00520000    /*                 EACH SMP/E LIST INPUT DATA SET, CONTAINING DATA FROM THE    */
00530000    /*                 MATCHING ENTRIES IN A FORMAT SUITABLE FOR USE IN AN SMP/E   */
00540000    /*                 CONTROL STATEMENT, OR FOR FURTHER EDITING USING AN          */
00550000    /*                 INTERACTIVE EDITOR.                                         */
00560000    /*                                                                             */
00570000    /*             .SUPPORT ALL OF THE ENTRY TYPES IN AN SMP/E GLOBAL, DLIB, OR    */
00580000    /*              TARGET ZONE THAT CAN BE LISTED BY THE SMP/E "LIST" COMMAND,    */
00590000    /*              WITH OR WITHOUT THE "XREF" OPTION.                             */
00600000    /*                                                                             */
00610000    /*             .USE CHARACTER STRING SELECTION AND ENTRY MATCHING TECHNIQUES   */
00620000    /*              WHICH ARE GENERAL, AND RELATIVELY INSENSITIVE TO THE FORMAT    */
00630000    /*              AND VALUES OF INDIVIDUAL DATA FIELDS WITHIN THE SMP/E          */
00640000    /*              LISTING ENTRY LINES.  MOREOVER, IT WAS DEEMED IMPORTANT TO     */
00650000    /*              REMAIN INDEPENDENT OF SMP/E INTERNALS OR KNOWLEDGE OF THOSE    */
00660000    /*              INTERNALS.  THE CHARACTER STRING SCAN SELECTION TECHNIQUE IS   */
00670000    /*              BASED ON PRESENCE OR ABSENCE OF SPECIFIED CHARACTER STRINGS    */
00680000    /*              IN THE PRINT LINES DESCRIBING EACH INDIVIDUAL ENTRY.  THE      */
00690000    /*              ENTRY MATCHING TECHNIQUE USED BY SMPSCAN IS BASED ON ENTRY     */
00700000    /*              TYPE AND ON ENTRY NAME WITHIN TYPE.  THE ADVANTAGES OF USING   */
00710000    /*              A CHARACTER STRING SCAN APPROACH ARE THAT ALTHOUGH CONTROL     */
00720000    /*              FILES MAY REQUIRE CHANGE TO ACCOMMODATE NEW RELEASES OR        */
00730000    /*              LEVELS OF SMP/E, THE PROGRAM ITSELF WILL NOT, IN GENERAL, BE   */
00740000    /*              SENSITIVE TO CHANGES IN THE NAMES OF DATA FIELDS NOR WILL IT   */
00750000    /*              BE HIGHLY SENSITIVE TO THE COLUMN LOCATIONS IN WHICH GIVEN     */
00760000    /*              VALUES APPEAR.                                                 */
00770000    /*                                                                             */
00780000    /*             .THE MAJOR DISADVANTAGE FROM PROCESSING LISTINGS RATHER THAN    */
00790000    /*              THE ZONE DATA BASES DIRECTLY IS THAT THE RESULTING             */
00800000    /*              IMPLEMENTATION IS BATCH-ONLY.  THERE ARE ADDITIONAL RESOURCE   */
00810000    /*              COSTS BOTH FOR LISTING THE ENIRE ZONE CONTENTS OF POSSIBLE     */
00820000    /*              INTEREST TO DISK DATA SETS, AND FOR USING CHARACTER STRING     */
00830000    /*              SCAN TECHNIQUES RATHER THAN INDEX SEARCHES TO TRACK DOWN THE   */
00840000    /*              ENTRIES OF INTEREST.                                           */
00850000    /*                                                                             */
00860000    /*                                                                             */
00870000    /*   SOURCE    .IBM PLI OPTIMIZING COMPILER AT VERSION 1 RELEASE 5.1 LEVEL.    */
00880000    /*   LANGUAGE                                                                  */
00890000    /*                                                                             */
00900000    /*                                                                             */
00910000    /*   MODULE    .NOT REENTRANT.  THE MODULE IS CODED REENTRANTLY WITHOUT        */
00920000    /*   ATTRIBUTES     MODIFICATIONS TO STATIC STORAGE, BUT SEVERAL FILES ARE     */
00930000    /*              OPENED AND USED BY THE PROGRAM.  ALSO, WITH PLI VERSION 1      */
00940000    /*              RELEASE 5.1, THE RESULTING LOAD MODULE HAS AMODE=31,           */
00950000    /*              RMODE=ANY.                                                     */
00960000    /*                                                                             */
00970000    /*             .THE COMPILE-TIME OPTIONS USED AT COMMERCIAL UNION FOR          */
00980000    /*              COMPILING THIS PROGRAM WERE SPECIFIED USING "*PROCESS"         */
00990000    /*              STATEMENTS.  THESE ARE INCLUDED AT THE BEGINNING OF THE        */
01000000    /*              SOURCE PROGRAM.  EXECUTION TIME PERFORMANCE MAY BE IMPROVED    */
01010000    /*              IF DESIRED BY DELETING THE "*PROCESS" STATEMENT REQUESTING     */
01020000    /*              THE COUNT AND FLOW OPTIONS.                                    */
01030000    /*                                                                             */
01040000    /*             .THE EXECUTION-TIME PLI OPTIONS FOR THIS PROGRAM AT             */
01050000    /*              COMMERCIAL UNION WERE INCORPORATED INTO THE PROGRAM VIA A      */
01060000    /*              DECLARATION FOR THE STATIC VARIABLE "PLIXOPT".  AN ISASIZE     */
01070000    /*              HAS BEEN SPECIFIED TO ELIMINATE THE NEED FOR USE OF THE        */
01080000    /*              SYSTEM GETMAIN/FREEMAIN ROUTINES TO SATISFY STORAGE            */
01090000    /*              REQUESTS, AND THE HEAP OPTION HAS BEEN SPECIFIED TO ALLOW      */
01100000    /*              VIRTUAL STORAGE USE ABOVE THE 16 MEGABYTE LINE.                */
01110000    /*                                                                             */
01120000    /*                                                                             */
01130000    /*   ENTRY     .THIS PROGRAM IS NAMED "SMPSCAN", ALTHOUGH                      */
01140000    /*   POINT      PLI LOAD MODULES USE AN ENTRY POINT OF "PLISTART".             */
01150000    /*                                                                             */
01160000    /*                                                                             */
01170000    /*   INPUT     .THE PARM FIELD OF THE EXEC STATEMENT IS NOT CURRENTLY USED     */
01180000    /*              TO PASS EXECUTION-TIME VALUES TO SMPSCAN.  PRELIMINARY         */
01190000    /*              SUPPORT HAS BEEN INCLUDED IN THE PROGRAM TO MAKE IT FAIRLY     */
01200000    /*              EASY TO PROVIDE THIS SUPPORT LATER ON IF DESIRED.  VARIABLES   */
01210000    /*              THAT MIGHT BE GOOD CANDIDATES FOR INCLUSION IN THIS TYPE OF    */
01220000    /*              SUPPORT INCLUDE: DDIPFX, DDOPFX, IFILE_MAX, IPLANE_MAX,        */
01230000    /*              IROW_MAX, ICOL_MAX, AND IMATCH_MAX.  THE "SYSIN" CONTROL       */
01240000    /*              CARD DATA SET COULD ALSO BE ADAPTED TO USE A WIDER OR          */
01250000    /*              VARIABLE RECORD SIZE.                                          */
01260000    /*                                                                             */
01270000    /*             .INPUT TO SMPSCAN IS PROVIDED BY THE FOLLOWING INPUT DATA       */
01280000    /*              SETS:                                                          */
01290000    /*                                                                             */
01300000    /*                -THE CONTROL VARIABLE INPUT DATA SET, DDNAME=SYSIN           */
01310000    /*                 (RECFM=FB, LRECL=80), CONTAINS VALUES TO DESIGNATE WHICH    */
01320000    /*                 FILES ARE TO BE ACTIVE (UP TO 16 ARE SUPPORTED).  OTHER     */
01330000    /*                 VARIABLES FROM THIS INPUT DATA SET CONTROL THE SCAN         */
01340000    /*                 SELECTION AND MATCHING OF ENTRIES FROM EACH OF THE          */
01350000    /*                 SMPLIST INPUT DATA SETS, AND VARY THE AMOUNT OF OUTPUT      */
01360000    /*                 GENERATED TO EACH CORRESPONDING "SMPDATA" DATA SET.  FOR    */
01370000    /*                 PROGRAMMING SIMPLICITY AND TO AVOID THIS PROGRAM'S          */
01380000    /*                 BECOMMING A MAJOR DEVELOPMENT EFFORT, PLI GET DATA MODE     */
01390000    /*                 WAS USED TO PROCESS EACH "SYSIN" INPUT RECORD.              */
01400000    /*                 CONSEQUENTLY, ALL CHARACTER STRING VALUES MUST BE           */
01410000    /*                 ENCLOSED IN QUOTES.  THE FOLLOWING PROGRAM CONTROL          */
01420000    /*                 VARIABLES ARE READ FROM "SYSIN":                            */
01430000    /*                                                                             */
01440000    /*                    FILE_ACTIVE_OPTION(FILE#)                                */
01450000    /*                    DATA_OUTPUT_OPTION(FILE#)                                */
01460000    /*                                                                             */
01470000    /*                    SCAN_ARRAY.SELECT(FILE#)                                 */
01480000    /*                    SCAN_ARRAY.PLANE.SELECT(FILE#,PLANE#),                   */
01490000    /*                    SCAN_ARRAY.PLANE.ROW.SELECT(FILE#,PLANE#,ROW#),          */
01500000    /*                    SCAN_ARRAY.PLANE.ROW.COL.OP(FILE#,PLANE#,ROW#,COL#),     */
01510000    /*                    SCAN_ARRAY.PLANE.ROW.COL.STRING(FILE#,PLANE#,ROW#,COL#)  */
01520000    /*                    SCAN_ARRAY.PLANE.ROW.COL.BEG_POS(FILE#,PLANE#,ROW#,COL#) */
01530000    /*                    SCAN_ARRAY.PLANE.ROW.COL.END_POS(FILE#,PLANE#,ROW#,COL#) */
01540000    /*                    SCAN_ARRAY.PLANE.ROW.COL.POS_LEN(FILE#,PLANE#,ROW#,COL#) */
01550000    /*                                                                             */
01560000    /*                    MATCH_ARRAY.ENTRY.TYPE(MATCH#)                           */
01570000    /*                    MATCH_ARRAY.ENTRY.COMPARE_TEST(MATCH#)                   */
01580000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_OPTION(MATCH#,FILE#)      */
01590000    /*                    MATCH_ARRAY.ENTRY.FILE.COMPARE_SELECT(MATCH#,FILE#)      */
01600000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_OPTION(MATCH#,FILE#)        */
01610000    /*                    MATCH_ARRAY.ENTRY.FILE.WRITE_SELECT(MATCH#,FILE#)        */
01620000    /*                                                                             */
01630000    /*                 PLI DATA MODE DOES NOT ALLOW SUBSCRIPTS TO BE               */
01640000    /*                 INTERLEAVED, AND CHARACTER STRING VALUES MUST BE ENCLOSED   */
01650000    /*                 IN QUOTES.  A TERMINATING SEMICOLON IS NOT REQUIRED ON      */
01660000    /*                 THE SYSIN CONTROL CARDS - IT IS SUPPLIED INTERNALLY FOR     */
01670000    /*                 THE "GET DATA" STATEMENT BY SMPSCAN.  TO ALLOW THE INPUT    */
01680000    /*                 DATA TO BE SELF-DOCUMENTING, A CONTROL CARD WITH AN "*"     */
01690000    /*                 IN COLUMN 001 IS CONSIDERED TO BE A COMMENT RECORD, AND     */
01700000    /*                 IT IS BYPASSED.  PLI GET DATA MODE DOES NOT ALLOW USE OF    */
01710000    /*                 THE PLI-STYLE COMMENTS ON RECORDS PROCESSED BY "GET         */
01720000    /*                 DATA".                                                      */
01730000    /*                                                                             */
01740000    /*                 THE MEANING OF THE ABOVE VARIABLES, AND THE ALLOWABLE       */
01750000    /*                 VALUES FOR THEM ARE DESCRIBED IN THE FACILITIES/FEATURES    */
01760000    /*                 SECTION BELOW.                                              */
01770000    /*                                                                             */
01780000    /*                -THE SMP/E LIST INPUT DATA SETS,                             */
01790000    /*                 DDNAMES=(SMPLIST1-SMPLIST9, SMPLST10-SMPLST16)              */
01800000    /*                 DCB=(RECFM=FBA,LRECL=121) CONTAIN THE OUTPUT WRITTEN TO     */
01810000    /*                 THE "SMPLIST" DATA SET DURING AN SMP/E                      */
01820000    /*                 "SET_BDY(ZONENAME)./LIST."  RUN.  THIS DATA CAN COME        */
01830000    /*                 DIRECTLY FROM EXECUTION OF SMP/E, OR FROM A DATA WRITTEN    */
01840000    /*                 TO AN "SMPSOUT" DATA SET DURING A PREVIOUS EXECUTION OF     */
01850000    /*                 SMPSCAN.  THE "XREF" OPTION CAN BE SPECIFIED ON THE SMP/E   */
01860000    /*                 LIST COMMAND, IF IT IS SUPPORTED FOR THE ZONE BEING         */
01870000    /*                 LISTED.  EACH SMP/E LIST DATA SET USED AS INPUT TO          */
01880000    /*                 SMPSCAN MUST CONTAIN DATA FOR A SINGLE ZONE - "LIST         */
01890000    /*                 ALLZONES" OUTPUT IS NOT SUPPORTED AS INPUT BY SMPSCAN.      */
01900000    /*                 CROSS-ZONE MATCHING VIA SMPSCAN IS ACCOMPLISHED BY          */
01910000    /*                 PROCESSING SEPARATE LIST DATA SETS, ONE FOR EACH ZONE OF    */
01920000    /*                 INTEREST.                                                   */
01930000    /*                                                                             */
01940000    /*                                                                             */
01950000    /*   WORK/     .SMPSCAN EXECUTION REQUIRES USE OF TEMPORARY WORK DATA SETS     */
01960000    /*   SPILL      OR "SPILL" FILES FOR SAVING ENTRY LISTINGS WHOSE SIZE          */
01970000    /*   FILES      EXCEEDS THE COMPILED CAPACITY OF SMPSCAN.  THERE ARE UP TO     */
01980000    /*              16 OF THESE DATA SETS, ONE FOR EACH OF THE ACTIVE INPUT        */
01990000    /*              LISTING FILES. THE DDNAMES ARE SMPUT1-9, SMPUT10-16, AND THE   */
02000000    /*              DCB ATTRIBUTES ARE (RECFM=FB, LRECL=120).  PRINT CONTROL       */
02010000    /*              CHARACTERS ARE NOT SAVED WITH THE LISTING LINES.  THE SPILL    */
02020000    /*              FILE IS USED WHENEVER THE ENTRY MATCHING CRITERIA PROVIDED     */
02030000    /*              IN "MATCH_ARRAY" INDICATE THAT THE ENTRY COULD POSSIBLY BE     */
02040000    /*              WRITTEN TO AN OUTPUT DATA SET.                                 */
02050000    /*                                                                             */
02060000    /*              THE WORK/SPILL FILES CAN BE ALLOCATED TO ANY MEDIUM            */
02070000    /*              SUPPORTING SEQUENTIAL INPUT AND OUTPUT TO THE SAME DATA SET    */
02080000    /*              (E.G., DASD OR VIO).  AS EACH ENTRY LISTING LINE IS READ       */
02090000    /*              FROM THE "SMPLIST" INPUT DATA SET AND AND PROCESSED AGAINST    */
02100000    /*              THE FILE'S SCAN_ARRAY, THE LINE IS SAVED IN AN ARRAY IN        */
02110000    /*              STORAGE.  IF THE NUMBER OF LINES IN AN ENTRY LISTING EXCEEDS   */
02120000    /*              THE LIMIT SPECIFIED IN SMPSCAN PROGRAM VARIABLE                */
02130000    /*              "LINE_SAVE_LIMIT" (CURRENTLY SET AT 100), THE WORK FILE IS     */
02140000    /*              OPENED FOR OUTPUT, AND THE LINES BEYOND 100 (101, 102, ETC.)   */
02150000    /*              ARE WRITTEN TO IT.  IF, ONCE THE ENTRY HAS BEEN FULLY READ,    */
02160000    /*              IT IS DETERMINED THAT THE ENTRY SATISFIES THE SCAN SELECTION   */
02170000    /*              AND FILE MATCHING CRITERIA SUPPLIED BY THE USER, THE WORK      */
02180000    /*              FILE IS REOPENED FOR INPUT AND THE SAVED LINES ARE REREAD.     */
02190000    /*              TOTALS OF THE NUMBER OF TIMES AN ENTRY WAS SAVED IN            */
02200000    /*              ANTICIPATION OF ITS POSSIBLY BEING NEEDED, THE NUMBER OF       */
02210000    /*              TIMES THE WORK FILE WAS OPENED FOR OUTPUT(WRITE OPEN/LINE      */
02220000    /*              COUNTS) AND FOR INPUT(READ OPEN/LINE COUNTS) ARE DISPLAYED     */
02230000    /*              IN THE FINAL TOTALS SECTION AT THE END OF THE "SMPDCTRY"       */
02240000    /*              REPORT DATA SET.                                               */
02250000    /*                                                                             */
02260000    /*                                                                             */
02270000    /*   OUTPUT    .SMPSCAN PRODUCES NO OPERATOR MESSAGES - THE PLI "DISPLAY"      */
02280000    /*              STATEMENT IS NOT USED.                                         */
02290000    /*                                                                             */
02300000    /*             .SMPSCAN PRODUCES FOUR GROUPS OF OUTPUT DATA SETS:              */
02310000    /*                                                                             */
02320000    /*                -THE EXECUTION PROCESSING REPORT,                            */
02330000    /*                 DDNAME=PTSDCTRY(RECFM=FBA,LRECL=133), CONTAINS MESSAGES     */
02340000    /*                 AND COMMENTS DOCUMENTING THIS EXECUTION OF SMPSCAN.         */
02350000    /*                 REGARDLESS OF THE NUMBER OF ACTIVE INPUT LISTING FILES,     */
02360000    /*                 ONLY ONE SMPDCTRY DATA SET IS PRODUCED FOR AN EXECUTION     */
02370000    /*                 OF SMPSCAN.  THE SMPDCTRY DATA SET REPORT CONTAINS FOUR     */
02380000    /*                 SECTIONS:                                                   */
02390000    /*                                                                             */
02400000    /*                   1). INITIAL FILE INFORMATION AND SCAN_ARRAY CONTENTS.     */
02410000    /*                   2). MATCH STATUS INFORMATION AND MATCH_ARRAY CONTENTS.    */
02420000    /*                   3). DIRECTORY OF MATCHING ENTRIES (ONE SECTION FOR EACH   */
02430000    /*                       DISTINCT TYPE OF ENTRY MATCHED).                      */
02440000    /*                   4). FINAL PROCESSING TOTALS BY FILE, AND BY ENTRY TYPE    */
02450000    /*                       WITHIN FILE.                                          */
02460000    /*                                                                             */
02470000    /*                 THE FIRST TWO SECTIONS ARE PRODUCED DURING SMPSCAN          */
02480000    /*                 INITIALIZATION AND STARTUP, THE THIRD SECTION IS PRODUCED   */
02490000    /*                 AS THE INPUT FILES ARE READ AND ENTRIES ARE MATCHED, AND    */
02500000    /*                 THE LAST SECTION IS PRODUCED AFTER ALL INPUT FILES HAVE     */
02510000    /*                 BEEN READ AND ALL MATCHING OUTPUT PRODUCED.                 */
02520000    /*                                                                             */
02530000    /*                -THE MATCHED ENTRY HIGHLIGHTED OUTPUT DATA SETS,             */
02540000    /*                 DDNAMES=(SMPSCAN1-SMPSCAN9,SMPSCN10-SMPSCN16)               */
02550000    /*                 DCB=(RECFM=FBA,LRECL=133), CONTAIN LISTINGS OF THE          */
02560000    /*                 MATCHING ENTRIES.  THERE IS ONE OF THESE DATA SETS FOR      */
02570000    /*                 EACH ACTIVE INPUT DATA SET.  THIS DATA SET, WHEN PRINTED,   */
02580000    /*                 LOOKS LIKE THE SMPLIST OUTPUT FROM SMP/E, BUT THE DATA      */
02590000    /*                 SETS ARE NOT COMPATIBLE.  PAGE TITLES AND LINE SPACING      */
02600000    /*                 APPEAR THE SAME UPON PRINTING AND RECFM IS THE SAME, BUT    */
02610000    /*                 THE LRECL IS LARGER (133 VS 121), AND THE TOP-OF-PAGE       */
02620000    /*                 TITLE REFERENCES SMPSCAN RATHER THAN SMPLIST.  IN           */
02630000    /*                 ADDITION, THOSE LINES SELECTED BY COMPARISON WITH THE       */
02640000    /*                 FILE'S SCAN_ARRAY ARE FLAGGED ON THE RIGHT WITH             */
02650000    /*                 "**PPP,RRR**" AND SELECTING CHARACTER STRINGS ARE           */
02660000    /*                 UNDERSCORED.  THE FLAG ON THE RIGHT OF A HIGHLIGHTED LINE   */
02670000    /*                 REFERENCES THE PLANE("PPP") AND ROW("RRR") OF THE FILE'S    */
02680000    /*                 SCAN_ARRAY THAT RESULTED IN THE SUCCESSFUL COMPARISON.      */
02690000    /*                 AN UNDERSCORE LINE IS PRODUCED ONLY FOR THE FIRST           */
02700000    /*                 SUCCESSFUL ROW OF THE FILE'S SCAN_ARRAY.  NOTE: AN ENTRY    */
02710000    /*                 THAT WAS CHOSEN BECAUSE AN EXCLUDE CRITERION WAS            */
02720000    /*                 SATISFIED WILL NOT SHOW CORRESPONDING HIGHLIGHTED LINES     */
02730000    /*                 BECAUSE THE CHARACTER STRING(S) DON'T APPEAR IN THE         */
02740000    /*                 ENTRY.                                                      */
02750000    /*                                                                             */
02760000    /*                -THE MATCHED ENTRY SMPLIST OUTPUT DATA SETS,                 */
02770000    /*                 DDNAMES=(SMPSOUT1-SMPSOUT9,SMPSOU10-SMPSOU16)               */
02780000    /*                 DCB=(RECFM=FBA,LRECL=121), CONTAIN LISTINGS OF THE          */
02790000    /*                 MATCHING ENTRIES.  THESE ARE THE SAME ENTRIES LISTED IN     */
02800000    /*                 THE HIGHLIGHTED OUTPUT ("SCAN") DATA SETS, BUT WITHOUT      */
02810000    /*                 HIGHLIGHTING INFORMATION.  THERE IS ONE OF THESE DATA       */
02820000    /*                 SETS FOR EACH ACTIVE INPUT DATA SET. THIS OUTPUT DATA SET   */
02830000    /*                 IS PRODUCED IN THE SAME FORMAT AND WITH THE SAME DCB        */
02840000    /*                 ATTRIBUTES AS THE SMPLIST OUTPUT FROM SMP/E (RECFM,         */
02850000    /*                 LRECL, PRINT CONTROL CHARACTERS, PAGE TITLES, AND LINE      */
02860000    /*                 SPACINGS ARE THE SAME).  THE DATA SET CAN BE PRINTED, BUT   */
02870000    /*                 IT IS NORMALLY USED TO PROVIDE INPUT (VIA SMPLIST           */
02880000    /*                 DDNAMES) TO A FOLLOW-ON EXECUTION OF SMPSCAN USING          */
02890000    /*                 DIFFERENT SELECTION CRITERIA.  IT CAN ALSO BE PASSED TO     */
02900000    /*                 OTHER PROGRAMS WHICH PROCESS SMP/E SMPLIST OUTPUT SUCH AS   */
02910000    /*                 THOSE FOUND ON SHARE OR GUIDE MODS TAPES.                   */
02920000    /*                                                                             */
02930000    /*                -THE MATCHED ENTRY CARD-IMAGE OUTPUT DATA SET,               */
02940000    /*                 DDNAMES=(SMPDATA1-SMPDATA9,SMPDAT10-SMPDAT16)               */
02950000    /*                 DCB=(RECFM=FB,LRECL=080), CONTAINS LISTING LINES FROM THE   */
02960000    /*                 SELECTED ENTRIES MAPPED FROM A 120 CHARACTER PRINT LINE     */
02970000    /*                 ONTO ONE OR MORE 80 BYTE CARD IMAGE RECORDS.  THERE IS      */
02980000    /*                 ONE OF THESE DATA SETS FOR EACH ACTIVE INPUT DATA SET.      */
02990000    /*                 DATA FROM EACH PRINT LINE IS MAPPED WITH ENCLOSING          */
03000000    /*                 COMMENT CHARACTERS SO THAT ONLY THE ENTRY NAME, SMP         */
03010000    /*                 M.C.S.  CONTROL STATEMENTS, ASSEM ENTRY ASSEMBLER SOURCE    */
03020000    /*                 STATEMENTS, AND LMOD ENTRY LINKAGE EDITOR CONTROL           */
03030000    /*                 STATEMENTS ARE MAPPED OUTSIDE COMMENT CHARACTERS.  THE      */
03040000    /*                 DATA SET IS THUS USUALLY SUITABLE FOR DIRECT USE IN AN      */
03050000    /*                 SMP CONTROL STATEMENT (SUCH AS "APPLY").  IT CAN ALSO BE    */
03060000    /*                 PROCESSED BY ANY AVAILABLE INTERACTIVE EDITOR TO PRODUCE    */
03070000    /*                 FURTHER RESULTS.  THE AMOUNT OF DATA WRITTEN TO THIS DATA   */
03080000    /*                 SET DEPENDS ON THE SETTING OF THE "DATA_OUTPUT_OPTION"      */
03090000    /*                 VARIABLE FOR THAT FILE.  THE ALLOWABLE VALUES AND           */
03100000    /*                 ASSOCIATED OUTPUT ARE DESCRIBED IN THE                      */
03110000    /*                 FEATURES/FACILITIES SECTION BELOW.                          */
03120000    /*                                                                             */
03130000    /*             .IN ADDITION TO THE DATA SETS PRODUCED BY SMPSCAN, THE          */
03140000    /*              FOLLOWING ADDITIONAL DATA SETS MAY BE REQUIRED BECAUSE THE     */
03150000    /*              PROGRAM IS WRITTEN IN PLI.  BOTH OF THESE DATA SETS SHOULD     */
03160000    /*              BE ASSIGNED TO SYSOUT, OR DUMMIED OUT:                         */
03170000    /*                                                                             */
03180000    /*                -DDNAME=SYSPRINT IS REQUIRED IF AN ERROR IN PROGRAM          */
03190000    /*                 EXECUTION OCCURS.                                           */
03200000    /*                                                                             */
03210000    /*                -DDNAME=PLIDUMP IS REQUIRED WHEN THE PROGRAM HAS BEEN        */
03220000    /*                 COMPILED WITH WITH THE "COUNT" OR "FLOW" ATTRIBUTES, OR     */
03230000    /*                 WHEN THE "REPORT" OPTION IS USED DURING PROGRAM EXECUTION   */
03240000    /*                 TO MONITOR ISA AND HEAP STORAGE USE.                        */
03250000    /*                                                                             */
03260000    /*                                                                             */
03270000    /*   RESTRICTIONS/LIMITATIONS                                                  */
03280000    /*                                                                             */
03290000    /*             .SMPSCAN HAS BEEN COMPILED UNDER IBM'S PLI OPTIMIZING           */
03300000    /*              COMPILER VERSION 1 RELEASE 5.1 AND SUCCESSFULLY EXECUTED ON    */
03310000    /*              MVS/SP LEVEL 2.1.3.  NO OTHER EXECUTION ENVIRONMENTS HAVE      */
03320000    /*              BEEN TESTED WITH THIS PROGRAM SINCE THE SITE AT WHICH THIS     */
03330000    /*              PROGRAM WAS DEVELOPED IS EXCLUSIVELY MVS/XA AND VM/SP.         */
03340000    /*                                                                             */
03350000    /*             .COMPILATION AND EXECUTION USING THE PLI OPTIMIZING COMPLIER    */
03360000    /*              AND LIBRARIES AT VERSION 1 RELEASE 4.0 LEVEL PRODUCED A LOAD   */
03370000    /*              MODULE WHICH FAILED TO EXECUTE.  WE TURNED OFF THE             */
03380000    /*              "OPTIMIZE(TIME)" OPTION AT COMPILATION AND MADE TEMPORARY      */
03390000    /*              PROGRAM CHANGES TO CIRCUMVENT THE PROBLEM UNTIL THE RELEASE    */
03400000    /*              5.1 LEVEL OF THE COMPILER WAS INSTALLED.  WHILE WE SUSPECT     */
03410000    /*              THESE PROBLEMS WERE RELATED TO THE MAINTENANCE LEVEL OF OUR    */
03420000    /*              4.0 COMPILER, WE DID NOT RESEARCH THE PROBLEM IN DEPTH.  IT    */
03430000    /*              MADE MORE SENSE TO US TO GET THE 5.1 LEVEL OF THE COMPILER     */
03440000    /*              AND LIBRARIES UP AND OPERATIONAL SINCE WE HAD OTHER            */
03450000    /*              REQUIREMENTS FOR THEM AS WELL.  IF THE PLI OPTIMIZING          */
03460000    /*              COMPILER AT VERSION 1 RELEASE 5.1 OR LATER LEVEL IS NOT        */
03470000    /*              AVAILABLE AT YOUR INSTALLATION, CONTACT THE AUTHOR FOR         */
03480000    /*              FUTHER DETAILS.                                                */
03490000    /*                                                                             */
03500000    /*             .THE PROGRAM SUPPORTS SMPLIST OUTPUT FROM THE SMP/E "LIST"      */
03510000    /*              COMMAND.  THERE ARE NO ENTRY TYPE PROCESSING RESTRICTIONS AS   */
03520000    /*              THERE WERE IN PTSSCAN.  ALL ENTRY TYPES THAT ARE DEFINED IN    */
03530000    /*              ZONES AND THAT CAN BE LISTED BY SMP/E RELEASE 3 ARE            */
03540000    /*              SUPPORTED BY SMPSCAN.  MOREOVER, SMPSCAN HAS BEEN STRUCTURED   */
03550000    /*              TO MAKE SUPPORT FOR NEW ENTRY TYPES FAIRLY EASY TO ADD.        */
03560000    /*                                                                             */
03570000    /*             .LISTING OF BACKUP ENTRIES FROM THE SCDS, MTSMAC ENTRIES FROM   */
03580000    /*              SMPMTS, AND STSSRC ENTRIES FROM SMPSTS ARE NOT SUPPORTED BY    */
03590000    /*              SMPSCAN AT THIS TIME.                                          */
03600000    /*                                                                             */
03610000    /*             .THIS VERSION OF SMPSCAN HAS BEEN RUN WITH SMPLIST OUTPUT       */
03620000    /*              FROM SMP/E LVL 13.05.                                          */
03630000    /*                                                                             */
03640000    /*             .AT PRESENT, CONCURRENT PROCESSING IS SUPPORTED FOR A MAXIMUM   */
03650000    /*              OF 16 INPUT LISTINGS ALONG WITH ASSOCIATED OUTPUT DATA SETS.   */
03660000    /*                                                                             */
03670000    /*             .ERROR ROUTINES TO ALLOW FOR RECOVERY FROM MISSING DD           */
03680000    /*              STATEMENTS ARE NOT CODED INTO SMPSCAN AT THIS TIME.  THUS,     */
03690000    /*              IF AN OUTPUT DATA SET IS NOT WANTED, A "DD DUMMY" JCL          */
03700000    /*              STATEMENT SHOULD BE SUPPLIED FOR THE UNWANTED OUTPUT DATA      */
03710000    /*              SET, OR THE PROGRAM WILL END IN ERROR WITHOUT PROCESSING ANY   */
03720000    /*              DATA.                                                          */
03730000    /*                                                                             */
03740000    /*                                                                             */
03750000    /*   FACILITIES/FEATURES                                                       */
03760000    /*                                                                             */
03770000    /*            THIS PROGRAM READS SMP/E "SET_BDY(ZONENAME)./LIST."  OUTPUT      */
03780000    /*      LISTINGS FROM DDNAME=SMPLIST THAT HAVE BEEN WRITTEN TO DISK OR TAPE    */
03790000    /*      DATA SETS RATHER THAN SYSOUT.  UP TO 16 LISTING DATA SETS CAN BE       */
03800000    /*      SCANNED AND MATCHED CONCURRENTLY.  ALL ENTRY TYPES ARE SUPPORTED.      */
03810000    /*      AS ENTRY LISTINGS ARE READ, SMPSCAN SCANS EACH ENTRY FOR CHARACTER     */
03820000    /*      STRINGS AS SPECIFIED BY THE FILE'S "SCAN_ARRAY".  BASED ON THE         */
03830000    /*      RESULTS OF THESE SCANS AND ON THE FILE MATCHING INSTRUCTIONS FROM      */
03840000    /*      THE "MATCH_ARRAY", SMPSCAN PRODUCES OUTPUT DATA SETS CONTAINING DATA   */
03850000    /*      FROM THOSE ENTRIES SATISFYING THE COMBINATION OF SCAN SELECTION AND    */
03860000    /*      MATCH CRITERIA SPECIFIED.                                              */
03870000    /*                                                                             */
03880000    /*            PROGRAM EXECUTION IS CONTROLLED BY VALUES SPECIFIED FOR          */
03890000    /*      PROGRAM VARIABLES IN THE "SYSIN" DATA SET.  THE "SYSIN" DATA SET IS    */
03900000    /*      DEFINED AS A "RECORD" DATA SET.  PLI "GET STRING DATA" IS USED TO      */
03910000    /*      EXTRACT VALUES FROM EACH "SYSIN" INPUT RECORD ONCE IT HAS BEEN READ.   */
03920000    /*      THIS TECHNIQUE WAS USED TO ALLOW COMMENT RECORDS TO BE INCLUDED WITH   */
03930000    /*      THE VARIABLES AND THEIR VALUES.  IF AN "*" APPEARS IN BYTE 1 OF A      */
03940000    /*      SYSIN INPUT RECORD, THE RECORD IS CONSIDERED A COMMENT.  SMPSCAN       */
03950000    /*      BYPASSES COMMENT RECORDS.  WHEN A RECORD IS NOT A COMMENT, BYTES       */
03960000    /*      01-72 OF THE INPUT RECORD ARE PROCESSED AS DATA - BYTES 73-80 ARE      */
03970000    /*      IGNORED AND CAN CONTAIN SEQUENCE NUMBERS IF DESIRED.  IT IS NOT        */
03980000    /*      NECESSARY TO INCLUDE A SEMI-COLON IN "SYSIN" INPUT RECORDS FOR GET     */
03990000    /*      DATA MODE PROCESSING.  SMPSCAN APPENDS A SEMI-COLON TO THE END OF      */
04000000    /*      THE DATA PORTION OF THE RECORD BEFORE DOING THE "GET STRING DATA"      */
04010000    /*      FUNCTION.  BECAUSE PLI "GET DATA" IS USED TO READ THE INPUT            */
04020000    /*      SPECIFICATIONS, THE SPECIFICATIONS MUST HAVE ONE OF THE FOLLOWING      */
04030000    /*      FORMS:                                                                 */
04040000    /*                                                                             */
04050000    /*                 VARIABLE_NAME(SUBSCRIPTS) = NUMBER                          */
04060000    /*            OR   VARIABLE_NAME(SUBSCRIPTS) = 'VALUE'                         */
04070000    /*                                                                             */
04080000    /*      THE VALUE SPECIFICATION FOR CHARACTER STRINGS MUST BE ENCLOSED IN      */
04090000    /*      QUOTES BECAUSE THE CONTROL VARIABLES ARE DECLARED AS PLI CHARACTER     */
04100000    /*      STRINGS. FURTHERMORE, SUBSCRIPTS MUST BE SPECIFIED TOGETHER            */
04110000    /*      FOLLOWING THE VARIABLE NAME AND ALL QUALIFICATIONS.  UNLIKE THE PLI    */
04120000    /*      COMPILER, PLI GET DATA MODE DOES NOT SUPPORT INTERLEAVED SUBSCRIPTS.   */
04130000    /*      PROGRAM CONTROL VARIABLES THAT CAN BE SPECIFIED IN THE CONTROL         */
04140000    /*      VARIABLE INPUT DATA SET WERE LISTED IN THE "INPUT" SECTION ABOVE.      */
04150000    /*      THE MEANING OF THESE VARIABLES, THEIR EFFECTS ON PROGRAM EXECUTION,    */
04160000    /*      AND THEIR VALID RANGES OF VALUES, WILL NOW BE DESCRIBED.               */
04170000    /*                                                                             */
04180000    /*            >>>>>FILE_ACTIVE_OPTION(FILE#).<<<<<                             */
04190000    /*            THIS VARIABLE SPECIFIES WHICH FILES ARE TO BE ACTIVE DURING      */
04200000    /*      THIS EXECUTION OF SMPSCAN.  IT IS DECLARED WITHIN SMPSCAN AS A         */
04210000    /*      ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER STRINGS WITH THE     */
04220000    /*      SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER: 01-16.  THE         */
04230000    /*      VALUES THAT CAN BE SPECIFIED ARE:                                      */
04240000    /*                                                                             */
04250000    /*                 'ACTIVE'                                                    */
04260000    /*                 'INACTIVE'                                                  */
04270000    /*                                                                             */
04280000    /*      THE DEFAULT SPECIFICATION IS "INACTIVE" TO INSURE THAT FILES ARE       */
04290000    /*      EXPLICITLY ACTIVATED.  IF A FILE IS "ACTIVATED", THE CORRESPONDING     */
04300000    /*      "LIST", "SCAN" AND "SOUT" DD STATEMENTS MUST BE SUPPLIED.  THE         */
04310000    /*      CORRESPONDING "DATA" DD STATEMENT IS ALSO REQUIRED UNLESS              */
04320000    /*      DATA_OUTPUT_OPTION FOR THE FILE IS SET TO "NONE" (SEE BELOW).          */
04330000    /*                                                                             */
04340001    /*            >>>>>DATA_OUTPUT_OPTION(FILE#).<<<<<                             */
04350000    /*            THIS VARIABLE CONTROLS THE AMOUNT OF OUTPUT WRITTEN TO EACH      */
04360000    /*      ACTIVE CARD-IMAGE (SMPDATA1-SMPDATA9, SMPDAT10-SMPDAT16) OUTPUT DATA   */
04370000    /*      SET FOR MATCHING ENTRIES.  THE SELECTION OF ENTRIES TO BE WRITTEN IS   */
04380000    /*      CONTROLLED BY THE FILE'S SCAN_ARRAY CONTENTS, AND BY THE               */
04390000    /*      MATCH_ARRAY.  THE DATA_OUTPUT_OPTION VARIABLE IS DECLARED WITHIN       */
04400000    /*      SMPSCAN AS A ONE-DIMENSIONAL ARRAY OF VARYING LENGTH CHARACTER         */
04410000    /*      STRINGS WITH THE SINGLE SUBSCRIPT CORRESPONDING TO THE FILE NUMBER:    */
04420000    /*      01-16.  THE VALUES THAT CAN BE SPECIFIED ARE:                          */
04430000    /*                                                                             */
04440000    /*                 'NONE'                                                      */
04450000    /*                 'ID1'                                                       */
04460000    /*                 'ID'                                                        */
04470000    /*                 'SELECT'                                                    */
04480000    /*                 'ALL'                                                       */
04490000    /*                                                                             */
04500000    /*      THE DEFAULT SPECIFICATION IS "NONE".  CONSEQUENTLY, THE "DATA" DD      */
04510000    /*      STATEMENT IS OPTIONAL AND IS REQUIRED AND USED ONLY IF EXPLICITLY      */
04520000    /*      REQUESTED, AND IF THE MATCH_ARRAY INDICATES THAT THE DATA SET MAY BE   */
04530000    /*      REQUIRED FOR OUTPUT.  THE OTHER SPECIFICATIONS CONTROL THE AMOUNT OF   */
04540000    /*      DATA THAT WILL BE WRITTEN TO THIS DATA SET BY DESIGNATING WHICH OF A   */
04550000    /*      MATCHING ENTRY'S LINES WILL BE MAPPED FROM 120-CHARACTER PRINT LINES   */
04560000    /*      ONTO 80-BYTE CARD IMAGE RECORDS.  A VALUE OF "ID1" CAUSES THE FIRST    */
04570000    /*      PART OF THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO A SINGLE   */
04580000    /*      80-BYTE CARD IMAGE.  THE RESULT IS A SINGLE CARD IMAGE FOR EACH        */
04590000    /*      MATCHING ENTRY THAT IS SYNTACTICALLY CORRECT FOR USE WITH              */
04600000    /*      SELECT/EXCLUDE OPERANDS ON SMP/E COMMANDS.  A VALUE OF "ID" CAUSES     */
04610000    /*      THE FIRST LISTING LINE FOR AN ENTRY TO BE MAPPED TO ONE OR MORE CARD   */
04620000    /*      IMAGE RECORDS.  SOME ENTRIES, E.G., M.C.S.  ENTRIES, MAY GENERATE      */
04630000    /*      MORE THAN ONE CARD IMAGE WITH THE "ID" OPTION.  A VALUE OF "SELECT"    */
04640000    /*      CAUSES THE FIRST LISTING LINE OF AN ENTRY, AND ANY LISTING LINE        */
04650000    /*      WHICH WAS SELECTED BY COMPARISON WITH THE FILE'S SCAN_ARRAY TO BE      */
04660000    /*      MAPPED TO CARD IMAGE RECORDS.  LASTLY, A VALUE OF "ALL" CAUSES ALL     */
04670000    /*      LISTING LINES FOR A MATCHING ENTRY TO BE MAPPED ONTO CARD IMAGE        */
04680000    /*      RECORDS, WHETHER SELECTED BY THE FILE'S SCAN_ARRAY, OR NOT.            */
04690000    /*                                                                             */
04700000    /*            >>>>>SCAN_ARRAY.<<<<<                                            */
04710000    /*            SCAN_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO     */
04720000    /*      SEARCH ENTRY LISTING LINES.  TITLE LINES ASIDE, THE FORMAT OF SMP/E    */
04730000    /*      LIST OUTPUT LINES IS QUITE STRAIGHTFORWARD.  WITHOUT RECOURSE TO ANY   */
04740000    /*      INTERNAL INFORMATION ON SMP/E, ONE CAN SEE THAT LISTING LINES ARE      */
04750000    /*      FORMATTED IN FOUR AREAS, THREE OF WHICH ARE SIGNIFICANT:               */
04760000    /*                                                                             */
04770000    /*             .ENTRY NAME:       POSITIONS: 001-008     LENGTH: 008           */
04780000    /*             .LINE TYPE:        POSITIONS: 011-025     LENGTH: 015           */
04790000    /*             .EQUALS SIGN:      POSITION:    027       LENGTH: 001           */
04800000    /*             .LINE DATA:        POSITIONS: 029-120     LENGTH: 092           */
04810000    /*                                                                             */
04820000    /*      THE TYPE OF ENTRY IS DETERMINED FROM THE SECOND TITLE LINE OF THE      */
04830000    /*      PAGE ON WHICH THE ENTRY LISTING BEGINS.  A COMPLETELY BLANK LINE IS    */
04840000    /*      NOT PART OF AN ENTRY LISTING, AND IS DISCARDED.  ON NON-BLANK LINES,   */
04850000    /*      THE ENTRY NAME, LINE TYPE, AND LINE DATA AREAS HAVE A MAJOR TO MINOR   */
04860000    /*      RELATIONSHIP WITHIN AN ENTRY LISTING.  THE ENTRY NAME FIELD CONTAINS   */
04870000    /*      THE NAME OF THE ENTRY.  IF THE ENTRY NAME FIELD IS NON-BLANK, IT       */
04880000    /*      SIGNALS THE START OF A NEW ENTRY LISTING.  IF BLANK, THE LINE IS A     */
04890000    /*      CONTINUATION OF THE CURRENT ENTRY LISTING.  THE LINE TYPE FIELD        */
04900000    /*      CATEGORIZES THE INFORMATION BEING LISTED ABOUT THE ENTRY.  WHEN THIS   */
04910000    /*      AREA IS BLANK THE INFORMATION IN THE LINE DATA AREA IS IN THE SAME     */
04920000    /*      CATEGORY AS THAT ON THE PRECEEDING LINE.  SOMETIMES SMP/E WILL PLACE   */
04930000    /*      CHARACTERS IN THE ENDING POSITIONS OF THE LINE TYPE FIELD, LEAVING     */
04940000    /*      THE BEGINNING BLANK.  IN THESE SITUATIONS IT MADE SENSE TO PROPAGATE   */
04950000    /*      THE NON-BLANK DATA FROM THE PRECEEDING LINE TYPE VALUE.  AN EXAMPLE    */
04960000    /*      OF THIS SITUATION OCCURS WITH "DATA/TIME" LINES.  APPLIED SYSMODS IN   */
04970000    /*      A TARGET ZONE WILL HAVE A "DATA/TIME REC" LINE FOLLOWED BY AN          */
04980000    /*      "__________INS" LINE.  SMPSCAN LOGIC SIMPLY CARRIES FORWARD THE        */
04990000    /*      LEADING VALUE SO THAT THE LINE TYPE BECOMES "DATE/TIME INS".  THE      */
05000000    /*      EQUALS SIGN AREA VISUALLY SEPARATES THE LINE TYPE AREA FROM THE LINE   */
05010000    /*      DATA AREA, BUT OTHERWISE ISN'T SIGNIFICANT.  THE LINE DATA AREA        */
05020000    /*      GENERALLY CONTAINS THE ELEMENTS WITHIN THE LINE TYPE CATEGORY.         */
05030000    /*      EXAMPLES INCLUDE THE LISTS OF ELEMENTS AFFECTED BY A SYSMOD (MACROS,   */
05040000    /*      MODULES), THE DATE AND TIME A SYSMOD WAS RECEIVED OR INSTALLED,        */
05050000    /*      HOLDDATA INFORMATION, AND ASSEMBLER INPUT FOR ASSEMBLER ENTRIES.       */
05060000    /*      SOMETIMES THE LINE TYPE AREA WILL IMPLY A SPECIAL TYPE OF LAYOUT FOR   */
05070000    /*      THE INFORMATION PRINTED IN THE LINE DATA AREA.                         */
05080000    /*                                                                             */
05090000    /*            TO PROVIDE THE FACILITIES NEEDED FOR EFFECTIVE SEARCHING OF      */
05100000    /*      LISTING LINES, FOUR GROUPS OF COMPARE AND SCAN OPERATIONS ARE          */
05110000    /*      DEFINED:                                                               */
05120000    /*                                                                             */
05130000    /*             .ENTRY TYPE COMPARES.  THESE OPERATIONS TEST THE TYPE OF        */
05140000    /*              ENTRY LISTED.  ENTRY TYPE IS DETERMINED FROM THE SECOND        */
05150000    /*              TITLE LINE AND IS NOT PART OF THE ENTRY'S LISTING.             */
05160000    /*                                                                             */
05170000    /*             .LINE TYPE COMPARES.  THESE OPERATIONS TEST THE CONTENTS OF     */
05180000    /*              THE SMPSCAN-CALCULATED LINE TYPE FIELD STORED SEPARATELY FOR   */
05190000    /*              THE LINE.  SMPSCAN LOGICALLY CARRIES FORWARD LINE TYPE         */
05200000    /*              INFORMATION FROM A PREVIOUS LINE IF THIS AREA OF THE CURRENT   */
05210000    /*              LINE IS BLANK.  THE CONTENTS OF THE CURRENT LINE ARE NOT       */
05220000    /*              CHANGED.  BECAUSE SMP/E USES A CARRY-FORWARD LOGIC FOR         */
05230000    /*              FORMATTING THIS VALUE (ALL-BLANKS AND LEADING BLANKS), THESE   */
05240000    /*              OPERATIONS ARE PROCESSED AS "PREFIX" COMPARES.     THE LINE    */
05250000    /*              TYPE FIELD IS COMPARED ONLY UP TO THE LENGTH OF THE            */
05260000    /*              SCAN_ARRAY "STRING", AND "STRING" IS NOT EXTENDED ON THE       */
05270000    /*              RIGHT WITH BLANKS.  BOTH NORMAL (CHARACTER-BY-CHARACTER) AND   */
05280000    /*              GENERIC COMPARE OPERATIONS ARE PROVIDED.                       */
05290000    /*                                                                             */
05300000    /*             .LINE DATA COMPARES.  THESE OPERATIONS EXAMINE DATA ON THE      */
05310000    /*              LISTING LINE.  PROGRAM DEFAULTS ARE SET TO COMPARE AT THE      */
05320000    /*              BEGINNING OF THE LINE DATA AREA (029), BUT LOCATIONS           */
05330000    /*              ANYWHERE ON THE LINE CAN BE COMPARED, INCLUDING THE ENTRY      */
05340000    /*              NAME AND LINE TYPE AREAS.  THE COMPARISON IS DONE ONCE, AT     */
05350000    /*              THE LINE POSITION DESIGNATED IN SCAN_ARRAY VARIABLE            */
05360000    /*              "BEG_POS" (SEE BELOW).  LINE DATA COMPARES DIFFER FROM LINE    */
05370000    /*              TYPE COMPARES IN TWO WAYS:  LINE DATA COMPARES ARE NOT         */
05380000    /*              PREFIX COMPARES, A FIELD LENGTH LONGER THAN THE STRING         */
05390000    /*              LENGTH IS NOT IMPLIED, AND LINE DATA COMPARES ARE NOT          */
05400000    /*              LIMITED TO THE LINE DATA FIELD, DATA ANYWHERE ON THE LINE      */
05410000    /*              CAN BE COMPARED.  BOTH NORMAL AND GENERIC COMPARE OPERATIONS   */
05420000    /*              ARE PROVIDED.                                                  */
05430000    /*                                                                             */
05440000    /*             .LINE DATA SCANS.  THESE OPERATIONS EXAMINE THE DATA ON THE     */
05450000    /*              LISTING LINE FOR ONE OR MORE OCCURRENCES OF A CHARACTER        */
05460000    /*              STRING.  PROGRAM DEFAULTS ARE SET TO SCAN THE BOUNDS OF THE    */
05470000    /*              LINE DATA AREA (029-120), BUT DATA ANYWHERE ON THE LINE CAN    */
05480000    /*              BE SCANNED.  TO REDUCE EXECUTION OVERHEAD, THE FIRST           */
05490000    /*              OCCURRENCE OF A STRING STOPS THE SCAN WHEN TESTING LINES,      */
05500000    /*              BUT ALL OCCURRENCES WILL BE UNDERSCORED IF THE ENTRY IS        */
05510000    /*              WRITTEN WITH HIGHLIGHTED OUTPUT.  SCAN OPERATIONS RESEMBLE     */
05520000    /*              EDIT PROCESSOR "FIND" COMMANDS, EXCEPT THAT THE SCAN           */
05530000    /*              OPERATION IS RESTRICTED TO A SINGLE LINE.  BOTH NORMAL AND     */
05540000    /*              GENERIC SCAN OPERATIONS ARE SUPPORTED.                         */
05550000    /*                                                                             */
05560000    /*            SCAN_ARRAY IS DECLARED WITHIN SMPSCAN AS A FOUR DIMENSIONAL      */
05570000    /*      ARRAY OF STRUCTURES, WITH EACH FILE HAVING A CORRESPONDING             */
05580000    /*      CROSS-SECTION.  THE FIRST SCAN_ARRAY SUBSCRIPT CORRESPONDS TO THE      */
05590000    /*      FILE NUMBER (FILE#) WITHIN SMPSCAN, AND THE REMAINING SUBSCRIPTS       */
05600000    /*      DESIGNATE THE PLANE, ROW, AND COLUMN NUMBERS WITHIN SCAN_ARRAY FOR     */
05610000    /*      THAT FILE.  EACH FILE'S CROSS SECTION OF SCAN_ARRAY CAN BE THOUGHT     */
05620000    /*      OF AS A CUBE.  A CUBE IS MADE UP OF PLANES WHICH IN TURN ARE MADE UP   */
05630000    /*      OF LINES (ROWS) WHICH ARE MADE UP OF POINTS (COLUMNS).  THE            */
05640000    /*      SCAN_ARRAY WAS DESIGNED AS AN ALTERNATIVE TO TRYING TO DESIGN A        */
05650000    /*      BOOLEAN ALGEBRA SYNTAX FOR SEARCHING THE LISTING LINES OF AN ENTRY     */
05660000    /*      FOR CHARACTER STRINGS.  THE PLANE AND ROW DIMENSIONS WERE SET UP TO    */
05670000    /*      PROVIDE "LOGICAL OR(PLANE)" AND "LOGICAL AND(ROW)" CAPABILITY, WHILE   */
05680000    /*      THE COLUMN DIMENSION PROVIDES FOR MULTIPLE CHARACTER STRING TESTS      */
05690000    /*      AGAINST THE SAME LINE.  NEGATION CAPABILITY IS ALSO PROVIDED AT EACH   */
05700000    /*      LEVEL WITHIN A FILE'S CROSS-SECTION SO THAT DE_MORGAN'S RULES          */
05710000    /*      RELATING "LOGICAL AND" AND "LOGICAL OR":                               */
05720000    /*                                                                             */
05730000    /*           ¬(A & B) = ¬A | ¬B      ("|" IS THE PLI SYMBOL FOR "OR")          */
05740000    /*           ¬(A | B) = ¬A & ¬B      ("&" IS THE PLI SYMBOL FOR "AND")         */
05750000    /*                                                                             */
05760000    /*      ALONG WITH SOME OF THEIR USEFUL CONSEQUENCES USING DOUBLE NEGATION     */
05770000    /*      TO EXCHANGE THE ROLES OF "AND" AND "OR":                               */
05780000    /*                                                                             */
05790000    /*            (A & B) = ¬(¬A | ¬B)                                             */
05800000    /*            (A | B) = ¬(¬A & ¬B)                                             */
05810000    /*                                                                             */
05820000    /*           (¬A & B) = ¬( A | ¬B)                                             */
05830000    /*           (¬A | B) = ¬( A & ¬B)                                             */
05840000    /*                                                                             */
05850000    /*      AND THE IDENTITY:                                                      */
05860000    /*                                                                             */
05870000    /*               A    =   ¬(¬A)                                                */
05880000    /*                                                                             */
05890000    /*      CAN BE USED TO USED TO ADVANTAGE.  NEGATION CAPABILITY ALSO ALLOWS     */
05900000    /*      ENTRIES TO BE SELECTED BASED ON CONDITIONS THAT AREN'T SATISFIED       */
05910000    /*      (E.G., TO FIND A SYSMOD THAT DOES CONTAIN JCLIN OR REFERENCES A        */
05920000    /*      SYSGEN MACRO, BUT THAT DOESN'T BELONG TO A PARTICULAR FMID).           */
05930000    /*                                                                             */
05940000    /*            THE STRUCTURAL DECLARATION OF SCAN_ARRAY IS AS FOLLOWS:          */
05950000    /*                                                                             */
05960000    /*            01 SCAN_ARRAY                           CONTROLLED,              */
05970000    /*               05 FILE(IFILE_MIN:IFILE_MAX),       -ONE CUBE FOR EACH FILE-  */
05980000    /*                  09 SELECT_OPTION                  CHAR(008) VARYING,       */
05990000    /*                  09 PLANE(IPLANE_MIN:IPLANE_MAX),                           */
06000000    /*                     13 SELECT_OPTION               CHAR(008) VARYING,       */
06010000    /*                     13 ROW(IROW_MIN:IROW_MAX),                              */
06020000    /*                        17 SELECT_OPTION            CHAR(008) VARYING,       */
06030000    /*                        17 COL(ICOL_MIN:ICOL_MAX),                           */
06040000    /*                           21 BEG_POS               FIXED BINARY(15,0),      */
06050000    /*                           21 END_POS               FIXED BINARY(15,0),      */
06060000    /*                           21 POS_LEN               FIXED BINARY(15,0),      */
06070000    /*                           21 OP                    CHAR(008) VARYING,       */
06080000    /*                           21 OP_OIX                FIXED BINARY(15,0),      */
06090000    /*                           21 STRING                CHAR(032) VARYING,       */
06100000    /*                           21 STR_LEN               FIXED BINARY(15,0),      */
06110000    /*                           21 STR_NIX               FIXED BINARY(15,0),      */
06120000    /*                                                                             */
06130000    /*      IF SCAN_ARRAY VARIABLES ARE SPECIFIED FOR A FILE, A "SCAN_RESULT"      */
06140000    /*      IS CALCULATED FOR EACH ENTRY PROCESSED (SEE THE DESCRIPTION OF         */
06150000    /*      MATCH_ARRAY FOR AN EXPLANATION OF WHEN ENTRIES ARE PROCESSED).         */
06160000    /*      THREE RESULTS ARE RECOGNIZED IN SMPDCTRY OUTPUT:  SCANNED AND          */
06170000    /*      SELECTED, SCANNED AND NOT SELECTED, AND NOT SCANNED.  FOR THE          */
06180000    /*      PURPOSES OF ENTRY MATCHING, HOWEVER, SCANNED AND NOT SELECTED IS       */
06190000    /*      EQUIVALENT TO NOT SCANNED.  THE "SCAN_RESULT" CALCULATION IS A THREE   */
06200000    /*      STEP PROCESS:                                                          */
06210000    /*                                                                             */
06220000    /*           1. WHEN THE FIRST LINE OF A NEW ENTRY IS RECOGNIZED, ALL OF THE   */
06230000    /*              SCAN_ARRAY ROW RESULTS ARE SET TO '0'B ('0'B = FALSE OR        */
06240000    /*              NOT SELECTED, '1'B = TRUE OR SELECTED).                        */
06250000    /*                                                                             */
06260000    /*           2. A SCAN_ARRAY PLANE OR ROW IS CONSIDERED ACTIVE IF ANY COLUMN   */
06270000    /*              SUBSTRUCTURE CONTAINS A "STRING" VALUE.  AS ENTRY LINES ARE    */
06280000    /*              READ, EACH ACTIVE ROW IN EACH ACTIVE PLANE IS REVIEWED.  IF    */
06290000    /*              THE ROW RESULT IS ALREADY SET TO '1'B, TESTS FOR THAT ROW      */
06300000    /*              ARE SKIPPED (FOR SCANNING BUT NOT FOR HIGHLIGHTING) TO         */
06310000    /*              REDUCE EXECUTION OVERHEAD.  WHEN THE RESULT FOR AN ACTIVE      */
06320000    /*              ROW IS NOT YET SET TO '1'B, THE COLUMN SUBSTRUCTURES ARE       */
06330000    /*              PROCESSED AGAINST THE CURRENT LINE, AND A ROW RESULT IS        */
06340000    /*              CALCULATED.                                                    */
06350000    /*                                                                             */
06360000    /*              THE ROW-COLUMN STRUCTURING IS DESIGNED TO PROVIDE A WAY TO     */
06370000    /*              DESCRIBE SEPARATE MULTIPLE TESTS AGAINST THE SAME LINE.  THE   */
06380000    /*              TESTS FOR ALL ACTIVE COLUMNS IN A ROW MUST BE SATISFIED        */
06390000    /*              AGAINST THE SAME LINE IN ORDER FOR A POSITIVE ROW RESULT TO    */
06400000    /*              OCCUR.                                                         */
06410000    /*                                                                             */
06420000    /*           3. ONCE ALL LINES FOR AN ENTRY HAVE BEEN READ AND ROW RESULTS     */
06430000    /*              HAVE BEEN DETERMINED, CALCULATION OF THE FINAL SCAN_RESULT     */
06440000    /*              FOR THE ENTRY BEGINS.  A ROW'S RESULT IS FIRST COMPARED WITH   */
06450000    /*              ITS SELECT_OPTION.  IF EACH ACTIVE ROW'S RESULT IS THE SAME    */
06460000    /*              AS ITS SELECT_OPTION, THE PLANE'S RESULT IS SET TO '1'B.       */
06470000    /*              OTHERWISE, THE PLANE'S SCAN_RESULT IS SET TO '0'B.  A          */
06480000    /*              SCAN_RESULT MATCHES ITS CORRESPONDING SELECT_OPTION IF         */
06490000    /*              EITHER THE RESULT IS '1'B AND THE OPTION IS "SELECT", OR THE   */
06500000    /*              RESULT IS '0'B AND THE OPTION IS "EXCLUDE".  IN EFFECT, THE    */
06510000    /*              FINAL RESULTS FOR THE ACTIVE ROWS ARE "ANDED" TOGETHER.        */
06520000    /*                                                                             */
06530000    /*              ONCE THE PLANE RESULTS HAVE BEEN DETERMINED, THE FILE (CUBE)   */
06540000    /*              RESULT IS CALCULATED.  EACH ACTIVE PLANE'S RESULT IS           */
06550000    /*              COMPARED WITH ITS CORRESPONDING SELECT_OPTION.  IF ANY         */
06560000    /*              ACTIVE PLANE'S RESULT MATCHES ITS SELECT_OPTION, THE ENTRY'S   */
06570000    /*              FILE (CUBE) SCAN_RESULT IS SET TO '1'B.  OTHERWISE IT IS SET   */
06580000    /*              TO '0'B.  IN EFFECT, THE FINAL PLANE RESULTS ARE "ORED"        */
06590000    /*              TOGETHER.                                                      */
06600000    /*                                                                             */
06610000    /*              THE FILE SCAN_RESULT IS THE NEXT-TO-LAST STEP IN CALCULATING   */
06620000    /*              THE ENTRY'S SCAN_RESULT.  THE FILE RESULT IS COMPARED WITH     */
06630000    /*              THE SELECT_OPTION AT THE FILE LEVEL.  IF THEY AGREE, THE       */
06640000    /*              FINAL SCAN_RESULT FOR THE ENTRY IS SET TO '1'B, OTHERWISE      */
06650000    /*              '0'B.                                                          */
06660000    /*                                                                             */
06670000    /*              THE FILE-PLANE-ROW STRUCTURE IS DESIGNED TO PROVIDE A WAY TO   */
06680000    /*              DESCRIBE NOT/OR/AND OPERATIONS TO BE APPLIED TO THE ROW        */
06690000    /*              RESULTS OBTAINED FROM EXAMINING AN ENTRY'S LISTING LINES.  A   */
06700000    /*              FULL BOOLEAN EXPRESIION CAN BE CONSTRUCTED, ALTHOUGH SOME      */
06710000    /*              DUPLICATION MAY BE REQUIRED.  SELECT OPTIONS CORRESPOND TO     */
06720000    /*              "NOT", PLANES TO "OR", AND ROWS TO "AND".                      */
06730000    /*                                                                             */
06740000    /*      AN ENTRY'S FINAL SCAN_RESULT IS PART OF THE INFORMATION USED BY        */
06750000    /*      MATCH_ARRAY PROCESSING TO DECIDE WHICH ENTRIES SHOULD BE WRITTEN TO    */
06760000    /*      OUTPUT DATA SETS.                                                      */
06770000    /*                                                                             */
06780000    /*            THE SCAN_ARRAY VARIABLES THAT CAN BE SUPPLIED IN THE "SYSIN"     */
06790000    /*      DATA STREAM ARE LISTED ABOVE IN THE INPUT SECTION.  IF USED, THEY      */
06800000    /*      SHOULD BE SPECIFIED WITH REQUIRED LEVELS OF QUALIFICATION AND          */
06810000    /*      SUBSCRIPTS AS SHOWN THERE.  NOT ALL SCAN_ARRAY VARIABLES CAN BE        */
06820000    /*      SPECIFIED:  SOME, SUCH AS STR_LEN, AND STR_NIX ARE CALCULATED AFTER    */
06830000    /*      ALL VARIABLES HAVE BEEN READ, AND POS_LEN IS USUALLY ALLOWED TO        */
06840000    /*      DEFAULT.  THE VARIABLES THAT CAN BE SUPPLIED, ALONG WITH THEIR         */
06850000    /*      DEFAULT VALUES ARE:                                                    */
06860000    /*                                                                             */
06870000    /*             .SELECT_OPTION.  THE SELECT OPTIONS CAN BE SPECIFIED AT THE     */
06880000    /*              FILE, PLANE AND ROW LEVELS AND INDICATE NEGATION IF            */
06890000    /*              REQUESTED.  THE VALUES THAT CAN BE SPECIFIED ARE:              */
06900000    /*                                                                             */
06910000    /*                 'SELECT'                                                    */
06920000    /*                 'EXCLUDE'                                                   */
06930000    /*                                                                             */
06940000    /*              THE DEFAULT SPECIFICATION IS "SELECT".  A VALUE OF "EXCLUDE"   */
06950000    /*              REQUESTS NEGATION.  THE EFFECTS OF THESE VARIABLES IN          */
06960000    /*              COMPUTING THE LINE SCAN RESULTS FOR AN INDIVIDUAL ENTRY        */
06970000    /*              ARE DESCRIBED BELOW.                                           */
06980000    /*                                                                             */
06990000    /*             .BEG_POS.  THE BEG_POS VARIABLE IS A NUMBER INDICATING THE      */
07000000    /*              STARTING POSITION WITHIN THE LISTING LINE AT WHICH             */
07010000    /*              COMPARISON IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS   */
07020000    /*              NUMBER IS ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER,   */
07030000    /*              WITH THE LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT    */
07040000    /*              VALUE DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS           */
07050000    /*              FOLLOWS:                                                       */
07060000    /*                                                                             */
07070000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED.  NOT USED.       */
07080000    /*                                                                             */
07090000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO 011.     */
07100000    /*                                                                             */
07110000    /*                -LINE  DATA COMPARE:   029.                                  */
07120000    /*                                                                             */
07130000    /*                -LINE  DATA    SCAN:   029.                                  */
07140000    /*                                                                             */
07150000    /*              BEG_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */
07160000    /*              BUT SHOULD BE LESS THAN OR EQUAL IN VALUE TO END_POS.          */
07170000    /*                                                                             */
07180000    /*             .END_POS.  THE END_POS VARIABLE IS A NUMBER INDICATING THE      */
07190000    /*              ENDING POSITION WITHIN THE LISTING LINE AT WHICH COMPARISON    */
07200000    /*              IS TO BE PERFORMED OR SCANNING IS TO BEGIN.  THIS NUMBER IS    */
07210000    /*              ASSIGNED EXCLUSIVE OF THE PRINT CONTROL CHARACTER, WITH THE    */
07220000    /*              LEFTMOST PRINTED CHARACTER BEING 001.  THE DEFAULT VALUE       */
07230000    /*              DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS FOLLOWS:        */
07240000    /*                                                                             */
07250000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */
07260000    /*                                                                             */
07270000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */
07280000    /*                                       BEG_POS+STR_LEN-1 OR 025,             */
07290000    /*                                       WHICHEVER IS LESS.                    */
07300000    /*                                                                             */
07310000    /*                -LINE  DATA COMPARE:   BEG_POS+STR_LEN-1 OR 120,             */
07320000    /*                                       WHICHEVER IS LESS.                    */
07330000    /*                                                                             */
07340000    /*                -LINE  DATA    SCAN:   120.                                  */
07350000    /*                                                                             */
07360000    /*              END_POS CAN DESIGNATE ANY POSITION ON THE LINE: 001 - 120,     */
07370000    /*              BUT SHOULD BE GREATER THAN OR EQUAL IN VALUE TO BEG_POS.       */
07380000    /*                                                                             */
07390000    /*             .POS_LEN.  THE POS_LEN VARIABLE IS A NUMBER INDICATING THE      */
07400000    /*              NUMBER OF PRINT POSTITONS BETWEEN BEG_POS AND END_POS.         */
07410000    /*              POS_LEN CAN BE SPECIFIED IN LIEU OF END_POS, BUT IT IS         */
07420000    /*              USUALLY ALLOWED TO DEFAULT.  IF POS_LEN IS PROVIDED RATHER     */
07430000    /*              THAN END_POS, END_POS IS CALCULATED.  THE CALCULATED VALUE     */
07440000    /*              FOR POS_LEN DEPENDS ON THE TYPE OF OPERATION (SEE "OP") AS     */
07450000    /*              FOLLOWS:                                                       */
07460000    /*                                                                             */
07470000    /*                -ENTRY TYPE COMPARE:   IGNORED IF PROVIDED. NOT USED.        */
07480000    /*                                                                             */
07490000    /*                -LINE  TYPE COMPARE:   IGNORED IF PROVIDED.  SET TO          */
07500000    /*                                       END_POS-BEG_POS+1 OR 015,             */
07510000    /*                                       WHICHEVER IS LESS.                    */
07520000    /*                                                                             */
07530000    /*                -LINE  DATA COMPARE:   END_POS-BEG_POS+1 OR STR_LEN,         */
07540000    /*                                       WHICHEVER IS LESS.                    */
07550000    /*                                                                             */
07560000    /*                -LINE  DATA    SCAN:   END_POS-BEG_POS+1 OR 120,             */
07570000    /*                                       WHICHEVER IS LESS.                    */
07580000    /*                                                                             */
07590000    /*              POS_LEN IS RECALCULATED AFTER THE FINAL VALUES FOR             */
07600000    /*              BEG_POS AND END_POS HAVE BEEN DETERMINED.                      */
07610000    /*                                                                             */
07620000    /*             .OP.  THIS VARIABLE GOVERNS HOW THE "STRING" IS COMPARED WITH   */
07630000    /*              THE ENTRY'S LISTING LINE WITHIN THE BOUNDS DEFINED BY          */
07640000    /*              BEG_POS AND END_POS.  IN EACH GROUP OF COMPARE/SCAN            */
07650000    /*              OPERATIONS, SEVERAL COMPARISON OPERATORS ARE DEFINED.  FOR     */
07660000    /*              THREE OF THE FOUR, GENERIC COMPARISONS CAN ALSO BE             */
07670000    /*              PERFORMED.  THE OPERATIONS SUPPORTED WITHIN EACH GROUP ARE     */
07680000    /*              AS FOLLOWS:                                                    */
07690000    /*                                                                             */
07700000    /*                -ENTRY TYPE COMPARE:                                         */
07710000    /*                            EQENTRY:   THE ENTRY TYPE MUST BE THE SAME AS    */
07720000    /*                                       THAT SPECIFIED IN "STRING".           */
07730000    /*                            NEENTRY:   THE ENTRY TYPE MUST NOT BE THE SAME   */
07740000    /*                                       AS THAT SPECIFIED IN "STRING".        */
07750000    /*                   EQENTRY SYNONYMS:   EQNTRY,     EQN.                      */
07760000    /*                   NEENTRY SYNONYMS:   NENTRY,     NEN,                      */
07770000    /*                                      ¬EQENTRY,   ¬EQNTRY,  ¬EQN.            */
07780000    /*                                                                             */
07790000    /*                -LINE  TYPE COMPARE:                                         */
07800000    /*                             EQLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
07810000    /*                                       CHARACTERS IN "STRING" (I.E., A       */
07820000    /*                                       PREFIX COMPARISON IS DONE) MUST BE    */
07830000    /*                                       THE SAME AS THAT SPECIFIED IN         */
07840000    /*                                       "STRING".                             */
07850000    /*                             NELINE:   THE LINE TYPE, FOR THE NUMBER OF      */
07860000    /*                                       CHARACTERS IN "STRING" (I.E., A       */
07870000    /*                                       PREFIX COMPARISON IS DONE) MUST NOT   */
07880000    /*                                       BE THE SAME AS THAT SPECIFIED IN      */
07890000    /*                                       "STRING".                             */
07900000    /*                            EQGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
07910000    /*                                       CHARACTERS IN "STRING" (I.E., A       */
07920000    /*                                       PREFIX COMPARISON IS DONE) MUST       */
07930000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */
07940000    /*                                       VALUE SPECIFIED IN "STRING".          */
07950000    /*                            NEGLINE:   THE LINE TYPE, FOR THE NUMBER OF      */
07960000    /*                                       CHARACTERS IN "STRING" (I.E., A       */
07970000    /*                                       PREFIX COMPARISON IS DONE) MUST       */
07980000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */
07990000    /*                                       THE VALUE SPECIFIED IN "STRING".      */
08000000    /*                    EQLINE SYNONYMS:    EQLIN,    EQL.                       */
08010000    /*                    NELINE SYNONYMS:    NELIN,    NEL,                       */
08020000    /*                                       ¬EQLINE,  ¬EQLIN,    ¬EQL.            */
08030000    /*                   EQGLINE SYNONYMS:    EQGLIN,   EQGL.                      */
08040000    /*                   NEGLINE SYNONYMS:    NEGLIN,   NEGL,                      */
08050000    /*                                       ¬EQGLINE, ¬EQGLIN,   ¬EQGL.           */
08060000    /*                                                                             */
08070000    /*                -LINE  DATA COMPARE:                                         */
08080000    /*                             LTCMPR:   THE CHARACTER STRING IN THE ENTRY     */
08090000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
08100000    /*                                       LESS THAN THE VALUE  SPECIFIED IN     */
08110000    /*                                       "STRING".                             */
08120000    /*                             LECMPR:   THE CHARACTER STRING IN THE ENTRY     */
08130000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
08140000    /*                                       LESS THAN OR EQUAL TO THE VALUE       */
08150000    /*                                       SPECIFIED IN "STRING".                */
08160000    /*                             EQCMPR:   THE CHARACTER STRING IN THE ENTRY     */
08170000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
08180000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */
08190000    /*                                       "STRING".                             */
08200000    /*                             NECMPR:   THE CHARACTER STRING IN THE ENTRY     */
08210000    /*                                       LINE, STARTING AT BEG_POS, MUST NOT   */
08220000    /*                                       BE EQUAL TO THE VALUE SPECIFIED IN    */
08230000    /*                                       "STRING".                             */
08240000    /*                             GECMPR:   THE CHARACTER STRING IN THE ENTRY     */
08250000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
08260000    /*                                       GREATER THAN OR EQUAL TO THE VALUE    */
08270000    /*                                       SPECIFIED IN "STRING".                */
08280000    /*                             GTCMPR:   THE CHARACTER STRING IN THE ENTRY     */
08290000    /*                                       LINE, STARTING AT BEG_POS, MUST BE    */
08300000    /*                                       GREATER THAN THE VALUE SPECIFIED IN   */
08310000    /*                                       "STRING".                             */
08320000    /*                            EQGCMPR:   THE CHARACTER STRING IN THE ENTRY     */
08330000    /*                                       LINE, STARTING AT BEG_POS, MUST       */
08340000    /*                                       GENERICALLY COMPARE EQUAL TO THE      */
08350000    /*                                       VALUE SPECIFIED IN "STRING".          */
08360000    /*                            NEGCMPR:   THE CHARACTER STRING IN THE ENTRY     */
08370000    /*                                       LINE, STARTING AT BEG_POS, MUST       */
08380000    /*                                       GENERICALLY COMPARE NOT EQUAL TO      */
08390000    /*                                       THE VALUE SPECIFIED IN "STRING".      */
08400000    /*                    LTCMPR SYNONYMS:   LTCPR,    LTC,      LT,               */
08410000    /*                                      ¬GECMPR,  ¬GECPR,   ¬GEC,    ¬GE.      */
08420000    /*                    LECMPR SYNONYMS:   LECPR,    LEC,      LE,               */
08430000    /*                                      ¬GTCMPR,  ¬GTCPR,   ¬GTC,    ¬GT.      */
08440000    /*                    EQCMPR SYNONYMS:   EQCPR,    EQC,      EQ.               */
08450000    /*                    NECMPR SYNONYMS:   NECPR,    NEC,      NE,               */
08460000    /*                                      ¬EQCMPR,  ¬EQCPR,   ¬EQC,    ¬EQ.      */
08470000    /*                    GECMPR SYNONYMS:   GECPR,    GEC,      GE,               */
08480000    /*                                      ¬LTCMPR,  ¬LTCPR,   ¬LTC,    ¬LT.      */
08490000    /*                    GTCMPR SYNONYMS:   GTCPR,    GTC,      GT,               */
08500000    /*                                      ¬LECMPR,  ¬LECPR,   ¬LEC,    ¬LE.      */
08510000    /*                   EQGCMPR SYNONYMS:   EQGCPR,   EQGC,     EQG.              */
08520000    /*                   NEGCMPR SYNONYMS:   NEGCPR,   NEGC,     NEG,              */
08530000    /*                                      ¬EQGCPR,  ¬EQGC,     ¬EQG.             */
08540000    /*                                                                             */
08550000    /*                -LINE  DATA    SCAN:                                         */
08560000    /*                             EQSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
08570000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
08580000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */
08590000    /*                                       EQUAL TO THE VALUE SPECIFIED IN       */
08600000    /*                                       "STRING".  SUBSTRINGS ARE EXAMINED    */
08610000    /*                                       STARTING AT BEG_POS AND STOPPING AT   */
08620000    /*                                       (END_POS-STR_LEN+1).                  */
08630000    /*                             NESCAN:   THE CHARACTERS IN THE ENTRY LINE      */
08640000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
08650000    /*                                       NOT CONTAIN ANY SUBSTRING EQUAL TO    */
08660000    /*                                       THE VALUE SPECIFIED IN "STRING".      */
08670000    /*                                       SUBSTRINGS ARE EXAMINED STARTING AT   */
08680000    /*                                       BEG_POS AND STOPPING AT               */
08690000    /*                                       (END_POS-STR_LEN+1).                  */
08700000    /*                            EQGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
08710000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
08720000    /*                                       CONTAIN AT LEAST ONE SUBSTRING        */
08730000    /*                                       GENERICALLY EQUAL TO THE VALUE        */
08740000    /*                                       SPECIFIED IN "STRING".  SUBSTRINGS    */
08750000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */
08760000    /*                                       AND STOPPING AT                       */
08770000    /*                                       (END_POS-STR_LEN+1).                  */
08780000    /*                            NEGSCAN:   THE CHARACTERS IN THE ENTRY LINE      */
08790000    /*                                       BETWEEN BEG_POS AND END_POS MUST      */
08800000    /*                                       NOT CONTAIN ANY SUBSTRING             */
08810000    /*                                       GENERICALLY EQUAL TO THE VALUE        */
08820000    /*                                       SPECIFIED IN "STRING".  SUBSTRINGS    */
08830000    /*                                       ARE EXAMINED STARTING AT BEG_POS      */
08840000    /*                                       AND STOPPING AT                       */
08850000    /*                                       (END_POS-STR_LEN+1).                  */
08860000    /*                    EQSCAN SYNONYMS:    EQSCN,    EQS.                       */
08870000    /*                    NESCAN SYNONYMS:    NESCN,    NES,                       */
08880000    /*                                       ¬EQSCAN,  ¬EQSCN,     ¬EQS.           */
08890000    /*                   EQGSCAN SYNONYMS:    EQGSCN,   EQGS.                      */
08900000    /*                   NEGSCAN SYNONYMS:    NEGSCN,   NEGS,                      */
08910000    /*                                       ¬EQGSCAN, ¬EQGSCN,    ¬EQGS.          */
08920000    /*                                                                             */
08930000    /*              THE DEFAULT SPECIFICATION FOR "OP" IS "EQSCAN".                */
08940000    /*                                                                             */
08950000    /*             .STRING.  THIS IS THE CHARACTER STRING DATA WHOSE PRESENCE OR   */
08960000    /*              ABSENCE IS BEING SOUGHT.  IT CAN HAVE A MAXIMUM LENGTH OF 32   */
08970000    /*              BYTES.  A SCAN_ARRAY ELEMENT IS CONSIDERED ACTIVE ONLY IF A    */
08980000    /*              CHARACTER STRING VALUE OF LENGTH GREATER THAN ZERO HAS BEEN    */
08990000    /*              SPECIFIED (THE STRING CAN BE BLANK).  THE DATA PROVIDED FOR    */
09000000    /*              "STRING" WILL DEPEND ON THE TYPE OF OPERATION (SEE "OP") AS    */
09010000    /*              FOLLOWS:                                                       */
09020000    /*                                                                             */
09030000    /*                -ENTRY TYPE COMPARE:   NAMES A TYPE OF ENTRY (E.G.,          */
09040000    /*                                       "DDDEF", "ASSEM", "LMOD", "MOD",      */
09050000    /*                                       "SYSMOD").  A FULL LIST OF VALUES     */
09060000    /*                                       APPEARS BELOW IN THE DESCRIPTION OF   */
09070000    /*                                       "TYPE" FOR MATCH_ARRAY.  WITHIN       */
09080000    /*                                       REASON, ABBREVIATIONS ARE             */
09090000    /*                                       SUPPORTED.  TO REDUCE EXECUTION       */
09100000    /*                                       OVERHEAD, THE ENTRY TYPE NAME IS      */
09110000    /*                                       CONVERTED TO AN INTERNAL INDEX        */
09120000    /*                                       VALUE (AND SAVED IN STR_NIX).  THE    */
09130000    /*                                       INDEX VALUE IS USED FOR THE ACTUAL    */
09140000    /*                                       TEST AGAINST THE LINE.                */
09150000    /*                                                                             */
09160000    /*                -LINE  TYPE COMPARE:   IDENTIFIES A TYPE OF LISTING LINE.    */
09170000    /*                                       THE BEST WAY TO DETERMINE VALUES TO   */
09180000    /*                                       USE IS TO EXAMINE AN ACTUAL SMP/E     */
09190000    /*                                       LIST OUTPUT.                          */
09200000    /*                                                                             */
09210000    /*                -LINE  DATA COMPARE:   THE COMPARE ARGUMENT STRING FOR       */
09220000    /*                                       REGULAR COMPARE OPERATIONS, OR THE    */
09230000    /*                                       PATTERN STRING FOR GENERIC            */
09240000    /*                                       COMPARES.                             */
09250000    /*                                                                             */
09260000    /*                -LINE  DATA    SCAN:   THE SCAN ARGUMENT STRING OR THE       */
09270000    /*                                       PATTERN STRING, DEPENDING ON          */
09280000    /*                                       WHETHER THE SCAN OPERATION IS OF      */
09290000    /*                                       THE NORMAL VARIETY, OR GENERIC.       */
09300000    /*                                                                             */
09310000    /*              "STRING" HAS NO DEFAULT.  IF A STRING VALUE IS NOT PROVIDED,   */
09320000    /*              THE SCAN_ARRAY COLUMN SUBSTRUCTURE IS NOT USED DURING ENTRY    */
09330000    /*              PROCESSING.  IF A VALUE IS PROVIDED, ITS LENGTH DETERMINED     */
09340000    /*              AND THEN SAVED IS SCAN_ARRAY VARIABLE STR_LEN.                 */
09350000    /*                                                                             */
09360000    /*            THE DISTINCTION BETWEEN THE "NE" COLUMN OPERATIONS AND A ROW     */
09370000    /*      LEVEL SELECT_OPTION OF "EXCLUDE" NEEDS TO BE CLARIFIED.  COLUMN        */
09380000    /*      OPERATIONS ARE USED TO TEST WHETHER A CONDITION OCCURS OR DOESN'T      */
09390000    /*      OCCUR ON A GIVEN LINE.  ONCE A ROW TEST HAS BEEN SATISFIED FOR ANY     */
09400000    /*      LINE OF AN ENTRY, HOWEVER, THE TEST IS SATISFIED FOR THE ENTRY.        */
09410000    /*      CONSEQUENTLY, AN "NE" OPERATION MAY NOT RESULT IN ALL PERTINENT        */
09420000    /*      LINES BEING TESTED.  TO VERIFY THAT A PARTICULAR VALUE DOES NOT        */
09430000    /*      APPEAR ON ANY ENTRY LINE (I.E., THAT ALL PERTINENT LINES FAIL THE      */
09440000    /*      TEST), USE A POSITIVE TEST SUCH AS "EQ" COMBINED WITH A ROW            */
09450000    /*      SELECT_OPTION OF "EXCLUDE".  NEGATIVELY-EXPRESSED OPERATIONS ARE       */
09460000    /*      GENERALLY USED IN COMBINATION WITH OTHER TESTS, OR WHEN THE DATA OF    */
09470000    /*      INTEREST APPEAR ON ONLY ONE LISTING LINE.                              */
09480000    /*                                                                             */
09490000    /*            WHILE GENERIC SEARCH AND COMPARE FACILITIES ARE AVAILABLE IN A   */
09500000    /*      VARIETY OF PROGRAMS AND PRODUCTS, THE GENERIC OPERATIONS PROVIDED IN   */
09510000    /*      THE SCAN_ARRAY ARE MOST SIMILAR TO THE PICTURE STRING FEATURE OF THE   */
09520000    /*      ISPF BROWSE AND EDIT COMMANDS.  A NOTE FOR THE LAWYERS - ISPF IS A     */
09530000    /*      PROGRAM PRODUCT OF IBM.  WHEN GENERIC COMPARISON OR GENERIC SCANNING   */
09540000    /*      IS REQUESTED, THE SCAN_ARRAY SEARCH STRING IS TREATED AS A MASK OR     */
09550000    /*      PATTERN.  THE CHARACTER STRING FROM THE LISTING LINE BEING EXAMINED    */
09560000    /*      IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN STRING FROM        */
09570000    /*      SCAN_ARRAY, PROCESSING FROM LEFT TO RIGHT.  THE FIRST CHARACTER        */
09580000    /*      STRING CHARACTER NOT SATISFYING THE REQUIREMENTS OF ITS PATTERN        */
09590000    /*      STRING CHARACTER STOPS THE COMPARE AND GIVES A NOT-EQUAL RESULT.       */
09600000    /*      WHEN ALL CORRESPONDING CHARACTERS ARE EQUAL, A CHARACTER STRING        */
09610000    /*      LONGER THAN THE PATTERN STRING IS CHECKED TO VERIFY THAT BYTES         */
09620000    /*      EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE PATTERN STRING ARE     */
09630000    /*      BLANK.  LIKEWISE, A PATTERN STRING LONGER THAN THE CHARACTER STRING    */
09640000    /*      IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT        */
09650000    /*      BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE     */
09660000    /*      "ANY" SELECTION BYTE("*").                                             */
09670000    /*                                                                             */
09680000    /*            A GENERIC COMPARISON PATTERN CHARACTER REPRESENTS EITHER A       */
09690000    /*      GROUP OF CHARACTERS, OR ITSELF.  BECAUSE CHARACTERS WITHIN A GROUP     */
09700000    /*      WILL NOT, IN GENERAL, BE CONSECUTIVE WITHOUT GAPS IN THE COLLATING     */
09710000    /*      SEQUENCE, A GENERIC COMPARISON ORDER IN TERMS OF HIGH, LOW, AND        */
09720000    /*      EQUAL CANNOT BE DEFINED.  THE BEST THAT CAN BE DETERMINED IS EQUAL     */
09730000    /*      OR NOT EQUAL.  THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN   */
09740000    /*      PATTERN STRINGS, AND ARE USED TO SELECT GROUPS OF CHARACTERS:          */
09750000    /*                                                                             */
09760000    /*            "*" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE        */
09770000    /*                  ANY CHARACTER.                                             */
09780000    /*                                                                             */
09790000    /*            "#" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09800000    /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.             */
09810000    /*                                                                             */
09820000    /*            "@" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09830000    /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.          */
09840000    /*                                                                             */
09850000    /*            "¢" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09860000    /*                  ONE OF THE NATIONAL CHARACTERS: "$", "#", OR "@".          */
09870000    /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL             */
09880000    /*                  CHARACTERS ARE UPPERCASE.                                  */
09890000    /*                                                                             */
09900000    /*            "%" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09910000    /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.              */
09920000    /*                                                                             */
09930000    /*            "_" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09940000    /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.   */
09950000    /*                                                                             */
09960000    /*            ">" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
09970000    /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE            */
09980000    /*                  ALPHABETIC OR NUMERIC CHARACTER.                           */
09990000    /*                                                                             */
10000000    /*            "<" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
10010000    /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.               */
10020000    /*                                                                             */
10030000    /*            "!" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
10040000    /*                  ONE OF THE SPECIAL CHARACTERS.                             */
10050000    /*                                                                             */
10060000    /*            "-" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
10070000    /*                  NON-NUMERIC.                                               */
10080000    /*                                                                             */
10090000    /*            "¬" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
10100000    /*                  NON-BLANK.                                                 */
10110000    /*                                                                             */
10120000    /*            "?" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE       */
10130000    /*                  ONE OF THE INVALID CHARACTERS.                             */
10140000    /*                                                                             */
10150000    /*      ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS,         */
10160000    /*      NUMERIC DIGITS, AND ESPECIALLY THE CHARACTERS "=" "." "," ":" "$"      */
10170000    /*      "(" AND ")" REPRESENT THEMSELVES.  WHEN A PATTERN STRING CHARACTER     */
10180000    /*      REPRESENTS ITSELF, THE CHARACTER STRING CHARACTER MUST BE THE SAME     */
10190000    /*      AS THE PATTERN CHARACTER.  FOR EXAMPLE, IN THE PATTERN STRING          */
10200000    /*      "%RM####" USED TO SEARCH FOR RMF FMID'S, THE CHARACTERS "R" AND "M"    */
10210000    /*      REPRESENT THEMSELVES.  EVERY ATTEMPT WAS MADE TO CHOOSE GENERIC        */
10220000    /*      SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE DATA      */
10230000    /*      EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE (E.G., THE CHOICE   */
10240000    /*      OF "#" TO SELECT NUMERIC CHARACTERS).                                  */
10250000    /*                                                                             */
10260000    /*            >>>>>MATCH_ARRAY.<<<<<                                           */
10270000    /*            MATCH_ARRAY PROVIDES SMPSCAN WITH THE INFORMATION IT NEEDS TO    */
10280000    /*      DETERMINE WHICH ENTRIES SHOULD BE WRITTEN TO OUTPUT DATA SETS.  THE    */
10290000    /*      MATCH_ARRAY CONTENTS SPECIFY ENTRY MATCH CRITERIA WHICH CAN APPLY TO   */
10300000    /*      A SINGLE INPUT LISTING, OR TO MULTIPLE LISTINGS (CROSS-ZONES)          */
10310000    /*      CONCURRENTLY.  MATCH CRITERIA ARE BASED ON A COMBINATION OF ENTRY      */
10320000    /*      TYPE (SYSMOD, MAC, MOD, LMOD, OR WHATEVER), ON THE PRESENCE OR         */
10330000    /*      ABSENCE OF AN ENTRY IN A PARTICULAR INPUT LISTING, AND ON AN ENTRY'S   */
10340000    /*      SCAN_RESULT IF SCAN_ARRAY VARIABLES WERE PROVIDED FOR THAT FILE.       */
10350000    /*      THE OUTPUT DECISION IS BASED ON WHETHER THE MATCH CRITERIA WERE        */
10360000    /*      SATISFIED AND, IF SCAN RESULTS ARE DEEMED RELEVANT, ON WHETHER SCAN    */
10370000    /*      RESULTS WERE POSITIVE.                                                 */
10380000    /*                                                                             */
10390000    /*            MATCH_ARRAY IS DECLARED AS A TWO DIMENSIONAL ARRAY OF            */
10400000    /*      STRUCTURES.  THE FIRST SUBSCRIPT IS THE MATCH_ARRAY ENTRY NUMBER AND   */
10410000    /*      THE SECOND, WHEN REQUIRED, IS THE FILE NUMBER.  THE STRUCTURAL         */
10420000    /*      DECLARATION OF MATCH_ARRAY IS:                                         */
10430000    /*                                                                             */
10440000    /*            01 MATCH_ARRAY                          CONTROLLED,              */
10450000    /*               05 ENTRY(IMATCH_MIN:IMATCH_MAX),                              */
10460000    /*                  09 TYPE                           CHAR(016) VARYING,       */
10470000    /*                  09 COMPARE_TEST                   CHAR(008) VARYING,       */
10480000    /*                  09 FILE(IFILE_MIN:IFILE_MAX),                              */
10490000    /*                     13 COMPARE_OPTION              CHAR(012) VARYING,       */
10500000    /*                     13 COMPARE_SELECT              CHAR(012) VARYING,       */
10510000    /*                     13 WRITE_OPTION                CHAR(012) VARYING,       */
10520000    /*                     13 WRITE_SELECT                CHAR(012) VARYING,       */
10530000    /*                                                                             */
10540000    /*            AS ENTRIES ARE READ, SMPSCAN FORMS A COMPARE KEY FROM THE        */
10550000    /*      ENTRY TYPE, AND ENTRY NAME WITHIN TYPE.  FOR COMPARE KEY PURPOSES      */
10560000    /*      THE ENTRY TYPE IS CONVERTED TO A TWO DIGIT INDEX WHOSE VALUES ARE IN   */
10570000    /*      THE SAME ORDER AS ENTRY TYPES APPEAR IN SMP/E LISTINGS.  THIS IS THE   */
10580000    /*      SAME INDEX VALUE MENTIONED IN REGARD TO ENTRY TYPE COMPARE             */
10590000    /*      OPERATIONS IN THE DESCRIPTION OF THE SCAN_ARRAY "STRING" VARIABLE      */
10600000    /*      ABOVE.  THE COMPARE KEY IS USED TO SYNCHRONIZE THE PROCESSING OF       */
10610000    /*      MULTIPLE LISTING INPUTS BECAUSE IT DEFINES AN ORDER FOR THE INPUT      */
10620000    /*      AND ALLOWS ENTRIES WITH THE SAME NAME TO BE IDENTIFIED ACROSS ZONES.   */
10630000    /*      THIS KEY TECHNIQUE WORKS BECAUSE SMP/E LISTS ENTRIES WITHIN TYPE IN    */
10640000    /*      ASCENDING ORDER BY NAME, AND ENTRY TYPES ALWAYS APPEAR IN THE SAME     */
10650000    /*      ORDER IN OUTPUT LISTINGS.  THIS CONSISTENCY PROBABLY REFLECTS          */
10660000    /*      SMP/E'S ZONE KEY CONSTRUCTION TECHNIQUE.                               */
10670000    /*                                                                             */
10680000    /*            ONCE THE FIRST ENTRY HAS BEEN READ FROM EACH ACTIVE INPUT        */
10690000    /*      FILE, SMPSCAN CHECKS THE COMPARE KEYS, AND IDENTIFIES THOSE WITH THE   */
10700000    /*      LOWEST COMPARE KEY.  THERE WILL ALWAYS BE AT LEAST ONE SUCH ENTRY,     */
10710000    /*      AND THERE MAY SEVERAL IF THE ENTRY APPEARS IN MORE THAT ONE INPUT      */
10720000    /*      LISTING.  THESE ENTRIES ARE THEN PROCESSED AS A GROUP.  PROCESSING     */
10730000    /*      CONSISTS OF TESTING EACH ACTIVE ENTRY OF MATCH_ARRAY TO SEE IF THIS    */
10740000    /*      GROUP OF ENTRIES IS A "MATCH", AND THEN APPLYING EACH "MATCHING"       */
10750000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS TO EACH GROUP MEMBER.  A "MATCH"     */
10760000    /*      IS DEFINED IN TERMS OF THE VARIABLES TYPE, COMPARE_TEST,               */
10770000    /*      COMPARE_OPTION, AND COMPARE_SELECT:                                    */
10780000    /*                                                                             */
10790000    /*            1. MATCH_ARRAY TYPE MUST BE "ALL", OR MUST BE THE SAME AS THE    */
10800000    /*               ENTRY TYPE FOR THE GROUP (ENTRIES OF DIFFERENT TYPES WILL     */
10810000    /*               NOT BE IN THE SAME GROUP).                                    */
10820000    /*                                                                             */
10830000    /*            2. FOR EACH ACTIVE FILE, COMPARE_OPTION AND COMPARE_SELECT ARE   */
10840000    /*               CHECKED AGAINST THE FILE'S CONTRIBUTION TO THE GROUP.  EACH   */
10850000    /*               ACTIVE FILE EITHER HAS OR DOESN'T HAVE AN ENTRY IN THE        */
10860000    /*               GROUP, AND EACH ENTRY IN THE GROUP HAS EITHER A POSITIVE      */
10870000    /*               ('1'B) OR NEGATIVE ('0'B) SCAN_RESULT.  COMPARE_OPTION        */
10880000    /*               INDICATES WHETHER THE FILE MUST OR MUST NOT HAVE AN ENTRY     */
10890000    /*               IN THE GROUP, OR WHETHER MEMBERSHIP IN THE GROUP IS           */
10900000    /*               OPTIONAL.  COMPARE_SELECT IS CHECKED IF AN ENTRY APPEARS IN   */
10910000    /*               THE GROUP (WHETHER MANDATORY OR OPTIONAL).  AN ABSENT ENTRY   */
10920000    /*               DOESN'T HAVE A SCAN_RESULT.  COMPARE_SELECT INDICATES         */
10930000    /*               WHETHER AN ENTRY MUST HAVE A POSITIVE OR NEGATIVE             */
10940000    /*               SCAN_RESULT, OR THE SCAN_RESULT IS TO BE DISREGARDED FOR      */
10950000    /*               MATCHING PURPOSES (COMPARE_SELECT AND WRITE_SELECT ARE        */
10960000    /*               INDEPENDENT OF EACH OTHER).                                   */
10970000    /*                                                                             */
10980000    /*            3. COMPARE_TEST AFFECTS THE WAY THE COMPARE_OPTION AND           */
10990000    /*               COMPARE_SELECT TESTS ARE ASSESED TO DETERMINE A "MATCH".      */
11000000    /*               IF COMPARE_TEST IS "ALL", THE COMPARE_OPTION/COMPARE_SELECT   */
11010000    /*               TESTS MUST BE TRUE FOR ALL ACTIVE FILES.  IF COMPARE_TEST     */
11020000    /*               IS "ANY", AT LEAST ONE OF THE COMPARE_OPTION/COMPARE_SELECT   */
11030000    /*               TESTS MUST BE TRUE FOR AN ACTIVE FILE.                        */
11040000    /*                                                                             */
11050000    /*      IF A MATCH_ARRAY ENTRY'S COMPARE INSTRUCTION YIELD A "MATCH", THE      */
11060000    /*      ARRAY ENTRY'S OUTPUT INSTRUCTIONS ARE APPLIED TO EACH ENTRY IN THE     */
11070000    /*      GROUP.  AN ABSENT ENTRY CAN'T BE WRITTEN.  THE OUTPUT INSTRUCTIONS     */
11080000    /*      ARE GIVEN BY THE VARIABLES WRITE_OPTION AND WRITE_SELECT:              */
11090000    /*                                                                             */
11100000    /*            1. FOR EACH ACTIVE FILE, WRITE_OPTION INDICATES WHETHER THE      */
11110000    /*               ENTRY IS TO BE WRITTEN IF THE GROUP IS A "MATCH".             */
11120000    /*               WRITE_OPTION IS INDEPENDENT OF COMPARE_OPTION, ESPECIALLY     */
11130000    /*               WHEN COMPARE_TEST IS "ANY".  FOR EXAMPLE, FOR MULTIPLE        */
11140000    /*               INPUTS, COMPARE_TEST='ANY' ALONG WITH                         */
11150000    /*               COMPARE_OPTION='NOCOMPARE' AND WRITE_OPTION='WRITE' IS A      */
11160000    /*               VALID COMBINATION.  THIS COMBINATION INSTRUCTS SMPSCAN TO     */
11170000    /*               IDENTIFY AND WRITE THOSE GROUPS OF ENTRIES THAT DON'T         */
11180000    /*               APPEAR IN ALL INPUT LISTINGS.                                 */
11190000    /*                                                                             */
11200000    /*            2. IF WRITE_OPTION IS "WRITE" AND AN ENTRY FROM THIS FILE        */
11210000    /*               APPEARED IN THE GROUP, WRITE_SELECT INDICATES WHETHER THE     */
11220000    /*               FILE ENTRY'S SCAN_RESULT HAS ANY BEARING ON THE OUTPUT        */
11230000    /*               DECISION.  LIKE WRITE_OPTION, WRITE_SELECT IS INDEPENDENT     */
11240000    /*               OF BOTH COMPARE_OPTION AND COMPARE_SELECT.  ONE ADVANTAGE     */
11250000    /*               OF THIS INDEPENDENCE IS THAT ONE CAN "MATCH" OR IDENTIFY      */
11260000    /*               ENTRIES INDEPENDENT OF SCAN RESULTS AND THEN WRITE A SUBSET   */
11270000    /*               OF THE "MATCHING" ENTRIES BASED ON SCAN RESULTS.  A CAUTION   */
11280000    /*               IS THAT IMPOSSIBLE COMBINATIONS PRODUCING NO OUTPUT CAN       */
11290000    /*               ALSO BE DESCRIBED.                                            */
11300000    /*                                                                             */
11310000    /*      ONCE A MATCH_ARRAY ENTRY HAS PRODUCED A "MATCH", PROCESSING            */
11320000    /*      CONTINUES.  THE FIRST ARRAY ENTRY YIELDING A MATCH DOES NOT            */
11330000    /*      TERMINATE THE PROCESSING OF MATCH_ARRAY FOR THIS ENTRY GROUP.  AFTER   */
11340000    /*      APPLYING OUTPUT INSTRUCTIONS, SMPSCAN GOES ON TO THE NEXT ACTIVE       */
11350000    /*      MATCH_ARRAY ENTRY.  THIS ALLOWS THE OUTPUT FROM MULTIPLE CONDITIONS    */
11360000    /*      TO BE MERGED IN A SINGLE EXECUTION (SMPSCAN HAS EXTRACT AND            */
11370000    /*      MULTI-PASS CAPABILITIES).  "MATCHED" ARRAY ENTRY OUTPUT INSTRUCTIONS   */
11380000    /*      ARE APPLIED ADDITIVELY.  ALTHOUGH THE WRITE_OPTION DEFAULT IS          */
11390000    /*      "WRITE", AN ENTRY FROM THE GROUP WILL NOT BE WRITTEN UNLESS ITS        */
11400000    /*      CORRESPONDING WRITE_OPTION FROM A "MATCHED" ARRAY ENTRY SPECIFIES      */
11410000    /*      "WRITE".  FURTHER, AN ENTRY WILL BE WRITTEN IF ANY "MATCHED" ARRAY     */
11420000    /*      ENTRY SPECIFIES "WRITE".  "NOWRITE" DOES NOT OVERRIDE "WRITE".         */
11430000    /*                                                                             */
11440000    /*            AFTER THE ABOVE PROCESSING HAS COMPLETED FOR THE FIRST SET       */
11450000    /*      ENTRIES READ FROM EACH ACTIVE FILE, THE NEXT ENTRY IS READ FROM EACH   */
11460000    /*      ACTIVE INPUT FILE THAT HAD AN ENTRY IN THE GROUP, AND THE MATCHING     */
11470000    /*      PROCESS IS REPEATED, STARTING WITH THE IDENTIFICATION OF A NEW GROUP   */
11480000    /*      OF LOW-KEY ENTRIES.  READING, SCANNING, AND MATCHING OF ENTRIES        */
11490000    /*      CONTINUES UNTIL THE ENTRIES FROM ALL INPUT FILES HAVE BEEN READ.       */
11500000    /*      LINES ARE SCANNED AS ENTRIES ARE READ, SO THAT THE SCAN_RESULT IS      */
11510000    /*      AVAILABLE WHEN THE THE NEXT LOW-KEY GROUP IS IDENTIFIED.               */
11520000    /*                                                                             */
11530000    /*            MATCH_ARRAY VARIABLES ARE SUPPLIED IN THE "SYSIN" DATA STREAM,   */
11540000    /*      AND ARE DOCUMENTED IN THE INPUT SECTION ABOVE.  IF USED, THEY SHOULD   */
11550000    /*      BE SPECIFIED WITH THE REQUIRED LEVELS OF QUALIFICATION AND             */
11560000    /*      SUBSCRIPTS AS SHOWN THERE.  UNLIKE SCAN_ARRAY, MATCH_ARRAY             */
11570000    /*      (CURRENTLY) DOES NOT CONTAIN SMPSCAN-CALCULATED VARIABLES.  ALL        */
11580000    /*      MATCH_ARRAY VARIABLES CAN BE SPECIFIED BY THE USER.  THE VARIABLES,    */
11590000    /*      ALONG WITH THEIR DEFAULTS ARE:                                         */
11600000    /*                                                                             */
11610000    /*             .TYPE.  THIS VARIABLE SPECIFIES THE SMP/E ENTRY TYPE TO WHICH   */
11620000    /*              THE MATCH_ARRAY ENTRY APPLIES.  IT CAN REFERENCE A SPECIFIC    */
11630000    /*              ENTRY TYPE (LIKE THE SCAN_ARRAY STRING VALUE FOR ENTRY TYPE    */
11640000    /*              OPERATIONS).  THE SPECIAL VALUES "NONE" AND "ALL" ARE ALSO     */
11650000    /*              RECOGNIZED.  "ALL" INDICATES THAT THE MATCH_ARRAY ENTRY        */
11660000    /*              APPLIES TO ALL ENTRY TYPES, AND "NONE" THAT THE ENTRY IS       */
11670000    /*              INACTIVE.  FOR SOME ENTRY TYPES, REASONABLE ABBREVIATIONS      */
11680000    /*              ARE SUPPORTED.  A FULL LIST OF THE CURRENTLY SUPPORTED ENTRY   */
11690000    /*              TYPES IN ORDER OF APPEARANCE IN LISTINGS IS:                   */
11700000    /*                                                                             */
11710000    /*                 'ZONE'                                                      */
11720000    /*                 'OPTIONS'                                                   */
11730000    /*                 'UTILITY'                                                   */
11740000    /*                 'FMIDSET'                                                   */
11750000    /*                 'DDDEF'                                                     */
11760000    /*                 'ZONESET'                                                   */
11770000    /*                 'ASSEMBLER'                                                 */
11780000    /*                 'LOAD MODULE'                                               */
11790000    /*                 'MACRO'                                                     */
11800000    /*                 'MODULE'                                                    */
11810000    /*                 'SOURCE'                                                    */
11820000    /*                 'DLIB'                                                      */
11830000    /*                 'SYSMOD'                                                    */
11840000    /*                 'M.C.S.'                                                    */
11850000    /*                                                                             */
11860000    /*             NOTE THAT A VALUE OF "ALL" WILL INCREASE SMPSCAN EXECUTION      */
11870000    /*             TIME, BECAUSE ONLY THOSE ENTRY TYPES REFERENCED IN              */
11880000    /*             MATCH_ARRAY ARE POTENTIAL OUTPUT CANDIDATES.  SMPSCAN           */
11890000    /*             BYPASSES NON-ESSENTIAL PROCESSING FOR THOSE TYPES OMITTED       */
11900000    /*             FROM MATCH_ARRAY.  IN PARTICULAR, LINE SCANNING IS SKIPPED.     */
11910000    /*             NOT USING MATCH_ARRAY HAS THE SAME EFFECT AS "ALL" SINCE        */
11920000    /*             ENTRY MATCHING IS GOVERNED BY SCAN RESULTS.                     */
11930000    /*                                                                             */
11940000    /*             .COMPARE_TEST.  THIS VARIABLE CONTROLS WHETHER THE FILE         */
11950000    /*              SUB-ENTRIES WITHIN THIS MATCH_ARRAY ENTRY ARE TO BE PROCESSED  */
11960000    /*              IN AN ALL (AND) OR ANY (OR) MANNER.  VALID VALUES ARE:         */
11970000    /*                                                                             */
11980000    /*                 'ALL'                                                       */
11990000    /*                 'ANY'                                                       */
12000000    /*                                                                             */
12010000    /*              THE DEFAULT IS "ALL".  "ALL" INDICATES THAT ALL CONDITIONS     */
12020000    /*              REPRESENTED BY THE COMPARE_OPTION AND COMPARE_SELECT           */
12030000    /*              VARIABLES FOR EACH ACTIVE FILE MUST BE MET IN ORDER FOR A      */
12040000    /*              MATCH_ARRAY ENTRY TO YIELD A MATCH WITH THE CURRENT GROUP OF   */
12050000    /*              LISTING ENTRIES.  "ALL" WAS CHOSEN AS DEFAULT TO COMPLEMENT    */
12060000    /*              THE FACT THAT ALL ACTIVE MATCH_ARRAY ENTRIES ARE PROCESSED     */
12070000    /*              FOR EACH GROUP OF LISTING ENTRIES, AND ANY MATCH_ARRAY ENTRY   */
12080000    /*              RESULTING IN A MATCH CAUSES TH ENTRY'S OUTPUT INSTRUCTIONS     */
12090000    /*              TO BE APPLIED TO THE GROUP.  IN OTHER WORDS, "ALL" (AND) WAS   */
12100000    /*              CHOSEN TO COMPLEMENT THE "ANY" (OR) LOGIC USED WITH THE        */
12110000    /*              ARRAY.  A VALUE OF "ANY" CAN ALSO BE SPECIFIED FOR             */
12120000    /*              COMPARE_TEST.  A VALUE OF "ANY" DOESN'T CHANGE THE WAY         */
12130000    /*              MATCH_ARRAY IS INTERPRETED, BUT IT DOES SIMPLIFY THE           */
12140000    /*              SPECIFICATION OF CERTAIN TESTS.  THAT'S WHY IT'S PROVIDED.     */
12150000    /*              FOR EXAMPLE, WITH FOUR INPUT ZONE LISTINGS, TESTING FOR        */
12160000    /*              ENTRIES OF A CERTAIN TYPE THAT ARE DEFINED IN SOME BUT NOT     */
12170000    /*              ALL INPUT LISTINGS WILL REQUIRE 1 MATCH_ARRAY ENTRY WITH       */
12180000    /*              COMPARE_TEST='ANY', BUT WILL REQUIRE 14 MATCH_ARRAY ENTRIES    */
12190000    /*              WITH COMPARE_TEST='ALL'.                                       */
12200000    /*                                                                             */
12210000    /*             .COMPARE_OPTION.  THIS VARIABLE SPECIFIES, FOR THE CURRENT      */
12220000    /*              GROUP OF LISTING ENTRIES, WHETHER AN ENTRY IS EXPECTED TO      */
12230000    /*              BE PRESENT FROM THAT FILE.  A COMPARE_OPTION VALUE             */
12240000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */
12250000    /*                                                                             */
12260000    /*                 'COMPARE'       (AND REASONABLE ABBREVIATIONS)              */
12270000    /*                 'NOCOMPARE'     (AND REASONABLE ABBREVIATIONS)              */
12280000    /*                 'IGNORE' OR 'IGCOMPARE'    (AND ABBREVIATIONS)              */
12290000    /*                                                                             */
12300000    /*             THE DEFAULT IS "IGNORE".  "COMPARE" INDICATES THAT A LISTING    */
12310000    /*             ENTRY IS EXPECTED FROM THIS FILE.  "NOCOMPARE" INDICATES THAT   */
12320000    /*             A LISTING ENTRY IS EXPECTED TO BE ABSENT FROM THIS FILE.        */
12330000    /*             "IGNORE" AND ITS SYNONYM "IGCOMPARE" INDICATE THAT AN ENTRY     */
12340000    /*             LISTING MAY OR MAY NOT APPEAR - IT WILL BE PROCESSED IF         */
12350000    /*             PRESENT, BUT ITS PRESENCE OR ABSENCE ISN'T DEMANDED.  BOTH      */
12360000    /*             "COMPARE" AND "IGNORE" ARE INTERPRETED IN CONJUNCTION WITH      */
12370000    /*             THE COMPARE_SELECT VARIABLE AS DESCRIBED BELOW.  "NOCOMPARE"    */
12380000    /*             DOESN'T INTERACT WITH COMPARE_SELECT BECAUSE AN ENTRY THAT      */
12390000    /*             ISN'T PRESENT CAN'T BE SCANNED.                                 */
12400000    /*                                                                             */
12410000    /*             .COMPARE_SELECT.  THIS VARIABLE SPECIFIES, WHEN AN ENTRY FROM   */
12420000    /*              THIS FILE IS PRESENT IN THE CURRENT GROUP OF LISTING           */
12430000    /*              ENTRIES, HOW THE ENTRY'S SCAN_RESULT IS TO BE WEIGHED.  A      */
12440000    /*              COMPARE_TEST VALUE CORRESPONDING TO THE COMPARE_OPTION         */
12450000    /*              PERTAINS TO EACH ACTIVE FILE.  VALID VALUES ARE:               */
12460000    /*                                                                             */
12470000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */
12480000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */
12490000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */
12500000    /*                                                                             */
12510000    /*             THE DEFAULT IS "IGNORE".  "SELECT" INDICATES THAT THE ENTRY     */
12520000    /*             MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS '1'B).   */
12530000    /*             "NOSELECT" INDICATES THAT THE ENTRY MUST BE NOT SELECTED BY     */
12540000    /*             THE SCAN PRECESS (RESULT IS '0'B).  "IGNORE" AND ITS SYNONYM    */
12550000    /*             "IGSELECT" INDICATE THAT THE SCAN RESULT IS TO BE DISREGARDED   */
12560000    /*             IN DETERMINING WHETHER THE CURRENT GROUP OF ENTRIES IS A        */
12570000    /*             "MATCH" ACCORDING TO THIS MATCH_ARRAY ENTRY.  IF                */
12580000    /*             COMPARE_OPTION IS "COMPARE" OR "IGNORE" AND COMPARE_SELECT IS   */
12590000    /*             "SELECT" OR "NOSELECT", THE VARIABLES ACT TOGETHER.  FOR        */
12600000    /*             INSTANCE, ONE CAN SPECIFY THAT AN ENTRY NEED NOT BE PRESENT     */
12610000    /*             ISN A LISTING, BUT IF IT IS PRESENT, ITS SCAN_RESULT MUST BE    */
12620000    /*             POSITIVE BY SPECIFYING COMPARE_OPTION='IGNORE' AND              */
12630000    /*             'COMPARE_SELECT='SELECT'.                                       */
12640000    /*                                                                             */
12650000    /*             .WRITE_OPTION.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */
12660000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES, THIS VARIABLE        */
12670000    /*              INDICATES THE OUTPUT REQUIREMENT FOR THE ENTRY FROM THIS       */
12680000    /*              FILE.  VALID VALUES ARE:                                       */
12690000    /*                                                                             */
12700000    /*                 'WRITE'         (AND REASONABLE ABBREVIATIONS)              */
12710000    /*                 'NOWRITE'       (AND REASONABLE ABBREVIATIONS)              */
12720000    /*                                                                             */
12730000    /*              THE DEFAULT IS "WRITE", AND THEIR MEANINGS ARE APPARENT.       */
12740000    /*              FOR "WRITE", THE DECISION TO WRITE DEPENDS ON THE VALUE IN     */
12750000    /*              WRITE_SELECT, DESCRIBED NEXT.                                  */
12760000    /*                                                                             */
12770000    /*             .WRITE_SELECT.  IF THIS MATCH_ARRAY ENTRY RESULTS IN A MATCH    */
12780000    /*              FOR THE CURRENT GROUP OF LISTING ENTRIES AND WRITE_OPTION IS   */
12790000    /*              "WRITE", THIS VARIABLE INDICATES WHETHER THE LISTING ENTRY'S   */
12800000    /*              SCAN RESULT HAS ANY BEARING ON WHETHER THE ENTRY IS WRITTEN.   */
12810000    /*              VALID VALUES ARE THE SAME AS THOSE FOR COMPARE_SELECT:         */
12820000    /*                                                                             */
12830000    /*                 'SELECT'        (AND REASONABLE ABBREVIATIONS)              */
12840000    /*                 'NOSELECT'      (AND REASONABLE ABBREVIATIONS)              */
12850000    /*                 'IGNORE' OR 'IGSELECT'     (AND ABBREVIATIONS)              */
12860000    /*                                                                             */
12870000    /*              THE DEFAULT IS "IGNORE".  "SELECT" INDICATES THAT THE ENTRY    */
12880000    /*              MUST HAVE BEEN SELECTED BY THE SCAN PROCESS (RESULT IS         */
12890000    /*              '1'B).  "NOSELECT" INDICATES THAT THE ENTRY MUST HAVE BEEN     */
12900000    /*              NOT SELECTED (RESULT IS '0'B).  "IGNORE" AND ITS SYNONYM       */
12910000    /*              "IGSELECT" INDICATE THAT THE SCAN_RESULT IS TO BE              */
12920000    /*              DISREGARDED FOR THE PURPOSE OF DECIDING WHETHER TO WRITE THE   */
12930000    /*              ENTRY - IT IS WRITTEN EITHER WAY.  A WRITE_SELECT VALUE OF     */
12940000    /*              "IGNORE" HAS NO EFFECT ON THE PRESENCE OR ABSENCE OF           */
12950000    /*              UNDERSCORES IN HIGHLIGHTED OUTPUT FOR THIS FILE.               */
12960000    /*                                                                             */
12970000    /*      IF MATCH_ARRAY VARIABLES ARE OMITTED FROM THE INPUT DATA SET, IT IS    */
12980000    /*      AS IF A SINGLE MATCH_ARRAY ENTRY HAD BEEN SPECIFIED, WITH THE          */
12990000    /*      FOLLOWING VALUES:                                                      */
13000000    /*                                                                             */
13010000    /*             .TYPE          ='ALL'.                                          */
13020000    /*             .COMPARE_TEST  ='ANY'.                                          */
13030000    /*             .COMPARE_OPTION='IGNORE'  FOR EACH ACTIVE FILE.                 */
13040000    /*             .COMPARE_SELECT='SELECT'  FOR EACH ACTIVE FILE.                 */
13050000    /*             .WRITE_OPTION  ='WRITE'   FOR EACH ACTIVE FILE.                 */
13060000    /*             .WRITE_SELECT  ='SELECT'  FOR EACH ACTIVE FILE.                 */
13070000    /*                                                                             */
13080000    /*                                                                             */
13090000    /*   USES AND EXAMPLES                                                         */
13100000    /*                                                                             */
13110000    /*            SMPSCAN'S USES CORRESPOND TO ITS FOUR MAIN FUNCTIONAL            */
13120000    /*      CAPABILITIES:  PROVIDING A DIRECTORY OF MATCHING ENTRIES AND ENTRY     */
13130000    /*      TYPE TOTALS FOR ONE OR MORE SMP/E LIST COMMAND OUTPUT LISTINGS,        */
13140000    /*      IDENTIFYING AND MATCHING ENTRIES WHICH SATISY CERTAIN CONDITIONS,      */
13150000    /*      PROVIDING PRE-SELECTED INPUT TO OTHER LIST COMMAND OUTPUT PROCESSING   */
13160000    /*      PROGRAMS, AND GENERATING CARD-IMAGE FILES THAT CAN BE EDITED AND       */
13170000    /*      TAILORED FOR OTHER USES.  SOME SPECIFIC INSTANCES ARE TO:              */
13180000    /*                                                                             */
13190000    /*             .IDENTIFY DDDEF ENTRIES:                                        */
13200000    /*                                                                             */
13210000    /*                -REFERENCING VOLUME SERIAL NUMBERS NO LONGER DEFINED, OR     */
13220000    /*                 DEVICE TYPES NO LONGER INSTALLED.                           */
13230000    /*                                                                             */
13240000    /*                -THAT SHOULD BE DEFINED IN ALL (SAY) TARGET ZONES, BUT       */
13250000    /*                 AREN'T.                                                     */
13260000    /*                                                                             */
13270000    /*                -REFERENCING VOLUME SERIAL NUMBERS INAPPROPRIATE TO A        */
13280000    /*                 ZONE.                                                       */
13290000    /*                                                                             */
13300000    /*             .IDENTIFY LOAD MODULES:                                         */
13310000    /*                                                                             */
13320000    /*                -CROSS-SYSTEM THAT ARE DEFINED IN SOME BUT NOT ALL OF THE    */
13330000    /*                 LISTED TARGET ZONES.                                        */
13340000    /*                                                                             */
13350000    /*                -CONTAINING MODULES FOR A PARTICULAR FMID OR GROUP OF        */
13360000    /*                 FMID'S TO ASSIST IN THE INSTALLATION OF A NEW FMID.         */
13370000    /*                                                                             */
13380000    /*                -APPEARING IN MORE THAN ONE SYSTEM LIBRARY FOR A GIVEN       */
13390000    /*                 ZONE, OR IN MORE THAN ONE LIBRARY FOR SOME TARGET ZONES     */
13400000    /*                 BUT NOT FOR ALL.                                            */
13410000    /*                                                                             */
13420000    /*             .ALLOW IDENTIFICATION OF SYSMODS:                               */
13430000    /*                                                                             */
13440000    /*                -CONTAINING JCLIN, AND EITHER UPDATING OR REPLACING A        */
13450000    /*                 SYSGEN MACRO.                                               */
13460000    /*                                                                             */
13470000    /*                -RECEIVED ON A PARTICULAR DATE, DATE AND TIME, OR BETWEEN    */
13480000    /*                 ONE OR MORE RANGES OF DATES (AND TIMES).                    */
13490000    /*                                                                             */
13500000    /*                -REFERENCING A GIVEN MACRO, MODULE, APAR, FUNCTION, OR       */
13510000    /*                 PTF, WHETHER APPLIED, ACCEPTED, OR ONLY JUST RECEIVED.      */
13520000    /*                                                                             */
13530000    /*                -APPLIED TO A TARGET ZONE BETWEEN TWO DATES AND EITHER       */
13540000    /*                 ACCEPTED AFTER A CERTAIN DATE, OR NOT ACCEPTED AT ALL.      */
13550000    /*                 MOREOVER, THESE TYPES OF TESTS CAN INVOLVE MORE THAN ONE    */
13560000    /*                 TARGET ZONE, WITH DIFFERENT RANGES OF DATES FOR EACH        */
13570000    /*                 ZONE.                                                       */
13580000    /*                                                                             */
13590000    /*             .PROVIDE A CONTROL CARD OUTPUT FILE OF THE SELECTED ENTRIES     */
13600000    /*              THAT CAN BE EDITED:                                            */
13610000    /*                                                                             */
13620000    /*                -AND USED AS INPUT TO SMP/E TO INSTALL SPECIAL-PURPOSE       */
13630000    /*                 MAINTENANCE, OR SELECT CERTAIN SYSMODS FOR APPLY, ACCEPT,   */
13640000    /*                 OR RESTORE PROCESSING.                                      */
13650000    /*                                                                             */
13660000    /*                                                                             */
13670000    /*   PROGRAMMING NOTES                                                         */
13680000    /*                                                                             */
13690000    /*            THIS SECTION DESCRIBES SOME OF THE MORE IMPORTANT                */
13700000    /*      CONSIDERATIONS UNDERLYING THE STRUCTURE AND CODING OF SMPSCAN, IN      */
13710000    /*      CASE CORRECTIONS, CHANGES, OR ENHANCEMENTS ARE NEEDED:                 */
13720000    /*                                                                             */
13730000    /*             .AFTER ANY PROGRAM CHANGES ARE MADE, THE VALUE IN VARIABLE      */
13740000    /*              SMPSCAN_LVL SHOULD REFLECT THE VERSION AND NEW LEVEL OF        */
13750000    /*              SMPSCAN.  THIS VALUE APPEARS IN THE SMPDCTRY OUTPUT IN TITLE   */
13760000    /*              LINE NUMBER 1.                                                 */
13770000    /*                                                                             */
13780000    /*             .THE MAJOR DATA STRUCTURES WITHIN SMPSCAN WERE DECLARED         */
13790000    /*              "CONTROLLED" WITH VARIABLE DIMENSIONS IN ORDER TO MAKE ARRAY   */
13800000    /*              SIZES EASY TO EXPAND.  THESE DIMENSION VARIABLES WERE          */
13810000    /*              REFERENCED BOTH IN STRUCTURAL DECLARATIONS AND DO GROUPS.      */
13820000    /*              THE MORE IMPORTANT OF THESE DIMENSION VARIABLES ARE:           */
13830000    /*                                                                             */
13840000    /*                -IMATCH_MAX:  DETERMINES THE NUMBER OF ENTRIES IN            */
13850000    /*                              MATCH_ARRAY, CURRENTLY SET AT 032.             */
13860000    /*                                                                             */
13870000    /*                -IFILE_MAX:   DEFINES THE MAXIMUM NUMBER OF INPUT LISTING    */
13880000    /*                              FILES SUPPORTED, CURRENTLY SET AT 016.  IF     */
13890000    /*                              SUPPORT FOR MORE THAN 016 FILES IS DESIRED,    */
13900000    /*                              PROGRAM VARIABLES BEGINNING WITH "DTF", THE    */
13910000    /*                              FILE VARIABLES AND ASSOCIATED LISTS MUST       */
13920000    /*                              ALSO BE UPDATED ACCORDINGLY.  OTHERWISE, THE   */
13930000    /*                              SOLE DEPENDENCY IS ON THE VALUE IN             */
13940000    /*                              IFILE_MAX, SINCE THE FILE MANAGEMENT           */
13950000    /*                              STRUCTURES ARE "CONTROLLED" WITH VARIABLE      */
13960000    /*                              SUBSCRIPTS.                                    */
13970000    /*                                                                             */
13980000    /*                -IPLANE_MAX:  DETERMINES THE NUMBER OF PLANES IN EACH        */
13990000    /*                              SCAN_ARRAY FILE CROSS-SECTION, CURRENTLY SET   */
14000000    /*                              AT 012.                                        */
14010000    /*                                                                             */
14020000    /*                -IROW_MAX:    DETERMINES THE NUMBER OF ROWS IN EACH          */
14030000    /*                              SCAN_ARRAY PLANE, CURRENTLY SET AT 012.        */
14040000    /*                                                                             */
14050000    /*                -ICOL_MAX:    DETERMINES THE NUMBER OF COLUMNS IN EACH       */
14060000    /*                              SCAN_ARRAY ROW, CURRENTLY SET AT 012.          */
14070000    /*                                                                             */
14080000    /*                -PLIXOPT:     AFTER ANY PROGRAM CHANGES THAT INCREASE        */
14090000    /*                              SMPSCAN'S VIRTUAL STORAGE REQUIREMENTS, THE    */
14100000    /*                              ISASIZE AND HEAP OPTIONS IN PLIXOPT MAY NEED   */
14110000    /*                              TO BE REVISED.                                 */
14120000    /*                                                                             */
14130000    /*             .IF IT BECOMES NECESSARY TO ADD SUPPORT FOR NEW SMP/E ENTRY     */
14140000    /*              TYPES IN THE FUTURE, THE FOLLOWING PROGRAM AREAS SHOULD BE     */
14150000    /*              REVIEWED:                                                      */
14160000    /*                                                                             */
14170000    /*                -NTRYINDX_MAX:  THIS VARIABLE DEFINES AN ARBITRARY UPPER     */
14180000    /*                              LIMIT TO THE NUMBER OF DISTINCT ENTRY TYPES.   */
14190000    /*                              ITS VALUE IS CURRENTLY SET AT 024, WITH        */
14200000    /*                              14 VALUES IN ACTUAL USE.                       */
14210000    /*                                                                             */
14220000    /*                -ENTRY_TYPE:  THIS SUBROUTINE MAPS AN ENTRY TYPE NAME TO     */
14230000    /*                              AN SMPSCAN INTERNAL INDEX VALUE.  NEW ENTRY    */
14240000    /*                              TYPE NAMES AND ABBREVIATIONS FOR NEW OR        */
14250000    /*                              EXISTING TYPES SHOULD BE ADDED HERE.           */
14260000    /*                                                                             */
14270000    /*                -ENTRY_INDEX: THIS SUBROUTINE MAPS AN SMPSCAN ENTRY TYPE     */
14280000    /*                              INTERNAL INDEX VALUE BACK TO AN ENTRY TYPE     */
14290000    /*                              NAME.  NAMES OF NEW ENTRY TYPES, BUT NOT       */
14300000    /*                              ABBREVIATIONS, SHOULD BE ADDED HERE.           */
14310000    /*                                                                             */
14320000    /*                -SMPDATA_ENTRY_LINE_WRITE:  THIS SUBROUTINE AND ITS          */
14330000    /*                              SUBORDINATE SUBROUTINES                        */
14340000    /*                              WRITE_DATA_FORMAT1_LINE THROUGH                */
14350000    /*                              WRITE_DATA_FORMAT5_LINE SHOULD BE REVIEWED     */
14360000    /*                              AND FORMATTING ROUTINES FOR ANY NEW LINE       */
14370000    /*                              TYPES SHOULD BE ADDED AS NEEDED.               */
14380000    /*                                                                             */
14390000    /*                -SMPDCTRY_ENTRY_FILE_STYPE_INFO:  IF SPECIAL ENTRY           */
14400000    /*                              INFORMATION IS DESIRED IN SMPDCTRY ENTRY       */
14410000    /*                              LINE LOCATIONS 026-040 THIS SUBROUTINE, THE    */
14420000    /*                              CORRESPONDING DATA COLLECTION LOGIC IN         */
14430000    /*                              SMPLIST_ENTRY_LINE_EVAL, AND ANY NEW           */
14440000    /*                              VARIABLE DEFINITIONS NEEDED IN                 */
14450000    /*                              SMPLIST.CURR_PAGE AND SMPLIST.CURR_NTRY WILL   */
14460000    /*                              NEED TO BE CONSIDERED.                         */
14470000    /*                                                                             */
14480000    /*                -SCANDOC:     FINALLY, THIS DOCUMENTATION SHOULD BE          */
14490000    /*                              REVIEWED, AND THE NEW ENTRY TYPE MENTIONED     */
14500000    /*                              AT LEAST IN CONJUNCTION WITH THE MATCH_ARRAY   */
14510000    /*                              "TYPE" VARIABLE.                               */
14520000    /*                                                                             */
14530000    /*                                                                             */
14540000    /*   UPDATE HISTORY                                                            */
14550000    /*                                                                             */
14560000    /*             .MODULE UPGRADED FROM "PTSSCAN" TO SUPPORT SMP/E,               */
14570000    /*              RENAMED TO "SMPSCAN", TESTED, AND DOCUMENTED.      12/31/86 TJA*/
14580000    /*                                                                             */
14590000    /*******************************************************************************/
14600000    /*                                                                             */
14610000    /*>>>>>>>>>>>>>>>>>>>>>>>>C U I C   D I S C L A I M E R<<<<<<<<<<<<<<<<<<<<<<<<*/
14620000    /*                                                                             */
14630000    /*******************************************************************************/
14640000    /*            THE INFORMATION OR MATERIAL BEING PROVIDED BY COMMERCIAL UNION   */
14650000    /*      INSURANCE COMPANY (CUIC), WHETHER IN HARD COPY OR MACHINE READABLE     */
14660000    /*      FORM, HAS BEEN DEVELOPED BY CUIC FOR ITS OWN PURPOSE AND FOR USE ON    */
14670000    /*      ITS OWN EQUIPMENT AND WITHIN ITS OWN DATA PROCESSING SYSTEM.  CUIC     */
14680000    /*      MAKES NO REPRESENTATIONS OR WARRANTIES WHATSOEVER WITH RESPECT TO      */
14690000    /*      THE INFORMATION OR MATERIAL FURNISHED HEREUNDER, EXPRESSED OR          */
14700000    /*      IMPLIED, INCLUDING BUT NOT LIMITED TO ANY REPRESENTATION OR WARRANTY   */
14710000    /*      OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR USE OR PURPOSE OR     */
14720000    /*      THAT THE USE OF THE INFORMATION OR MATERIAL WILL NOT INFRINGE ANY      */
14730000    /*      PATENT, COPYRIGHT, TRADEMARK, OR OTHER PROPRIETARY INTEREST.  YOU      */
14740000    /*      ARE, THEREFORE, ACCEPTING THIS INFORMATION OR MATERIAL ON AN "AS IS"   */
14750000    /*      BASIS AND WILL BE USING IT AT YOUR OWN RISK.  NEITHER CUIC NOR ANY     */
14760000    /*      OF ITS AFFILIATES SHALL BE LIABLE WITH RESPECT TO ANY CLAIM, ACTION,   */
14770000    /*      OR DEMAND BY ANY USER OR OTHER PARTY (INCLUDING ANY CLAIM, ACTION,     */
14780000    /*      OR DEMAND FOR CONSEQUENTIAL DAMAGES EVEN IF CUIC HAS BEEN ADVISED OF   */
14790000    /*      THE POSSIBILITY OF SUCH DAMAGES) ARISING FROM THE USE OF THE           */
14800000    /*      INFORMATION OR THE MATERIALS AND CONCEPTS RELATED THERETO.             */
14810000    /*      FURTHERMORE, CUIC WILL NOT MAINTAIN, CORRECT, OR UPDATE THIS           */
14820000    /*      INFORMATION OR MATERIAL IN THE FUTURE.                                 */
14830000    /*                                                                  01/26/83   */
14840000    /*******************************************************************************/
14850000    /*                                                                             */
14860000    /*             DIRECT COMMENTS, QUESTIONS, AND SUGGESTIONS FOR ENHANCEMENTS    */
14870000    /*      TO THE AUTHOR.........                                                 */
14880000    /*                                                                             */
14890000    /*             THOMAS J. AUBREY                                                */
14900000    /*             INFORMATION SYSTEMS AND SERVICES - DATA PROCESSING DIVISION     */
14910000    /*             COMMERCIAL UNION INSURANCE COMPANIES                            */
14920000    /*             ONE BEACON STREET - THIRTEENTH FLOOR                            */
14930000    /*             BOSTON, MASSACHUSETTS  02108                                    */
14940000    /*             TELEPHONE: (617) 725-6208                                       */
14950000    /*                                                                             */
14960000    /*******************************************************************************/;
14970000    %SKIP(3);
14980000    DECLARE                    /*SPECIFY GLOBAL PROGRAM VALUES*/
14990000         SMPSCAN_LVL             CHAR(005) INIT('02.00'),    /*PROGRAM VERSION & LEVEL   */
15000000         SYSPARM                 CHAR(100) VARYING,          /*EXEC PARAMETER DATA       */
15010000         PLIXOPT                 CHAR(128) VARYING           /*EXEC-TIME RUN OPTIONS     */
15020000                                 STATIC EXTERNAL
15030000                INIT('ISASIZE(0064K),HEAP(2048K,512K),STAE,COUNT,FLOW(256,064),REPORT');
15040000    %PAGE;
15050000    DECLARE                    /*LIST THE BUILT-IN FUNCTIONS USED */
15060000        (ADDR,
15070000         ALL,
15080000         ANY,
15090000         BOOL,
15100000         CEIL,
15110000         DATE,
15120000         DIM,
15130000         FLOOR,
15140000         HIGH,
15150000         INDEX,
15160000         LENGTH,
15170000         LINENO,
15180000         LOG,LOG2,LOG10,
15190000         LOW,
15200000         MAX,
15210000         MIN,
15220000         PLIDUMP,
15230000         REPEAT,
15240000         SIGN,
15250000         STRING,
15260000         SUBSTR,
15270000         TIME,
15280000         UNSPEC,
15290000         VERIFY)                 BUILTIN;
15300000    %SKIP(2);
15310000    DECLARE                    /*DEFINE FREQUENTLY_USED PROGRAM CONSTANTS*/
15320000         SEMI_C                  CHAR(001) INIT(';');
15330000    %PAGE;
15340000    DECLARE                    /*DECLARE DO LOOP INDEX VARIABLES*/
15350000         IMATCH                  FIXED BIN(15,0),
15360000         IMATCH_MIN              FIXED BIN(15,0) INIT(001),
15370000         IMATCH_MAX              FIXED BIN(15,0) INIT(032),
15380000
15390000         IFILE                   FIXED BIN(15,0),
15400000         IFILE_MIN               FIXED BIN(15,0) INIT(001),
15410000         IFILE_MAX               FIXED BIN(15,0) INIT(016),
15420000
15430000         ILINE                   FIXED BIN(15,0),
15440000         LINE_SAVE_LIMIT   FIXED BIN(31,0) STATIC INTERNAL INIT(0100),
15450000         LIST_LINE_SIZE    FIXED BIN(31,0) STATIC INTERNAL INIT(120),
15460000         LIST_LINE_RCZC    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPDCTRY LINE SIZE*/
15470000         LIST_LINE_RCZD    FIXED BIN(31,0) STATIC INTERNAL INIT(080), /*SMPDATA  LINE SIZE*/
15480000         LIST_LINE_RCZL    FIXED BIN(31,0) STATIC INTERNAL INIT(121), /*SMPLIST  LINE SIZE*/
15490000         LIST_LINE_RCZN    FIXED BIN(31,0) STATIC INTERNAL INIT(133), /*SMPSCAN  LINE SIZE*/
15500000         LIST_LINE_DBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),
15510000         LIST_LINE_NBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(001),
15520000         LIST_LINE_NWID    FIXED BIN(15,0) STATIC INTERNAL INIT(008),
15530000         LIST_LINE_LBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(011),
15540000         LIST_LINE_LEND    FIXED BIN(15,0) STATIC INTERNAL INIT(025),
15550000         LIST_LINE_LWID    FIXED BIN(15,0) STATIC INTERNAL INIT(015),
15560000         LIST_LINE_SBGN    FIXED BIN(15,0) STATIC INTERNAL INIT(029),
15570000         LIST_LINE_DEND    FIXED BIN(15,0) STATIC INTERNAL INIT(120),
15580000
15590000         IPLANE                  FIXED BIN(15,0),
15600000         IPLANE_MIN              FIXED BIN(15,0) INIT(001),
15610000         IPLANE_MAX              FIXED BIN(15,0) INIT(012),
15620000         IROW                    FIXED BIN(15,0),
15630000         IROW_MIN                FIXED BIN(15,0) INIT(001),
15640000         IROW_MAX                FIXED BIN(15,0) INIT(012),
15650000         ICOL                    FIXED BIN(15,0),
15660000         ICOL_MIN                FIXED BIN(15,0) INIT(001),
15670000         ICOL_MAX                FIXED BIN(15,0) INIT(012),
15680000         SCAN_ARRAY_ELEMENT_ADDR       POINTER,
15690000
15700000         NTRYINDX_IX             FIXED BIN(15,0),
15710000         NTRYINDX_MIN            FIXED BIN(15,0) INIT(000),
15720000         NTRYINDX_MAX            FIXED BIN(15,0) INIT(024);
15730000    %PAGE;
15740000    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */
15750000         DDIPFX                               CHAR(003) INIT('SMP'),
15760000         DDOPFX                               CHAR(003) INIT('SMP');
15770000
15780000    DECLARE                    /*USER-PROVIDED EXECUTION CONTROL VARIABLES: */
15790000         FILE_ACTIVE_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED
15800000                                              CHAR(008) VARYING;   /*ACTIVE | INACTIVE */
15810000
15820000    DECLARE                                 /*USER-PROVIDED FILE MATCH CONTROL ARRAY: */
15830000      01 MATCH_ARRAY                                    CONTROLLED,
15840000         05 ENTRY(IMATCH_MIN:IMATCH_MAX),
15850000            09 TYPE                           CHAR(016) VARYING,  /* ALL | NONE | E_TYPE */
15860000            09 COMPARE_TEST                   CHAR(008) VARYING,  /* ALL | ANY */
15870000            09 FILE(IFILE_MIN:IFILE_MAX),
15880000               13 COMPARE_OPTION          /* COMPARE | NOCOMPARE | IGCOMPARE | IGNORE */
15890000                                              CHAR(012) VARYING,
15900000
15910000               13 COMPARE_SELECT          /* SELECT | NOSELECT | IGSELECT | IGNORE */
15920000                                              CHAR(012) VARYING,
15930000
15940000               13 WRITE_OPTION                       /* WRITE  | NOWRITE */
15950000                                              CHAR(012) VARYING,
15960000
15970000               13 WRITE_SELECT            /* SELECT | NOSELECT | IGSELECT | IGNORE */
15980000                                              CHAR(012) VARYING;
15990000
16000000    DECLARE                         /*USER-PROVIDED SMPLIST ENTRY SCAN CONTROL ARRAY: */
16010000      01 SCAN_ARRAY                                     CONTROLLED,
16020000         05 FILE(IFILE_MIN:IFILE_MAX),         /*ONE SCAN CUBE FOR EACH SUPPORTED FILE*/
16030000            09 SELECT_OPTION                  CHAR(008) VARYING,  /* SELECT | EXCLUDE */
16040000            09 PLANE(IPLANE_MIN:IPLANE_MAX),
16050000               13 SELECT_OPTION               CHAR(008) VARYING,  /* SELECT | EXCLUDE */
16060000               13 ROW(IROW_MIN:IROW_MAX),
16070000                  17 SELECT_OPTION            CHAR(008) VARYING,  /* SELECT | EXCLUDE */
16080000                  17 COL(ICOL_MIN:ICOL_MAX),
16090000                     21 BEG_POS               FIXED BINARY(15,0),
16100000                     21 END_POS               FIXED BINARY(15,0),
16110000                     21 POS_LEN               FIXED BINARY(15,0),
16120000                     21 OP                    CHAR(008) VARYING,
16130000                     21 OP_OIX                FIXED BINARY(15,0),
16140000                     21 STRING                CHAR(032) VARYING,
16150000                     21 STR_LEN               FIXED BINARY(15,0),
16160000                     21 STR_NIX               FIXED BINARY(15,0);
16170000
16180000    DECLARE                    /*USER-PROVIDED OUTPUT CONTROL OPTIONS:   */
16190000         DATA_OUTPUT_OPTION(IFILE_MIN:IFILE_MAX)        CONTROLLED
16200000                                              CHAR(008) VARYING;   /*ALL | ID */
16210000    %PAGE;
16220000    DECLARE
16230000         SYSIN                 /*CONTROL VARIABLE INPUT FILE*/
16240000                                 FILE RECORD SEQUENTIAL INPUT
16250000                                 ENV(FB   RECSIZE(080)),
16260000         SYSIN_CONTROL_CARD      CHAR(080),
16270000         SYSIN_EOF               BIT(1),
16280000
16290000         SYSPRINT              /*PL/I LISTING OUTPUT FILE*/
16300000                                 FILE STREAM OUTPUT PRINT
16310000                                 ENV(VB   RECSIZE(155));
16320000    %SKIP(5);
16330000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
16340000         DTFDCTRY                FILE STREAM OUTPUT PRINT INTERNAL
16350000                                 ENV(FB  RECSIZE(LIST_LINE_RCZC));
16360000
16370000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
16380000      01 SMPDCTRY                      CONTROLLED,
16390000         05 FILEREF              FILE  VARIABLE,
16400000         05 DDNAME               CHAR(008),
16410000         05 OPEN                 BIT(01),                       /*IF THE FILE IS OPEN   */
16420000         05 PAGE_SZ              FIXED BIN(15,0),               /*OUTPUT PAGE SIZE      */
16430000         05 LINE_SZ              FIXED BIN(15,0),               /*OUTPUT LINE SIZE      */
16440000         05 CURR_PAGE,
16450000            09 PAGE_NO           FIXED BIN(31,0),               /*CURRENT PAGE NUMBER   */
16460000            09 INFO_1STLINE      FIXED BIN(15,0),         /*# OF 1ST LINE AFTER HEADINGS*/
16470000            09 NTRYINDX          FIXED BIN(15,0),
16480000            09 TITLE1_DATE       CHAR(008),                     /*TITLE_1 MM/DD/YY      */
16490000            09 TITLE1_TIME       CHAR(012),                     /*TITLE_1 HH:MM:SS.XCM  */
16500000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE-010),      /*TITLE LINE FOR LISTING*/
16510000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE);          /*TITLE LINE FOR LISTING*/
16520000    %PAGE;
16530000    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING INPUT FILE(S)*/
16540000        (DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,
16550000         DTFLIST9,DTFLST10,DTFLST11,DTFLST12,DTFLST13,DTFLST14,DTFLST15,DTFLST16)
16560000                                 FILE RECORD SEQUENTIAL INPUT INTERNAL
16570000                                      ENV(FB   RECSIZE(LIST_LINE_RCZL)),
16580000
16590000         DTFLIST_LIST(001:016)   FILE  VARIABLE  INIT(DTFLIST1,DTFLIST2,DTFLIST3,DTFLIST4,
16600000                                                      DTFLIST5,DTFLIST6,DTFLIST7,DTFLIST8,
16610000                                                      DTFLIST9,DTFLST10,DTFLST11,DTFLST12,
16620000                                                      DTFLST13,DTFLST14,DTFLST15,DTFLST16);
16630000    %SKIP(2);
16640000    DECLARE
16650000      01 SMPLIST_CNTL            CONTROLLED,    /*SMP/E "SMPLIST" FILE CONTROL STRUCTURE*/
16660000         05 A_STAT,            /*GENERAL INFORMATION ON THE SMPLIST INPUT/OUTPUT FILES  */
16670000            09 #_F_ACTIVE        FIXED BIN(15,0),             /*# OF ACTIVE INPUT FILES */
16680000         05 HIGH_PAGE,         /*RESET   INFORMATION FOR CURRENT PAGE AT END-OF-FILE    */
16690000            09 NTRYNAME          CHAR(008),
16700000            09 NTRYINDX          FIXED BIN(15,0),
16710000            09 PAGEKEY           CHAR(011),
16720000            09 NTRYKEY           CHAR(019),
16730000            09 CMPRKEY           CHAR(011),
16740000         05 HIGH_CMPR,         /*RESET   INFORMATION FOR CURRENT SMPLIST ENTRIES*/
16750000            09 RESULT            BIT(01),
16760000            09 NTRYNAME          CHAR(008),
16770000            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/
16780000            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/
16790000         05 E_CMPR,            /*COMPARE INFORMATION FOR CURRENT SMPLIST ENTRIES*/
16800000            09 RESULT            BIT(01),
16810000            09 NTRYNAME          CHAR(008),
16820000            09 NTRYINDX          FIXED BIN(15,0),         /*NTRYINDX FOR CURRENT CMPRKEY*/
16830000            09 CMPRKEY           CHAR(011),                            /*CURRENT CMPRKEY*/
16840000         05 A_MATCH,
16850000            09 ACTIVE            BIT(01),                      /*ANY E_MATCH ROWS ACTIVE*/
16860000            09 RESULT            BIT(01),
16870000            09 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)         /*ENTRY TYPE(S) BEING MATCHED*/
16880000                                 BIT(01),
16890000            09 F_OUTPUT(IFILE_MIN:IFILE_MAX)
16900000                                 BIT(01),                      /*OUTPUT CANDIDATE FILES */
16910000            09 E_MATCH(IMATCH_MIN:IMATCH_MAX),
16920000               13 NTRYINDX       FIXED BIN(15,0),             /*NTRYINDX FOR ENTRY MATCH*/
16930000               13 ACTIVE         BIT(01),                      /*THIS MATCH ENTRY ACTIVE*/
16940000               13 C_TST          BIT(01),             /*COMPARE TEST: ANY='0'B, ALL='1'B*/
16950000               13 F_MATCH(IFILE_MIN:IFILE_MAX),
16960000                  17 M_CMPR      BIT(01),                  /*IF THE ENTRY MUST    BE FOUND*/
16970000                  17 M_NOCMPR    BIT(01),                  /*IF THE ENTRY MUSTN'T BE FOUND*/
16980000                  17 M_IGCMPR    BIT(01),                  /*IF THE ENTRY MAY     BE FOUND*/
16990000                  17 M_SEL       BIT(01),                 /*FOUND ENTRY MUST   BE SELECTED*/
17000000                  17 M_NOSEL     BIT(01),                 /*FOUND ENTRY MUSN'T BE SELECTED*/
17010000                  17 M_IGSEL     BIT(01),                 /*FOUND ENTRY IGNORE    SELECT  */
17020000                  17 W_OUT       BIT(01),                 /*WRITE BASED ON WRITE_SELECT   */
17030000                  17 W_SEL       BIT(01),                 /*WRITE MATCH IF SELECTED       */
17040000                  17 W_NOSEL     BIT(01),                 /*WRITE MATCH IF NOT SELECTED   */
17050000                  17 W_IGSEL     BIT(01);                 /*WRITE MATCH REGARDLESS OF SEL */
17060000    %PAGE;
17070000    DECLARE
17080000      01 SMPLIST(IFILE_MIN:IFILE_MAX)  CONTROLLED,           /*LIST FILE MANAGEMENT ARRAY*/
17090000         05 FILEREF              FILE  VARIABLE,
17100000         05 DDNAME               CHAR(008),
17110000         05 ACTIVE               BIT(01),                         /*IF THE FILE IS ACTIVE*/
17120000         05 EOF                  BIT(01),
17130000         05 LINE_SZ              FIXED BIN(15,0),                /*INPUT  LINE SIZE      */
17140000         05 CURR_PAGE,
17150000            09 PAGE_BS           FIXED BIN(31,0),           /*BASE FOR 4-DIGIT PAGE NUMBR*/
17160000            09 PAGE_NO           FIXED BIN(31,0),           /*CURRENT PAGE NUMBER        */
17170000            09 PAGE_HI           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.PAGE_HI  */
17180000            09 LINE_NO           FIXED BIN(31,0),           /*LINE # ON CURRENT PAGE     */
17190000            09 FLUSH             BIT(01),                   /*SET TO '1'B TO BYPASS PAGE */
17200000            09 LINE_CT           FIXED BIN(31,0),           /*TO INIT CURR_NTRY.LINE_CT  */
17210000            09 WRITE_OUT         BIT(01),                   /*TO INIT CURR_NTRY.WRITE_OUT*/
17220000            09 CMPR_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.CMPR_RSLT*/
17230000            09 SCAN_RESULT       BIT(01),                   /*TO INIT CURR_NTRY.SCAN_RSLT*/
17240000            09 ZONENAME          CHAR(007),
17250000            09 ZONEINDX          FIXED BIN(15,0),
17260000            09 ZONETYPE          CHAR(007)  VAR,
17270000            09 ZONETYPE_C        CHAR(001),
17280000            09 NTRYNAME          CHAR(008),
17290000            09 NTRYINDX          FIXED BIN(15,0),
17300000            09 NTRYTYPE          CHAR(016)  VAR,
17310000            09 FMID              CHAR(007),                 /*TO INIT CURR_NTRY.FMID     */
17320000            09 SOURCEID          CHAR(008),                 /*TO INIT CURR_NTRY.SOURCEID */
17330000            09 SYSLIB1           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB1  */
17340000            09 SYSLIB2           CHAR(008),                 /*TO INIT CURR_NTRY.SYSLIB2  */
17350000            09 PAGEKEY           CHAR(011),
17360000            09 NTRYKEY           CHAR(019),
17370000            09 CMPRKEY           CHAR(011),
17380000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
17390000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
17400000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
17410000         05 CURR_LINE,
17420000            09 LINETYPE          CHAR(LIST_LINE_LWID),
17430000            09 IN,
17440000               13 PRTCTL         CHAR(001),
17450000               13 DATA           CHAR(LIST_LINE_SIZE),
17460000         05 CURR_NTRY,
17470000            09 PAGE_NO           FIXED BIN(31,0),            /*1ST LISTING PAGE OF ENTRY*/
17480000            09 PAGE_HI           FIXED BIN(31,0),        /*HIGHEST PAGE NUMBER FOR ENTRY*/
17490000            09 LINE_CT           FIXED BIN(31,0),            /*CURRENT LINE COUNT OF ENTRY*/
17500000            09 WRITE_OUT         BIT(01),                    /*TO WRITE THIS ENTRY       */
17510000            09 CMPR_RESULT       BIT(01),                    /*TO READ NEXT ENTRY        */
17520000            09 SCAN_RESULT       BIT(01),                    /*IF ENTRY SELECTED FOR PROC*/
17530000            09 ZONENAME          CHAR(007),
17540000            09 ZONEINDX          FIXED BIN(15,0),
17550000            09 ZONETYPE          CHAR(007)  VAR,
17560000            09 ZONETYPE_C        CHAR(001),
17570000            09 NTRYNAME          CHAR(008),
17580000            09 NTRYINDX          FIXED BIN(15,0),
17590000            09 NTRYTYPE          CHAR(016)  VAR,
17600000            09 FMID              CHAR(007),
17610000            09 SOURCEID          CHAR(008),
17620000            09 SYSLIB1           CHAR(008),
17630000            09 SYSLIB2           CHAR(008),
17640000            09 PAGEKEY           CHAR(011),
17650000            09 NTRYKEY           CHAR(019),
17660000            09 CMPRKEY           CHAR(011),
17670000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
17680000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
17690000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),    /*SAVE TITLE LINE FROM LISTING*/
17700000         05 M_E_TYPE(NTRYINDX_MIN:NTRYINDX_MAX)   /*ENTRY TYPE(S) BEING MATCHED FOR FILE*/
17710000                                 BIT(01),
17720000         05 SCAN_CUBE,
17730000            09 RESULT            BIT(01),
17740000            09 SELECT            BIT(01),
17750000            09 ACTIVE            BIT(01),                        /*ANY SCAN_ARRAY PLANES*/
17760000            09 PLANE(IPLANE_MIN:IPLANE_MAX),
17770000               13 RESULT         BIT(01),
17780000               13 SELECT         BIT(01),
17790000               13 ACTIVE         BIT(01),                          /*ANY SCAN_ARRAY ROWS*/
17800000               13 ROW(IROW_MIN:IROW_MAX),
17810000                  17 RESULT      BIT(01),
17820000                  17 SELECT      BIT(01),
17830000                  17 ACTIVE      BIT(01),                          /*ANY SCAN_ARRAY COLS*/
17840000         05 FILE_TOTALS,
17850000            09 #_S_ACTIVE        FIXED BIN(15,0),    /*# OF ACTIVE SCAN PLANES/ROWS/COLS*/
17860000            09 #_F_OUTPUT        FIXED BIN(15,0),    /*# OF ACTIVE OUTPUT FILES         */
17870000            09 #_E_T_FOUND       FIXED BIN(15,0),    /*# OF DISTINCT ENTRY TYPES FOUND  */
17880000            09 RCRD_CT           FIXED BIN(31,0),           /*TOTAL NUMBER OF LINES READ*/
17890000         05 ENTRY_TOTALS(NTRYINDX_MIN:NTRYINDX_MAX+1),  /*ONE SUBSTRUCTURE FOR EACH TYPE*/
17900000                                                        /*PLUS ONE(MAX+1) FOR ALL TYPES */
17910000            09 ENTRY_CT          FIXED BIN(31,0),           /*NUMBER OF ENTRIES         */
17920000            09 LIST_PAGELO       FIXED BIN(31,0),           /*PAGE # OF FIRST INPUT PAGE*/
17930000            09 LIST_PAGEHI       FIXED BIN(31,0),           /*PAGE # OF HIGH  INPUT PAGE*/
17940000            09 LINE_CT           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRIES*/
17950000            09 MAXNAME           CHAR(008),                 /*ENTRY WITH MOST LINES     */
17960000            09 MAXLINE           FIXED BIN(31,0),           /*NUMBER OF LINES IN ENTRY  */
17970000            09 MAXPAGE           FIXED BIN(31,0),           /*PAGE ON WHICH ENTRY STARTS*/
17980000            09 SELECT_CT         FIXED BIN(31,0),           /*# OF ENTRIES SELECTED/SCAN*/
17990000            09 MATCH_CT          FIXED BIN(31,0),           /*# OF ENTRIES MATCHED /CMPR*/
18000000            09 WRITE_CT          FIXED BIN(31,0);           /*# OF ENTRIES WRITTEN      */
18010000    %SKIP(8);
18020000    DECLARE                    /*SMP/E "SMPLIST" TITLE LINE MAPPING POINTERS  */
18030000        (SMPLIST_TITLE1_MAP_ADDR,
18040000         SMPLIST_TITLE2_MAP_ADDR,
18050000         SMPLIST_TITLE3_MAP_ADDR)              POINTER;
18060000    %PAGE;
18070000    DECLARE                    /*SMP/E "SMPLIST" TITLE LINE MAPPINGS          */
18080000      01 SMPLIST_TITLE1_MAP      BASED(SMPLIST_TITLE1_MAP_ADDR),
18090000         05 EDATE                CHAR(004),    /*DATE*/
18100000         05 FILL02               CHAR(001),
18110000         05 LDATE                ,
18120000            09 YY                PIC'99',      /*YY*/
18130000            09 P                 CHAR(001),    /*.*/
18140000            09 DDD               PIC'999',     /*DDD*/
18150000         05 FILL03               CHAR(002),
18160000         05 ETIME                CHAR(004),    /*TIME*/
18170000         05 FILL04               CHAR(001),
18180000         05 LTIME                ,
18190000            09 HH                PIC'99',      /*HH*/
18200000            09 C1                CHAR(001),    /*:*/
18210000            09 MM                PIC'99',      /*MM*/
18220000            09 C2                CHAR(001),    /*:*/
18230000            09 SS                PIC'99',      /*SS*/
18240000         05 FILL05               CHAR(006),
18250000         05 EGIMSMP              CHAR(006),    /*GIMSMP*/
18260000         05 FILL06               CHAR(001),
18270000         05 ELVL                 CHAR(003),    /*LVL*/
18280000         05 FILL07               CHAR(001),
18290000         05 LVL                  ,
18300000            09 VV                PIC'99',      /*VV*/
18310000            09 P                 CHAR(001),    /*.*/
18320000            09 LL                PIC'99',      /*LL*/
18330000         05 FILL08               CHAR(001),
18340000         05 ESMPLIST             CHAR(007),    /*SMPLIST*/
18350000         05 FILL09               CHAR(002),
18360000         05 EOUTPUT              CHAR(006),    /*OUTPUT*/
18370000         05 FILL10               CHAR(005),
18380000         05 EDASH                CHAR(001),    /*-*/
18390000         05 FILL11               CHAR(001),
18400000         05 ENOWSET              CHAR(010),    /*NOW SET TO*/
18410000         05 FILL12               CHAR(001),
18420000         05 ZONETYPE             CHAR(006),    /*TYPE OF ZONE*/
18430000         05 FILL13               CHAR(001),
18440000         05 EZONE                CHAR(004),    /*ZONE*/
18450000         05 FILL14               CHAR(001),
18460000         05 ZONENAME             CHAR(007),    /*NAME OF ZONE*/
18470000         05 FILL15               CHAR(008),
18480000         05 EPAGE                CHAR(004),    /*PAGE*/
18490000         05 FILL16               CHAR(001),
18500000         05 PAGE_NO              PICTURE'9999',/*NNNN*/
18510000         05 FILL17               CHAR(002),
18520000      01 SMPLIST_TITLE2_MAP      BASED(SMPLIST_TITLE2_MAP_ADDR),
18530000         05 ZONENAME             CHAR(007),    /*NAME OF ZONE  BEING LISTED*/
18540000         05 FILL01               CHAR(001),
18550000         05 NTRYTYPE             CHAR(112),    /*TYPE OF ENTRY BEING LISTED*/
18560000      01 SMPLIST_TITLE3_MAP      BASED(SMPLIST_TITLE3_MAP_ADDR),
18570000         05 FILL01               CHAR(002),
18580000         05 ENAME                CHAR(004),    /*NAME*/
18590000         05 FILL02               CHAR(114);
18600000    %PAGE;
18610000    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING SPILL FILE(S)*/
18620000        (DTFUT1,DTFUT2, DTFUT3, DTFUT4, DTFUT5, DTFUT6, DTFUT7, DTFUT8,
18630000         DTFUT9,DTFUT10,DTFUT11,DTFUT12,DTFUT13,DTFUT14,DTFUT15,DTFUT16)
18640000                                 FILE RECORD SEQUENTIAL INTERNAL     /*INPUT AND OUTPUT*/
18650000                                 ENV(FB   RECSIZE(LIST_LINE_SIZE)),
18660000
18670000         DTFUT_LIST(001:016)     FILE  VARIABLE  INIT(DTFUT1, DTFUT2, DTFUT3, DTFUT4,
18680000                                                      DTFUT5, DTFUT6, DTFUT7, DTFUT8,
18690000                                                      DTFUT9, DTFUT10,DTFUT11,DTFUT12,
18700000                                                      DTFUT13,DTFUT14,DTFUT15,DTFUT16);
18710000    %SKIP(5);
18720000    DECLARE                    /*SMP/E "SMPLIST" ELEMENT LISTING SPILL FILE(S)*/
18730000      01 SMPUT(IFILE_MIN:IFILE_MAX)    CONTROLLED,  /*SPILL FILE MANAGEMENT ARRAY*/
18740000         05 FILEREF              FILE  VARIABLE,
18750000         05 DDNAME               CHAR(008),
18760000         05 LINE_SAVE(LINE_SAVE_LIMIT) CHAR(LIST_LINE_SIZE),  /*RESERVE SAVE_LIMIT LINES*/
18770000         05 WRITE,
18780000            09 SAVE_CT           FIXED BIN(31,0),
18790000            09 OPEN_CT           FIXED BIN(31,0),
18800000            09 LINE_CT           FIXED BIN(31,0),
18810000         05 READ,
18820000            09 OPEN_CT           FIXED BIN(31,0),
18830000            09 LINE_CT           FIXED BIN(31,0);
18840000    %PAGE;
18850000    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/
18860000        (DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,
18870000         DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16)
18880000                                 FILE STREAM OUTPUT PRINT INTERNAL
18890000                                 ENV(FB  RECSIZE(LIST_LINE_RCZN)),
18900000
18910000         DTFSCAN_LIST(001:016)   FILE  VARIABLE  INIT(DTFSCAN1,DTFSCAN2,DTFSCAN3,DTFSCAN4,
18920000                                                      DTFSCAN5,DTFSCAN6,DTFSCAN7,DTFSCAN8,
18930000                                                      DTFSCAN9,DTFSCN10,DTFSCN11,DTFSCN12,
18940000                                                      DTFSCN13,DTFSCN14,DTFSCN15,DTFSCN16);
18950000    %SKIP(5);
18960000    DECLARE                      /*SMPSCAN SMPLIST SCAN HIGHLIGHTED OUTPUT*/
18970000      01 SMPSCAN(IFILE_MIN:IFILE_MAX)  CONTROLLED,
18980000         05 FILEREF              FILE  VARIABLE,
18990000         05 DDNAME               CHAR(008),
19000000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
19010000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
19020000         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */
19030000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
19040000         05 CURR_PAGE,
19050000            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */
19060000            09 PAGEKEY           CHAR(011),
19070000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19080000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19090000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19100000         05 CURR_NTRY,
19110000            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */
19120000            09 PAGEKEY           CHAR(011);
19130000
19140000    DECLARE                      /*SMPSCAN DIRECTORY OUTPUT */
19150000         SMPSCAN_TITLE1_MAP_ADDR                 POINTER,
19160000      01 SMPSCAN_TITLE1_MAP      BASED(SMPSCAN_TITLE1_MAP_ADDR)
19170000                                 LIKE  SMPLIST_TITLE1_MAP;
19180000    %PAGE;
19190000    DECLARE                      /*SMPSCAN SMPLIST RELIST OUTPUT*/
19200000        (DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,
19210000         DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16)
19220000                                 FILE STREAM OUTPUT PRINT INTERNAL
19230000                                 ENV(FB  RECSIZE(LIST_LINE_RCZL)),
19240000
19250000         DTFSOUT_LIST(001:016)   FILE  VARIABLE  INIT(DTFSOUT1,DTFSOUT2,DTFSOUT3,DTFSOUT4,
19260000                                                      DTFSOUT5,DTFSOUT6,DTFSOUT7,DTFSOUT8,
19270000                                                      DTFSOUT9,DTFSOU10,DTFSOU11,DTFSOU12,
19280000                                                      DTFSOU13,DTFSOU14,DTFSOU15,DTFSOU16);
19290000    %SKIP(5);
19300000    DECLARE
19310000      01 SMPSOUT(IFILE_MIN:IFILE_MAX)  CONTROLLED,
19320000         05 FILEREF              FILE  VARIABLE,
19330000         05 DDNAME               CHAR(008),
19340000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
19350000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
19360000         05 PAGE_SZ              FIXED BIN(15,0),          /*OUTPUT PAGE SIZE            */
19370000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
19380000         05 CURR_PAGE,
19390000            09 PAGE_NO           FIXED BIN(31,0),          /*CURRENT PAGE NUMBER         */
19400000            09 PAGEKEY           CHAR(011),
19410000            09 TITLE1_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19420000            09 TITLE2_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19430000            09 TITLE3_DATA       CHAR(LIST_LINE_SIZE),     /*SAVE TITLE LINE FROM LISTING*/
19440000         05 CURR_NTRY,
19450000            09 PAGE_NO           FIXED BIN(31,0),          /*FIRST LISTING PAGE OF ENTRY */
19460000            09 PAGEKEY           CHAR(011);
19470000
19480000    DECLARE
19490000         SMPSOUT_TITLE1_MAP_ADDR                 POINTER,
19500000      01 SMPSOUT_TITLE1_MAP      BASED(SMPSOUT_TITLE1_MAP_ADDR)
19510000                                 LIKE  SMPLIST_TITLE1_MAP;
19520000
19530000    %PAGE;
19540000    DECLARE                      /*SMPSCAN SMPLIST CARD IMAGE OUTPUT*/
19550000        (DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,
19560000         DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16)
19570000                                 FILE STREAM OUTPUT INTERNAL
19580000                                 ENV(FB  RECSIZE(LIST_LINE_RCZD)),
19590000
19600000         DTFDATA_LIST(001:016)   FILE  VARIABLE  INIT(DTFDATA1,DTFDATA2,DTFDATA3,DTFDATA4,
19610000                                                      DTFDATA5,DTFDATA6,DTFDATA7,DTFDATA8,
19620000                                                      DTFDATA9,DTFDAT10,DTFDAT11,DTFDAT12,
19630000                                                      DTFDAT13,DTFDAT14,DTFDAT15,DTFDAT16);
19640000    %SKIP(5);
19650000    DECLARE
19660000      01 SMPDATA(IFILE_MIN:IFILE_MAX)  CONTROLLED,
19670000         05 FILEREF              FILE  VARIABLE,
19680000         05 DDNAME               CHAR(008),
19690000         05 ACTIVE               BIT(01),                  /*IF THE FILE IS ACTIVE       */
19700000         05 OPEN                 BIT(01),                  /*IF THE FILE IS OPEN         */
19710000         05 LINE_SZ              FIXED BIN(15,0),          /*OUTPUT LINE SIZE            */
19720000         05 CURR_CARD,
19730000            09 DATA              CHAR(072),
19740000            09 SEQ_NO            FIXED BIN(31,0),
19750000         05 CURR_NTRY,
19760000            09 SEQ_NO            FIXED BIN(31,0);      /*SEQ # OF FIRST LINE OF ENTRY*/
19770000    %PAGE;
19780000 SMPSCAN_MAINLINE:
19790000    /******************************************************************/
19800000    /*   SMPSCAN MAINLINE ROUTINE                                     */
19810000    /******************************************************************/
19820000
19830000    ON ERROR
19840000       BEGIN;
19850000            ON ERROR SYSTEM;
19860000            PUT DATA;                                                           /*DEBUG*/
19870000            CALL PLIDUMP;
19880000       END;
19890000    %SKIP(03);
19900000    CALL SMPDCTRY_OPEN;             /*OPEN THE DIAGNOSTIC MSG/DIRECTORY DATA SET        */
19910000    CALL CONTROL_VALUE_INPUT;  /*INIT/READ/VALIDATE THE PROGRAM EXECUTION CONTROL VALUES*/
19920000    CALL SMPLIST_OPEN;              /*OPEN INPUT AND OUTPUT DATA SETS,                  */
19930000                                    /*AND READ THE FIRST LINES OF INPUT                 */
19940000    CALL SMPDCTRY_INITIAL_INFO;     /*DOCUMENT FILE STATUS AND CONTROL VALUES           */
19950000    CALL SMPLIST_ENTRY_READ;        /*READ THE FIRST SET OF ENTRIES, DETERMINE SCAN     */
19960000                                    /*RESULTS, COMPARE FILES FOR LOWEST KEYS, AND       */
19970000                                    /*DETERMINE IF THIS IS A MATCH.                     */
19980000
19990000    DO   WHILE(SMPLIST_CNTL.E_CMPR.RESULT);           /*WHILE ENTRIES REMAIN TO PROCESS */
20000000
20010000         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH   */
20020000             & ANY(SMPLIST.CURR_NTRY.WRITE_OUT)       /*AND ANY ARE TO BE WRITTEN,      */
20030000           THEN CALL  SMPLIST_ENTRY_WRITE;            /*WRITE OUT THE SELECTED ENTRIES. */
20040000
20050000         IF       (SMPLIST_CNTL.A_MATCH.RESULT)       /*IF THIS IS A SUCCESSFUL MATCH,  */
20060000           THEN CALL  SMPDCTRY_ENTRY_INFO;            /*WRITE ENTRY LOCATOR INFORMATION.*/
20070000
20080000         CALL  SMPLIST_ENTRY_READ;                    /*READ THE NEXT SET OF ENTRIES,   */
20090000                                                      /*DETERMINE SCAN RESULTS,         */
20100000                                                      /*COMPARE FILES FOR LOWEST KEYS,  */
20110000                                                      /*AND DETERMINE IF THIS IS A MATCH*/
20120000    END;
20130000
20140000    CALL SMPLIST_WRAPUP;            /*CALCULATE FINAL VALUES                            */
20150000    CALL SMPDCTRY_FINAL_INFO;       /*WRITE OUT FINAL PROCESSING TOTALS                 */
20160000    CALL SMPLIST_CLOSE;             /*CLOSE THE INPUT AND OUTPUT DATA SET(S)            */
20170000    CALL SMPDCTRY_CLOSE;            /*CLOSE THE DIAGNOSTIC MSG/DIRECTORY DATA SET       */
20180000
20190000    RETURN;                         /*RETURN TO CALLER OF SMPSCAN                       */
20200000 %PAGE;
20210000 SMPDCTRY_OPEN:
20220000   PROC;
20230000      ALLOCATE SMPDCTRY;                            /*ALLOCATE FILE MANAGEMENT STRUCTURE*/
20240000      SMPDCTRY.FILEREF                =   DTFDCTRY; /*INITIALIZE FILE VARIABLE REFERENCE*/
20250000      PUT STRING(SMPDCTRY.DDNAME)         EDIT(DDIPFX,'DCTRY')             (A,A);  /*DDN*/
20260000      SMPDCTRY.OPEN                   =  '0'B;              /*INITIALIZE OPEN INDICATOR */
20270000      SMPDCTRY.PAGE_SZ                =   060;              /*INITIALIZE PAGE SIZE      */
20280000      SMPDCTRY.LINE_SZ                =   LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE  */
20290000      SMPDCTRY.CURR_PAGE.PAGE_NO      =   0000;             /*INITIALIZE PAGE NUMBER    */
20300000      SMPDCTRY.CURR_PAGE.INFO_1STLINE =   000;              /*INITIALIZE 1ST INFO LINE #*/
20310000      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;   /*INITIALIZE ENTRY INDEX    */
20320000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = ' ';                /*INITIALIZE TITLE LINES    */
20330000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  = ' ';                /*INITIALIZE TITLE LINES    */
20340000
20350000      OPEN  FILE(SMPDCTRY.FILEREF) OUTPUT
20360000            PAGESIZE(SMPDCTRY.PAGE_SZ) LINESIZE(SMPDCTRY.LINE_SZ)
20370000            TITLE(SMPDCTRY.DDNAME);
20380000
20390000      SMPDCTRY.OPEN          =   '1'B;           /*INDICATE FILE IS OPEN*/
20400000
20410000   END SMPDCTRY_OPEN;
20420000 %SKIP(3);
20430000 SMPDCTRY_CLOSE: /*SUBROUTINE TO CLOSE THE "SMPDCTRY" DATA SET */
20440000    PROC;
20450000       CLOSE FILE(SMPDCTRY.FILEREF) ENV(LEAVE);
20460000
20470000      SMPDCTRY.OPEN          =   '0'B;           /*INDICATE FILE IS NO LONGER OPEN*/
20480000    END SMPDCTRY_CLOSE;      /*END OF "SMPDCTRY_CLOSE" SUBROUTINE*/
20490000 %PAGE;
20500000 SMPDCTRY_NEWPAGE:
20510000   PROC;
20520000      DCL  NEWPAGE_DATE               CHAR(006), /*STORE DATE FROM "DATE" FUNCTION*/
20530000           NEWPAGE_TIME               CHAR(009); /*STORE TIME FROM "TIME" FUNCTION*/
20540000
20550000      IF LINENO(SMPDCTRY.FILEREF) > 1 THEN PUT FILE(SMPDCTRY.FILEREF) PAGE;
20560000      SMPDCTRY.CURR_PAGE.PAGE_NO      =   SMPDCTRY.CURR_PAGE.PAGE_NO + 1;
20570000      NEWPAGE_DATE                    =   DATE();
20580000      NEWPAGE_TIME                    =   TIME();
20590000      SMPDCTRY.CURR_PAGE.TITLE1_DATE  =   SUBSTR(NEWPAGE_DATE,03,02)  /*MM*/
20600000                                       || '/'
20610000                                       || SUBSTR(NEWPAGE_DATE,05,02)  /*DD*/
20620000                                       || '/'
20630000                                       || SUBSTR(NEWPAGE_DATE,01,02); /*YY*/
20640000
20650000      SMPDCTRY.CURR_PAGE.TITLE1_TIME  =   SUBSTR(NEWPAGE_TIME,01,02)  /*HH*/
20660000                                       || ':'
20670000                                       || SUBSTR(NEWPAGE_TIME,03,02)  /*MM*/
20680000                                       || ':'
20690000                                       || SUBSTR(NEWPAGE_TIME,05,02)  /*SS*/
20700000                                       || '.'
20710000                                       || SUBSTR(NEWPAGE_TIME,07,03); /*XCM*/
20720000      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE1 LINE*/
20730000             EDIT('DATE:',SMPDCTRY.CURR_PAGE.TITLE1_DATE)  (COL(001),A,X(1),A)
20740000                 ('TIME:',SMPDCTRY.CURR_PAGE.TITLE1_TIME)  (X(2),A,X(1),A(012))
20750000                 ('SMPSCAN  LVL',SMPSCAN_LVL)              (X(2),A,X(1),A)
20760000                 ('C.U. SMP/E LIST ENTRY SELECTION')       (X(3),A)
20770000                 ('--','SMPDCTRY OUTPUT')                  (X(1),A,X(1),A)
20780000                 ('PAGE', SMPDCTRY.CURR_PAGE.PAGE_NO)      (COL(110),A,X(1),P'9999');
20790000
20800000      CALL   SMPDCTRY_NEWTITLE_2_3;              /*WRITE TITLE LINES 2 & 3*/
20810000      SMPDCTRY.CURR_PAGE.INFO_1STLINE = LINENO(SMPDCTRY.FILEREF) + 1;
20820000   END SMPDCTRY_NEWPAGE;
20830000 %SKIP(2);
20840000 SMPDCTRY_NEWTITLE_2_3:                          /*WRITE TITLE LINES 2 & 3*/
20850000   PROC;
20860000      PUT    FILE(SMPDCTRY.FILEREF)              /*TITLE2 LINE*/
20870000             EDIT(' ')                                     (SKIP(1),A)
20880000                 ('SMPSCAN')                               (SKIP(1),COL(001),A)
20890000                 (SMPDCTRY.CURR_PAGE.TITLE2_DATA)          (COL(011),A(110))
20900000                 (' ')                                     (SKIP(1),A);
20910000      IF  SMPDCTRY.CURR_PAGE.TITLE3_DATA ¬= ' '  /*IF A TITLE3 LINE IS PRESENT*/
20920000        THEN
20930000         PUT FILE(SMPDCTRY.FILEREF)
20940000             EDIT(' ')                                     (SKIP(1),A)
20950000                 (SMPDCTRY.CURR_PAGE.TITLE3_DATA)          (SKIP(1),A)
20960000                 (' ')                                     (SKIP(1),A);
20970000   END SMPDCTRY_NEWTITLE_2_3;
20980000 %PAGE;
20990000 SMPDCTRY_INITIAL_INFO:
21000000   PROC;
21010000
21020000            /*-------------------------------------------------------------------------*/
21030000            /* ASSEMBLE TITLE2 LINE AND SET UP END-OF-PAGE CONTROL:                    */
21040000            /*-------------------------------------------------------------------------*/
21050000
21060000      SMPDCTRY.CURR_PAGE.NTRYINDX     = NTRYINDX_MIN - 1;
21070000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  =
21080000              'DIAGNOSTIC MESSAGES AND EXECUTION CONTROL VALUES:';
21090000
21100000      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;
21110000
21120000            /*-------------------------------------------------------------------------*/
21130000            /* PRINT FILE STATUS INFORMATION AND SCAN_ARRAY CONTENTS FOR ALL           */
21140000            /* SUPPORTED FILES:                                                        */
21150000            /*-------------------------------------------------------------------------*/
21160000      CALL     SMPDCTRY_INITIAL_FILE_INFO;
21170000
21180000            /*-------------------------------------------------------------------------*/
21190000            /* PRINT MATCH_ARRAY CONTROL INFORMATION IF VALUES HAVE BEEN PROVIDED:     */
21200000            /*-------------------------------------------------------------------------*/
21210000      CALL     SMPDCTRY_INITIAL_MATCH_INFO;
21220000
21230000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_INFO*/
21240000 %PAGE;
21250000 SMPDCTRY_INITIAL_FILE_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO    */
21260000   PROC;
21270000
21280000      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);
21290000
21300000            /*-------------------------------------------------------------------------*/
21310000            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */
21320000            /*-------------------------------------------------------------------------*/
21330000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';
21340000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)
21350000                                      =  'STATUS INFORMATION AND SCAN ARRAY CONTENTS:';
21360000
21370000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/
21380000
21390000            /*-------------------------------------------------------------------------*/
21400000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
21410000            /*-------------------------------------------------------------------------*/
21420000
21430000      DO  IFILE = IFILE_MIN TO IFILE_MAX;                     /*FOR EACH SUPPORTED FILE*/
21440000
21450000        IF   (SMPLIST(IFILE).ACTIVE)                            /*IF THE FILE IS ACTIVE*/
21460000          THEN     CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS   ACTIVE*/;
21470000          ELSE  /* CALL SMPDCTRY_INITIAL_FILE_F_INFO        /*WHEN THE FILE IS INACTIVE*/;
21480000
21490000      END;                       /*END OF IFILE DO GROUP*/
21500000
21510000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_INFO*/
21520000     %PAGE;
21530000 SMPDCTRY_INITIAL_FILE_F_INFO:     /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_INFO*/
21540000   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_F_INFO*/
21550000            /*-------------------------------------------------------------------------*/
21560000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
21570000            /*-------------------------------------------------------------------------*/
21580000      IF   (SMPLIST(IFILE).ACTIVE)                              /*IF THE FILE IS ACTIVE*/
21590000        THEN  FILE_LIST_LINE_CT = 01 + SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT
21600000                                     + SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE;
21610000        ELSE  FILE_LIST_LINE_CT = 01;
21620000
21630000      IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))
21640000          THEN                                   /*IF LISTING WILL FIT ON CURRENT PAGE*/
21650000              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
21660000               THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);     /*CONTINUE ON CURRENT PAGE*/
21670000               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/
21680000          ELSE                                   /*IF LISTING WON'T FIT ON CURRENT PAGE*/
21690000              IF (LINENO(SMPDCTRY.FILEREF) >=  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
21700000               THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);        /*START ON A NEW PAGE     */
21710000               ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);     /*CONTINUE ON CURRENT PAGE*/
21720000
21730000      PUT FILE(SMPDCTRY.FILEREF)
21740000          EDIT('FILE(',IFILE,') IS:')                               (COL(001),A,P'999',A);
21750000
21760000      IF   (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
21770000        THEN                                                    /*IF THE FILE IS ACTIVE*/
21780000          DO;
21790000            PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                        (COL(016),A)
21800000                    ('LIST DDNAME=')                                         (COL(026),A)
21810000                    ( SMPLIST(IFILE).DDNAME)                                          (A)
21820000                    ('SCAN SELECTION IS:')                                   (COL(051),A);
21830000            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)
21840000              THEN  PUT FILE(SMPDCTRY.FILEREF) EDIT('ACTIVE')                (COL(071),A);
21850000              ELSE  PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')              (COL(071),A);
21860000            IF (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))
21870000              THEN  PUT FILE(SMPDCTRY.FILEREF)           /*IF ENTRIES ARE BEING WRITTEN*/
21880000                        EDIT('SCAN DDNAME=',SMPSCAN(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
21890000                            ('SOUT DDNAME=',SMPSOUT(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
21900000                            ('DATA DDNAME=',SMPDATA(IFILE).DDNAME) (SKIP(1),COL(026),A,A)
21910000                            ('OUTPUT OPTION IS:')                            (COL(052),A)
21920000                            ( DATA_OUTPUT_OPTION(IFILE))                     (COL(071),A);
21930000              ELSE  PUT FILE(SMPDCTRY.FILEREF)       /*IF ENTRIES ARE NOT BEING WRITTEN*/
21940000                        EDIT('**ENTRIES ARE NOT BEING WRITTEN**')    (SKIP(1),COL(026),A);
21950000            IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)             /*SCAN ARRAY INFO FOR FILE*/
21960000              THEN  CALL     SMPDCTRY_INITIAL_FILE_FS_INFO;
21970000          END;                   /*END OF ACTIVE IFILE DO GROUP*/
21980000        ELSE                                                  /*IF THE FILE IS INACTIVE*/
21990000          DO;
22000000            PUT FILE(SMPDCTRY.FILEREF) EDIT('INACTIVE')                      (COL(016),A);
22010000          END;                   /*END OF INACTIVE IFILE DO GROUP*/
22020000
22030000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_F_INFO*/
22040000 %PAGE;
22050000 SMPDCTRY_INITIAL_FILE_FS_INFO:    /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_F_INFO*/
22060000   PROC;                        /*IFILE IS SET ON ENTRY  TO SMPDCTRY_INITIAL_FILE_FS_INFO*/
22070000            /*-------------------------------------------------------------------------*/
22080000            /* IF SCAN SELECTION IS BEING USED WITH A FILE, PRINT THE SCAN_ARRAY:      */
22090000            /*-------------------------------------------------------------------------*/
22100000      PUT FILE(SMPDCTRY.FILEREF)
22110000          EDIT('SCAN_ARRAY:')                                       (SKIP(1),COL(011),A)
22120000              ('FILE SELECT OPTION IS:')                                    (COL(047),A)
22130000              (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION)                        (COL(071),A);
22140000      DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;
22150000        IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)       /*IF PLANE IS ACTIVE*/
22160000          THEN
22170000            DO;
22180000              PUT FILE(SMPDCTRY.FILEREF)
22190000                  EDIT('PLANE(',IPLANE,'):')               (SKIP(1),COL(016),A,P'999',A)
22200000                      ('PLANE SELECT OPTION IS:')                           (COL(046),A)
22210000                      (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION)  (COL(071),A);
22220000              DO  IROW = IROW_MIN TO IROW_MAX;
22230000                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
22240000                 THEN
22250000                   DO;
22260000                     PUT FILE(SMPDCTRY.FILEREF)
22270000                         EDIT('ROW(',IROW,'):')            (SKIP(1),COL(022),A,P'999',A)
22280000                             ('ROW SELECT OPTION IS:')                      (COL(048),A)
22290000                             (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION)
22300000                                                                            (COL(071),A);
22310000                     DO  ICOL = ICOL_MIN TO ICOL_MAX;
22320000                       IF  (SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0)  /*IF STRING*/
22330000                         THEN  CALL  SMPDCTRY_INITIAL_FILE_FSE_INFO;
22340000
22350000                     END;          /*END OF ICOL          DO GROUP*/
22360000                   END;            /*END OF ACTIVE IROW   DO GROUP*/
22370000              END;                 /*END OF IROW          DO GROUP*/
22380000            END;                   /*END OF ACTIVE IPLANE DO GROUP*/
22390000      END;                         /*END OF IPLANE        DO GROUP*/
22400000      RETURN;                      /*TO THE CALLER OF SMPDCTRY_INITIAL_FILE_FS_INFO*/
22410000 %PAGE;
22420000 SMPDCTRY_INITIAL_FILE_FSE_INFO:   /*SUBROUTINE INTERNAL TO SMPDCTRY_INITIAL_FILE_FS_INFO*/
22430000   PROC;                            /*IFILE, IPLANE, IROW, AND ICOL ARE SET ON ENTRY   */
22440000      PUT FILE(SMPDCTRY.FILEREF)
22450000          EDIT('COL(',ICOL,'):')                           (SKIP(1),COL(026),A,P'999',A);
22460000
22470000      PUT FILE(SMPDCTRY.FILEREF)
22480000          EDIT('OP=',
22490000                SCAN_ARRAY(IFILE).OP(IPLANE,IROW,ICOL))              (COL(037),A,A(008));
22500000
22510000      IF   (SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL) <  NTRYINDX_MIN)
22520000        THEN
22530000          DO;
22540000            PUT FILE(SMPDCTRY.FILEREF)
22550000                EDIT('BEGIN POS=',
22560000                      SCAN_ARRAY(IFILE).BEG_POS(IPLANE,IROW,ICOL))   (COL(049),A,P'999');
22570000            PUT FILE(SMPDCTRY.FILEREF)
22580000                EDIT('END POS=',
22590000                      SCAN_ARRAY(IFILE).END_POS(IPLANE,IROW,ICOL))   (COL(064),A,P'999');
22600000          END;
22610000        ELSE
22620000          DO;
22630000            PUT FILE(SMPDCTRY.FILEREF)
22640000                EDIT('ENTRY INDEX=',
22650000                      SCAN_ARRAY(IFILE).STR_NIX(IPLANE,IROW,ICOL))   (COL(060),A,P'999');
22660000          END;
22670000
22680000      PUT FILE(SMPDCTRY.FILEREF)
22690000          EDIT('STR LEN=',
22700000                SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL))         (COL(077),A,P'999');
22710000
22720000      PUT FILE(SMPDCTRY.FILEREF)
22730000          EDIT('STRING=',
22740000               '"',SCAN_ARRAY(IFILE).STRING(IPLANE,IROW,ICOL),'"')    (COL(090),A,A,A,A);
22750000
22760000   END SMPDCTRY_INITIAL_FILE_FSE_INFO;
22770000  %SKIP(2);
22780000   END SMPDCTRY_INITIAL_FILE_FS_INFO;
22790000  %SKIP(2);
22800000   END SMPDCTRY_INITIAL_FILE_F_INFO;
22810000  %SKIP(2);
22820000   END SMPDCTRY_INITIAL_FILE_INFO;
22830000 %PAGE;
22840000 SMPDCTRY_INITIAL_MATCH_INFO: /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_INFO   */
22850000   PROC;
22860000      DCL  MATCH_LIST_LINE_CT      FIXED BINARY(15,0);
22870000            /*-------------------------------------------------------------------------*/
22880000            /* ASSEMBLE TITLE3 LINE AND BEGIN A NEW PAGE:                              */
22890000            /*-------------------------------------------------------------------------*/
22900000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  ' MATCH  ';
22910000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)
22920000                                      =  'STATUS INFORMATION AND MATCH ARRAY CONTENTS:';
22930000
22940000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF)/**/;                          /*START A NEW PAGE*/
22950000
22960000            /*-------------------------------------------------------------------------*/
22970000            /* PRINT MATCH_ARRAY CONTENTS AND STATUS INFORMATION:                      */
22980000            /*-------------------------------------------------------------------------*/
22990000      IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)           /*TEST FOR ENTRY MATCH TESTS PROVIDED*/
23000000        THEN                              /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
23010000          DO    IMATCH = IMATCH_MIN TO IMATCH_MAX;
23020000            IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    /*IF MATCH ENTRY ACTIVE*/
23030000              THEN                                  /*WHEN MATCH ARRAY ENTRY IS   ACTIVE*/
23040000                  CALL  SMPDCTRY_INITIAL_MATCH_E_INFO;
23050000              ELSE                                  /*WHEN MATCH ARRAY ENTRY IS INACTIVE*/
23060000               /* CALL  SMPDCTRY_INITIAL_MATCH_E_INFO/**/;
23070000          END;                    /*END OF IMATCH DO GROUP*/
23080000
23090000        ELSE                      /*IF NO  ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
23100000            PUT FILE(SMPDCTRY.FILEREF)
23110000                EDIT('***MATCH ARRAY IS NOT ACTIVE -- ')             (SKIP(3),COL(016),A)
23120000                    ('FILE MATCHING WILL BE BASED ON SCAN RESULTS***')                (A);
23130000
23140000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_INFO*/
23150000 %PAGE;
23160000 SMPDCTRY_INITIAL_MATCH_E_INFO:
23170000                             /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_INFO*/
23180000   PROC;
23190000            /*-------------------------------------------------------------------------*/
23200000            /* PRINT MATCH_ARRAY ENTRY CONTENTS AND STATUS INFORMATION:                */
23210000            /*-------------------------------------------------------------------------*/
23220000      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/
23230000        THEN  MATCH_LIST_LINE_CT  =  01 + SMPLIST_CNTL.A_STAT.#_F_ACTIVE;
23240000        ELSE  MATCH_LIST_LINE_CT  =  01;
23250000
23260000      IF (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ - (MATCH_LIST_LINE_CT + 02)))
23270000        THEN                                      /*IF LISTING WILL FIT ON CURRENT PAGE*/
23280000            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)
23290000              THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);      /*CONTINUE ON CURRENT PAGE*/
23300000              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/
23310000        ELSE                                     /*IF LISTING WON'T FIT ON CURRENT PAGE*/
23320000            IF (LINENO(SMPDCTRY.FILEREF) >= SMPDCTRY.CURR_PAGE.INFO_1STLINE)
23330000              THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);         /*START ON A NEW PAGE     */
23340000              ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);      /*CONTINUE ON CURRENT PAGE*/
23350000
23360000      PUT FILE(SMPDCTRY.FILEREF)
23370000          EDIT('ENTRY(',IMATCH,'):')                                (COL(001),A,P'999',A)
23380000              ('ENTRY   TYPE=')                                              (COL(015),A)
23390000              ( MATCH_ARRAY.ENTRY(IMATCH).TYPE)                                       (A);
23400000
23410000      IF    SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE         /*IF MATCH ENTRY ACTIVE*/
23420000        THEN                                         /*WHEN MATCH ARRAY ENTRY IS ACTIVE*/
23430000            CALL  SMPDCTRY_INITIAL_MATCH_F_INFO;
23440000        ELSE                                     /*WHEN MATCH ARRAY ENTRY IS NOT ACTIVE*/
23450000            PUT FILE(SMPDCTRY.FILEREF)
23460000                EDIT('***ENTRY IS NOT ACTIVE***')                            (COL(036),A);
23470000
23480000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_INITIAL_MATCH_E_INFO*/
23490000 %PAGE;
23500000 SMPDCTRY_INITIAL_MATCH_F_INFO:
23510000                           /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_INITIAL_MATCH_E_INFO*/
23520000   PROC;
23530000      DCL  MATCH_FILE_LINE_NO      FIXED BINARY(15,0);
23540000            /*-------------------------------------------------------------------------*/
23550000            /* PRINT FILE MATCH INFORMATION FOR THE MATCH_ARRAY ENTRY:                 */
23560000            /*-------------------------------------------------------------------------*/
23570000      MATCH_FILE_LINE_NO = 0;                           /*PRESET FOR IFILE DO GROUP*/
23580000      DO   IFILE = IFILE_MIN TO IFILE_MAX;
23590000        IF (SMPLIST(IFILE).ACTIVE)                /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
23600000          THEN                                                  /*IF THE FILE IS ACTIVE*/
23610000            DO;
23620000              MATCH_FILE_LINE_NO = MATCH_FILE_LINE_NO + 1;
23630000
23640000              IF    (MATCH_FILE_LINE_NO = 1)
23650000                THEN PUT FILE(SMPDCTRY.FILEREF)     SKIP(1)
23660000                         EDIT('COMPARE TEST=')                               (COL(015),A)
23670000                             ( MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST)                (A);
23680000                ELSE PUT FILE(SMPDCTRY.FILEREF)     SKIP(1);
23690000
23700000              PUT FILE(SMPDCTRY.FILEREF)
23710000                  EDIT('FILE(',IFILE,'):')                          (COL(036),A,P'999',A)
23720000                      ('COMPARE: OPTION=')                                   (COL(048),A)
23730000                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION)    (A(009));
23740000              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION ¬= 'NOCOMPARE')
23750000                THEN PUT FILE(SMPDCTRY.FILEREF)
23760000                         EDIT('SELECT=')                                         (X(2),A)
23770000                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT)
23780000                                                                                 (A(008));
23790000              PUT FILE(SMPDCTRY.FILEREF)
23800000                  EDIT('WRITE: OPTION=')                                     (COL(094),A)
23810000                      ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION)      (A(007));
23820000              IF       (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION ¬= 'NOWRITE')
23830000                THEN PUT FILE(SMPDCTRY.FILEREF)
23840000                         EDIT('SELECT=')                                         (X(2),A)
23850000                             ( MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT)
23860000                                                                                 (A(008));
23870000            END;                  /*END OF ACTIVE IFILE DO GROUP*/
23880000      END;                        /*END OF IFILE DO GROUP*/
23890000
23900000   END SMPDCTRY_INITIAL_MATCH_F_INFO;
23910000  %SKIP(1);
23920000   END SMPDCTRY_INITIAL_MATCH_E_INFO;
23930000  %SKIP(1);
23940000   END SMPDCTRY_INITIAL_MATCH_INFO;
23950000  %SKIP(2);
23960000   END SMPDCTRY_INITIAL_INFO;
23970000 %PAGE;
23980000 SMPDCTRY_ENTRY_INFO:            /********************************************************/
23990000                                 /*                                                      */
24000000                                 /*                                                      */
24010000                                 /********************************************************/
24020000   PROC;
24030000      DCL  ENTRY_INFO_LINE_NO      FIXED BINARY(15,0);
24040000
24050000      ON ENDPAGE(SMPDCTRY.FILEREF) CALL SMPDCTRY_NEWPAGE;
24060000
24070000            /*-------------------------------------------------------------------------*/
24080000            /* IF THIS IS THE FIRST ENTRY BEING REPORTED, OR IF THE ENTRY TYPE IS      */
24090000            /* CHANGING, ASSEMBLE NEW TITLE2 AND TITLE3 LINES:                         */
24100000            /*-------------------------------------------------------------------------*/
24110000      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/
24120000          |                                                   /*OR NEW ENTRY TYPE      */
24130000             (SMPDCTRY.CURR_PAGE.NTRYINDX  ¬= SMPLIST_CNTL.E_CMPR.NTRYINDX)
24140000        THEN
24150000          DO;                                /*ASSEMBLE TITLES 2 & 3 FOR NEW ENTRY TYPE*/
24160000            SMPDCTRY.CURR_PAGE.TITLE2_DATA  =    'DIRECTORY OF MATCHING'
24170000                                              ||  ' '
24180000                                              ||  ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX)
24190000                                              ||  ' '
24200000                                              ||  'ENTRIES:';
24210000            SMPDCTRY.CURR_PAGE.TITLE3_DATA  =     '  NAME  ';
24220000            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,026)  =  'STATUS';
24230000            SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,066)  =  'LOCATOR INFORMATION';
24240000          END;
24250000     %PAGE;
24260000            /*-------------------------------------------------------------------------*/
24270000            /* DETERMINE WHETHER TO START A NEW PAGE, REPRINT TITLES 2 & 3 OF THE      */
24280000            /* CURRENT PAGE, OR MERELY SPACE ONE LINE BEFORE STARTING TO PRINT THE     */
24290000            /* ENTRY INFORMATION FOR THE CURRENT MATCHING ENTRY:                       */
24300000            /*-------------------------------------------------------------------------*/
24310000      IF     (SMPDCTRY.CURR_PAGE.NTRYINDX  <  NTRYINDX_MIN)   /*IF FIRST ENTRY TO WRITE*/
24320000
24330000        |    (SMPDCTRY.CURR_PAGE.NTRYINDX  ¬= SMPLIST_CNTL.E_CMPR.NTRYINDX
24340000           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/
24350000                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01 + 05))))
24360000
24370000        |    (SMPDCTRY.CURR_PAGE.NTRYINDX   = SMPLIST_CNTL.E_CMPR.NTRYINDX
24380000           & (LINENO(SMPDCTRY.FILEREF)                     /*IF NOT ENOUGH ROOM ON PAGE*/
24390000                 >  (SMPDCTRY.PAGE_SZ - (SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 01))))
24400000
24410000        THEN      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE         */
24420000        ELSE                                             /*CONTINUE ON THE CURRENT PAGE*/
24430000          IF (SMPDCTRY.CURR_PAGE.NTRYINDX  ¬= SMPLIST_CNTL.E_CMPR.NTRYINDX)
24440000
24450000          /*THEN    CALL SMPDCTRY_NEWTITLE_2_3           /*REWRITE TITLE LINES 2 & 3   */
24460000            THEN  SIGNAL ENDPAGE(SMPDCTRY.FILEREF)       /*START ON A NEW PAGE ANYWAYS */;
24470000            ELSE    PUT  FILE(SMPDCTRY.FILEREF)  SKIP(1);  /*SPACE ONE LINE            */
24480000     %SKIP(3);
24490000            /*-------------------------------------------------------------------------*/
24500000            /* PRINT THE ENTRY INFORMATION REPORT LINES FOR THE CURRENT MATCHING       */
24510000            /* ENTRY:                                                                  */
24520000            /*-------------------------------------------------------------------------*/
24530000
24540000      SMPDCTRY.CURR_PAGE.NTRYINDX  = SMPLIST_CNTL.E_CMPR.NTRYINDX;
24550000      ENTRY_INFO_LINE_NO           = 0;          /*RESET ENTRY INFORMATION LINE COUNTER*/
24560000
24570000      DO  IFILE = IFILE_MIN TO IFILE_MAX;         /*WRITE LOCATOR INFORMATION FOR ENTRY*/
24580000        IF   (SMPLIST(IFILE).ACTIVE)              /*ONE LINE FOR EACH ACTIVE INPUT FILE*/
24590000          THEN                                                  /*IF THE FILE IS ACTIVE*/
24600000               CALL SMPDCTRY_ENTRY_FILE_INFO;
24610000      END;                               /*END OF IFILE DO GROUP*/
24620000
24630000      RETURN;                                    /*TO THE CALLER OF SMPDCTRY_ENTRY_INFO*/
24640000 %PAGE;
24650000 SMPDCTRY_ENTRY_FILE_INFO:
24660000   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_INFO     */
24670000            /*-------------------------------------------------------------------------*/
24680000            /* PRINT THE ENTRY INFORMATION REPORT LINE FOR THIS SMPLIST DATA SET:      */
24690000            /*-------------------------------------------------------------------------*/
24700000
24710000      ENTRY_INFO_LINE_NO  =  ENTRY_INFO_LINE_NO  +  1;            /*UPDATE LINE COUNTER*/
24720000
24730000      IF    ENTRY_INFO_LINE_NO <= 01
24740000        THEN  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1)                 /*  ENTRY NAME       */
24750000                  EDIT(SMPLIST_CNTL.E_CMPR.NTRYNAME)                       (COL(001),A);
24760000        ELSE  PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);                /*SPACE ONE LINE     */
24770000
24780000      PUT FILE(SMPDCTRY.FILEREF)
24790000          EDIT('ZONE=',SMPLIST(IFILE).CURR_NTRY.ZONENAME)                (COL(011),A,A)
24800000                  ('/',SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C)                       (A,A);
24810000     %PAGE;
24820000      IF    SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST_CNTL.E_CMPR.NTRYINDX).ENTRY_CT > 0
24830000        THEN                                     /*IF ENTRIES OF THIS TYPE WERE LISTED*/
24840000          DO;
24850000            IF   (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
24860000              THEN                           /*IF ENTRY WAS FOUND IN THIS LISTING FILE*/
24870000                DO;
24880000                  CALL SMPDCTRY_ENTRY_FILE_STYPE_INFO;          /*FILL IN COLS 026-040*/
24890000                  PUT FILE(SMPDCTRY.FILEREF)                              /*LINE COUNT*/
24900000                      EDIT('LNCT=',SMPLIST(IFILE).CURR_NTRY.LINE_CT) (COL(041),A,P'9999');
24910000                  IF  SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT /*SPILL FILE*/
24920000                    THEN     PUT FILE(SMPDCTRY.FILEREF) EDIT('>UT<')            (X(1),A);
24930000                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('    ')            (X(1),A);
24940000
24950000                  IF      SMPLIST(IFILE).SCAN_CUBE.ACTIVE               /*SCAN ACTIVE?*/
24960000                    THEN
24970000                      IF  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT          /*SCAN RESULTS*/
24980000                        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','SEL') (COL(056),A,A);
24990000                        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','XCL') (COL(056),A,A);
25000000                    ELSE     PUT FILE(SMPDCTRY.FILEREF) EDIT('SCAN=','NOT') (COL(056),A,A);
25010000
25020000                  PUT FILE(SMPDCTRY.FILEREF)               /*INPUT LISTING PAGE NUMBER*/
25030000                      EDIT(SUBSTR(SMPLIST(IFILE).DDNAME,004),'PG=',
25040000                           SMPLIST(IFILE).CURR_NTRY.PAGE_NO)    (X(2),A,X(1),A,P'Z9999');
25050000
25060000                  IF (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)
25070000                    THEN                /*IF ENTRY WAS WRITTEN TO OUTPUT DATA SETS*/
25080000                        CALL SMPDCTRY_ENTRY_FILE_WRT_INFO;
25090000                    ELSE                /*IF ENTRY WAS NOT WRITTEN TO OUTPUT DATA SETS*/
25100000                        PUT FILE(SMPDCTRY.FILEREF) EDIT('**ENTRY NOT WRITTEN**') (X(2),A);
25110000                END;                       /*END OF SUCCESSFUL CMPR_RESULT DO GROUP*/
25120000
25130000              ELSE                      /*IF ENTRY WAS NOT FOUND IN THIS LISTING FILE*/
25140000                    PUT FILE(SMPDCTRY.FILEREF)  EDIT('**ENTRY NOT FOUND**')  (COL(056),A);
25150000          END;                          /*END OF POSITIVE ENTRY_CT DO GROUP*/
25160000        ELSE                            /*IF ENTRIES OF THIS TYPE WERE NOT LISTED*/
25170000            PUT FILE(SMPDCTRY.FILEREF)
25180000                EDIT('***',ENTRY_TYPE(SMPLIST_CNTL.E_CMPR.NTRYINDX),
25190000                     'ENTRIES NOT FOUND***')                        (COL(056),A,A,X(1),A);
25200000      RETURN;                           /*TO THE CALLER OF SMPDCTRY_ENTRY_FILE_INFO*/
25210000 %PAGE;
25220000 SMPDCTRY_ENTRY_FILE_STYPE_INFO:
25230000   PROC;                     /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_STYPE_INFO */
25240000      SELECT;
25250000        WHEN((SMPLIST(IFILE).CURR_NTRY.FMID        ¬=  ' ')         /*FMID*/
25260000           & (SMPLIST(IFILE).CURR_NTRY.ZONETYPE_C  ¬=  'G'))
25270000          PUT FILE(SMPDCTRY.FILEREF)
25280000              EDIT(' FMID=',SMPLIST(IFILE).CURR_NTRY.FMID)    (COL(026),A,A);
25290000
25300000        WHEN((SMPLIST(IFILE).CURR_NTRY.SOURCEID    ¬=  ' '))       /*SRCID*/
25310000          PUT FILE(SMPDCTRY.FILEREF)
25320000              EDIT('SRCID=',SMPLIST(IFILE).CURR_NTRY.SOURCEID) (COL(026),A,A);
25330000
25340000        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     ¬=  ' ')      /*SYSLIB1*/
25350000           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2      =  ' '))     /*SYSLIB2*/
25360000          PUT FILE(SMPDCTRY.FILEREF)
25370000              EDIT(' SLIB=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);
25380000
25390000        WHEN((SMPLIST(IFILE).CURR_NTRY.SYSLIB1     ¬=  ' ')      /*SYSLIB1*/
25400000           & (SMPLIST(IFILE).CURR_NTRY.SYSLIB2     ¬=  ' '))     /*SYSLIB2*/
25410000          PUT FILE(SMPDCTRY.FILEREF)
25420000              EDIT('SLIB1=',SMPLIST(IFILE).CURR_NTRY.SYSLIB1)  (COL(026),A,A);
25430000
25440000        OTHERWISE;
25450000      END;
25460000   END SMPDCTRY_ENTRY_FILE_STYPE_INFO;
25470000 %PAGE;
25480000 SMPDCTRY_ENTRY_FILE_WRT_INFO:
25490000   PROC;                       /*IFILE IS SET ON ENTRY TO SMPDCTRY_ENTRY_FILE_WRT_INFO */
25500000      PUT FILE(SMPDCTRY.FILEREF)
25510000          EDIT(SUBSTR(SMPSCAN(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);
25520000      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)
25530000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');
25540000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);
25550000
25560000      PUT FILE(SMPDCTRY.FILEREF)
25570000          EDIT(SUBSTR(SMPSOUT(IFILE).DDNAME,004),'PG=')                  (X(2),A,X(1),A);
25580000      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)
25590000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_NTRY.PAGE_NO) (P'Z9999');
25600000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                                 (A);
25610000
25620000      PUT FILE(SMPDCTRY.FILEREF)
25630000          EDIT(SUBSTR(SMPDATA(IFILE).DDNAME,004),'SQ=')                  (X(2),A,X(1),A);
25640000      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)
25650000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_NTRY.SEQ_NO)
25660000                                                                           (P'99999999');
25670000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);
25680000
25690000   END SMPDCTRY_ENTRY_FILE_WRT_INFO;
25700000  %SKIP(3);
25710000   END SMPDCTRY_ENTRY_FILE_INFO;
25720000  %SKIP(3);
25730000   END SMPDCTRY_ENTRY_INFO;
25740000 %PAGE;
25750000 SMPDCTRY_FINAL_INFO:
25760000   PROC;
25770000
25780000            /*-------------------------------------------------------------------------*/
25790000            /* ASSEMBLE TITLE2/3 LINES AND SET UP END-OF-PAGE CONTROL:                 */
25800000            /*-------------------------------------------------------------------------*/
25810000
25820000      SMPDCTRY.CURR_PAGE.NTRYINDX     =  NTRYINDX_MAX + 1;
25830000      SMPDCTRY.CURR_PAGE.TITLE2_DATA  = 'FINAL PROCESSING TOTALS:';
25840000      SMPDCTRY.CURR_PAGE.TITLE3_DATA  =  '  FILE  ';
25850000      SUBSTR(SMPDCTRY.CURR_PAGE.TITLE3_DATA,035)
25860000                                      =  'FINAL TOTALS BY FILE AND ENTRY TYPE:';
25870000
25880000      ON ENDPAGE(SMPDCTRY.FILEREF)        CALL SMPDCTRY_NEWPAGE;
25890000      SIGNAL ENDPAGE(SMPDCTRY.FILEREF);              /*START FINAL TOTALS ON A NEW PAGE*/
25900000
25910000            /*-------------------------------------------------------------------------*/
25920000            /* PRINT FINAL TOTALS AND OTHER INFORMATION FOR SUPPORTED, ACTIVE FILES:   */
25930000            /*-------------------------------------------------------------------------*/
25940000
25950000      DO        IFILE = IFILE_MIN TO IFILE_MAX;               /*FOR EACH SUPPORTED FILE*/
25960000        IF     (SMPLIST(IFILE).ACTIVE)      /*PRODUCE TOTALS FOR EACH ACTIVE INPUT FILE*/
25970000          THEN  CALL  SMPDCTRY_FINAL_FILE_F_T_INFO;
25980000      END;
25990000
26000000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_INFO*/
26010000 %PAGE;
26020000 SMPDCTRY_FINAL_FILE_F_T_INFO:   /*THIS SUBROUTINE IS INTERNAL TO SMPDCTRY_FINAL_INFO  */
26030000   PROC;                         /*IFILE IS SET ON ENTRY TO SMPDCTRY_FINAL_FILE_INFO   */
26040000
26050000      DCL  FILE_LIST_LINE_CT       FIXED BINARY(15,0);
26060000
26070000            /*-------------------------------------------------------------------------*/
26080000            /* BEGIN A NEW PAGE FOR THIS FILE'S TOTALS IF NECESSARY:                   */
26090000            /*-------------------------------------------------------------------------*/
26100000        FILE_LIST_LINE_CT =        01                      /*FIRST FILE LINE*/
26110000                              +    01                      /*SPILL FILE LINE*/
26120000                              +    SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT
26130000                              + 3*(SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND+01);
26140000
26150000        IF         (LINENO(SMPDCTRY.FILEREF) <= (SMPDCTRY.PAGE_SZ -(FILE_LIST_LINE_CT+02)))
26160000            THEN                                 /*IF LISTING WILL FIT ON CURRENT PAGE*/
26170000                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
26180000                 THEN PUT FILE(SMPDCTRY.FILEREF)  SKIP(2);   /*CONTINUE ON CURRENT PAGE*/
26190000                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/
26200000            ELSE                                 /*IF LISTING WON'T FIT ON CURRENT PAGE*/
26210000                IF (LINENO(SMPDCTRY.FILEREF) >  SMPDCTRY.CURR_PAGE.INFO_1STLINE)
26220000                 THEN SIGNAL ENDPAGE(SMPDCTRY.FILEREF);      /*START ON A NEW PAGE     */
26230000                 ELSE PUT FILE(SMPDCTRY.FILEREF)  SKIP(1);   /*CONTINUE ON CURRENT PAGE*/
26240000     %PAGE;
26250000            /*-------------------------------------------------------------------------*/
26260000            /* WRITE OUT STATUS AND CONTROL INFORMATION FOR EACH FILE:                 */
26270000            /*-------------------------------------------------------------------------*/
26280000      PUT FILE(SMPDCTRY.FILEREF)
26290000          EDIT('FILE(',IFILE,'):')                                 (COL(001),A,P'999',A);
26300000      PUT FILE(SMPDCTRY.FILEREF)
26310000          EDIT('LIST  DDNAME=',SMPLIST(IFILE).DDNAME)                     (COL(012),A,A)
26320000              ('HIGHEST PAGE=',SMPLIST(IFILE).CURR_PAGE.PAGE_NO)
26330000                                                              (COL(035),A,X(3),P'Z9999')
26340000              ('TOTAL LINES READ=',SMPLIST(IFILE).FILE_TOTALS.RCRD_CT)
26350000                                                         (COL(058),A,X(2),P'ZZ,ZZZ,ZZ9')
26360000              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT)
26370000                                                              (COL(103),A,P'ZZ,ZZZ,ZZ9');
26380000
26390000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
26400000          EDIT('SPILL DDNAME=',SMPUT(IFILE).DDNAME)                       (COL(012),A,A)
26410000              ('WRITE:')                                                    (COL(035),A)
26420000              ('SAVECT=',SMPUT(IFILE).WRITE.SAVE_CT)                  (X(2),A,P'ZZ,ZZ9')
26430000              ('OPENCT=',SMPUT(IFILE).WRITE.OPEN_CT)                  (X(2),A,P'ZZ,ZZ9')
26440000              ('LINECT=',SMPUT(IFILE).WRITE.LINE_CT)                 (X(2),A,P'ZZZ,ZZ9')
26450000              ('READ:')                                                     (COL(094),A)
26460000              ('OPENCT=',SMPUT(IFILE).READ.OPEN_CT)                   (X(2),A,P'ZZ,ZZ9')
26470000              ('LINECT=',SMPUT(IFILE).READ.LINE_CT)                  (X(2),A,P'ZZZ,ZZ9');
26480000
26490000      IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))          /*IF FILE COULD HAVE HAD OUTPUT*/
26500000        THEN   CALL SMPDCTRY_FINAL_FILE_F_W_INFO;
26510000
26520000
26530000      DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX+1;
26540000        IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)
26550000            | (NTRYINDX_IX  =  NTRYINDX_MAX+1)
26560000          THEN CALL SMPDCTRY_FINAL_FILE_E_T_INFO;
26570000      END;
26580000
26590000      RETURN;                    /*TO THE CALLER OF SMPDCTRY_FINAL_FILE_F_T_INFO*/
26600000 %PAGE;
26610000 SMPDCTRY_FINAL_FILE_F_W_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */
26620000                                        /*SMPDCTRY_FINAL_FILE_F_W_INFO.                  */
26630000   PROC;                                /*IFILE IS SET ON ENTRY.                         */
26640000
26650000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
26660000          EDIT('SCAN  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)
26670000              ('HIGHEST PAGE=')                                             (COL(035),A);
26680000      IF (SMPSCAN(IFILE).ACTIVE  & SMPSCAN(IFILE).OPEN)
26690000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSCAN(IFILE).CURR_PAGE.PAGE_NO)
26700000                                                                          (X(3),P'Z9999');
26710000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);
26720000
26730000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
26740000          EDIT('SOUT  DDNAME=',SMPSOUT(IFILE).DDNAME)                     (COL(012),A,A)
26750000              ('HIGHEST PAGE=')                                             (COL(035),A);
26760000      IF (SMPSOUT(IFILE).ACTIVE  & SMPSOUT(IFILE).OPEN)
26770000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPSOUT(IFILE).CURR_PAGE.PAGE_NO)
26780000                                                                          (X(3),P'Z9999');
26790000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('-----')                            (X(3),A);
26800000
26810000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
26820000          EDIT('DATA  DDNAME=',SMPSCAN(IFILE).DDNAME)                     (COL(012),A,A)
26830000              ('HIGHEST SEQ#=')                                             (COL(035),A);
26840000      IF (SMPDATA(IFILE).ACTIVE  & SMPDATA(IFILE).OPEN)
26850000        THEN PUT FILE(SMPDCTRY.FILEREF) EDIT(SMPDATA(IFILE).CURR_CARD.SEQ_NO)  (P'(8)9');
26860000        ELSE PUT FILE(SMPDCTRY.FILEREF) EDIT('--------')                             (A);
26870000
26880000   END SMPDCTRY_FINAL_FILE_F_W_INFO;
26890000 %PAGE;
26900000 SMPDCTRY_FINAL_FILE_E_T_INFO:          /*THIS SUBROUTINE IS INTERNAL TO                 */
26910000                                        /*SMPDCTRY_FINAL_FILE_F_T_INFO.                  */
26920000   PROC;                                /*IFILE AND NTRYINDX_IX ARE SET ON ENTRY.        */
26930000
26940000      SELECT;                   /*SELECT LINE HEADING FOR ENTRY_INDEX*/
26950000         WHEN(NTRYINDX_IX <= NTRYINDX_MAX)
26960000             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)
26970000                 EDIT(ENTRY_TYPE(NTRYINDX_IX),'ENTRIES:')            (COL(012),A,X(1),A);
26980000         WHEN(NTRYINDX_IX  = NTRYINDX_MAX+1)
26990000             PUT FILE(SMPDCTRY.FILEREF)               SKIP(1)
27000000                 EDIT('ALL ENTRY TYPES:')                                   (COL(012),A);
27010000         OTHERWISE;
27020000      END;
27030000
27040000      PUT FILE(SMPDCTRY.FILEREF)
27050000          EDIT('INPUT TOTALS:')                                            (COL(035),A)
27060000              ('FIRST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO)
27070000                                                             (COL(058),A,X(2),P'Z9999')
27080000              ('LAST PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI)
27090000                                                             (COL(081),A,X(2),P'Z9999')
27100000              ('ENTRY LINES READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT)
27110000                                                             (COL(103),A,P'ZZ,ZZZ,ZZ9');
27120000
27130000      PUT FILE(SMPDCTRY.FILEREF)                       SKIP(1)
27140000          EDIT('ENTRY TOTALS:')                                             (COL(035),A)
27150000              ('READ=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT)
27160000                                                                 (COL(058),A,P'ZZZ,ZZ9')
27170000              ('SELECTED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).SELECT_CT)
27180000                                                                 (COL(075),A,P'ZZZ,ZZ9')
27190000              ('MATCHED=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT)
27200000                                                                 (COL(096),A,P'ZZZ,ZZ9')
27210000              ('WRITTEN=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).WRITE_CT)
27220000                                                                 (COL(115),A,P'ZZZ,ZZ9');
27230000      PUT FILE(SMPDCTRY.FILEREF)                      SKIP(1)
27240000          EDIT('LARGEST ENTRY:')                                            (COL(035),A)
27250000              ('NAME=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME)  (COL(058),A,A)
27260000              ('LINECT=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)
27270000                                                                 (COL(077),A,P'ZZZ,ZZ9')
27280000              ('PAGE=',SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE)
27290000                                                              (COL(099),A,X(2),P'Z9999');
27300000   END SMPDCTRY_FINAL_FILE_E_T_INFO;
27310000  %SKIP(1);
27320000   END SMPDCTRY_FINAL_FILE_F_T_INFO;
27330000  %SKIP(2);
27340000   END SMPDCTRY_FINAL_INFO;
27350000 %PAGE;
27360000 CONTROL_VALUE_INPUT:
27370000   PROC;
27380000    /******************************************************************/
27390000    /*   ALLOCATE EXECUTION CONTROL VARIABLE STRUCTURES               */
27400000    /******************************************************************/
27410000      ALLOCATE   FILE_ACTIVE_OPTION;
27420000      ALLOCATE   MATCH_ARRAY;
27430000      ALLOCATE   SCAN_ARRAY;
27440000      ALLOCATE   DATA_OUTPUT_OPTION;
27450000    /******************************************************************/
27460000    /*   INITIALIZE EXECUTION CONTROL VARIABLE VALUES                 */
27470000    /******************************************************************/
27480000      DO IFILE = IFILE_MIN TO IFILE_MAX;
27490000              FILE_ACTIVE_OPTION(IFILE)              = '';
27500000              DATA_OUTPUT_OPTION(IFILE)              = '';
27510000              SCAN_ARRAY.FILE(IFILE).SELECT_OPTION   = '';
27520000
27530000        DO IPLANE = IPLANE_MIN TO IPLANE_MAX;
27540000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION   = '';
27550000
27560000          DO IROW = IROW_MIN TO IROW_MAX;
27570000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION   = '';
27580000
27590000            DO ICOL = ICOL_MIN TO ICOL_MAX;
27600000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).BEG_POS  =
27610000                                                                  LIST_LINE_DBGN - 001;
27620000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).END_POS  =
27630000                                                                  LIST_LINE_DEND + 001;
27640000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).POS_LEN  =  000;
27650000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP       = '';
27660000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).OP_OIX   =  000;
27670000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STRING   = '';
27680000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_LEN  =  000;
27690000              SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL).STR_NIX  =
27700000                                                                        NTRYINDX_MIN-1;
27710000            END;           /*END OF ICOL   DO GROUP*/
27720000
27730000          END;             /*END OF IROW   DO GROUP*/
27740000        END;               /*END OF IPLANE DO GROUP*/
27750000      END;                 /*END OF IFILE  DO GROUP*/
27760000
27770000      DO IMATCH = IMATCH_MIN TO IMATCH_MAX;
27780000              MATCH_ARRAY.ENTRY(IMATCH).TYPE         = '';
27790000              MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST = '';
27800000        DO IFILE = IFILE_MIN TO IFILE_MAX;
27810000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = '';
27820000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = '';
27830000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = '';
27840000              MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = '';
27850000        END;               /*END OF IFILE  DO GROUP*/
27860000      END;                 /*END OF IMATCH DO GROUP*/
27870000   %PAGE;
27880000    /******************************************************************/
27890000    /*   READ EXECUTION CONTROL VARIABLE VALUES                       */
27900000    /******************************************************************/
27910000      OPEN  FILE(SYSIN);                                  /*READ THE SEARCH ARGUMENTS */
27920000      SYSIN_EOF = '0'B;
27930000      ON ENDFILE(SYSIN)
27940000         BEGIN;
27950000              SYSIN_EOF = '1'B;     /*SIGNAL END OF FILE ON INPUT*/
27960000              SYSIN_CONTROL_CARD = REPEAT(SEMI_C,079);
27970000         END;
27980000
27990000         /*READ THE EXECUTION CONTROL VARIABLES FROM "SYSIN"*/
28000000      READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);      /*READ THE FIRST CONTOL CARD IMAGE*/
28010000      DO WHILE(¬(SYSIN_EOF));
28020000         IF SUBSTR(SYSIN_CONTROL_CARD,001,001) ¬= '*'  /*COMMENT RECORD  */
28030000           THEN
28040000                GET STRING(SUBSTR(SYSIN_CONTROL_CARD,001,072) || SEMI_C)
28050000                    DATA(
28060000                         FILE_ACTIVE_OPTION,
28070000
28080000                         MATCH_ARRAY,
28090000
28100000                         SCAN_ARRAY.FILE.SELECT_OPTION,
28110000                         SCAN_ARRAY.FILE.PLANE.SELECT_OPTION,
28120000                         SCAN_ARRAY.FILE.PLANE.ROW.SELECT_OPTION,
28130000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.BEG_POS,
28140000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.END_POS,
28150000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.POS_LEN,
28160000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.OP,
28170000                         SCAN_ARRAY.FILE.PLANE.ROW.COL.STRING,
28180000
28190000                         DATA_OUTPUT_OPTION
28200000                        );
28210000         READ FILE(SYSIN) INTO(SYSIN_CONTROL_CARD);   /*READ THE NEXT CONTROL CARD IMAGE*/
28220000      END;
28230000      CLOSE FILE(SYSIN);
28240000   %SKIP(2);
28250000    /******************************************************************/
28260000    /*   VALIDATE EXECUTION CONTROL VARIABLE VALUES                   */
28270000    /******************************************************************/
28280000      DO IFILE = IFILE_MIN TO IFILE_MAX;
28290000        FILE_ACTIVE_OPTION(IFILE)
28300000               = VALIDATE_FILE_ACTIVE_OPTION(FILE_ACTIVE_OPTION(IFILE));
28310000        DATA_OUTPUT_OPTION(IFILE) = VALIDATE_DATA_OUTPUT_OPTION(DATA_OUTPUT_OPTION(IFILE));
28320000        CALL VALIDATE_SCAN_ARRAY;
28330000      END;
28340000      CALL VALIDATE_MATCH_ARRAY;
28350000      RETURN;          /*TO THE CALLER OF CONTROL_VALUE_INPUT*/
28360000 %PAGE;
28370000  VALIDATE_MATCH_ARRAY:
28380000  /**************************************************/
28390000  /*VALIDATE THE MATCH_ARRAY INPUT VALUES           */
28400000  /**************************************************/
28410000  PROC;
28420000
28430000     DO IMATCH = IMATCH_MIN TO IMATCH_MAX;
28440000
28450000       MATCH_ARRAY.ENTRY(IMATCH).TYPE
28460000               = VALIDATE_MATCH_TYPE_OPTION(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
28470000
28480000       MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST
28490000               = VALIDATE_MATCH_TEST_OPTION(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);
28500000
28510000       DO IFILE = IFILE_MIN TO IFILE_MAX;
28520000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION
28530000                = VALIDATE_MATCH_COMPARE_OPTION
28540000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION);
28550000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT
28560000                = VALIDATE_MATCH_SELECT_OPTION
28570000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT);
28580000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION
28590000                = VALIDATE_MATCH_WRITE_OPTION
28600000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION);
28610000         MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT
28620000                = VALIDATE_MATCH_SELECT_OPTION
28630000                         (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT);
28640000       END;             /*END OF IFILE  DO GROUP*/
28650000
28660000     END;               /*END OF IMATCH DO GROUP*/
28670000  END   VALIDATE_MATCH_ARRAY;
28680000 %PAGE;
28690000  VALIDATE_SCAN_ARRAY:           /**************************************************/
28700000                                 /*VALIDATE THE SCAN_ARRAY INPUT VALUES            */
28710000                                 /**************************************************/
28720000  PROC;                              /*IFILE IS SET ON ENTRY TO VALIDATE_SCAN_ARRAY*/
28730000
28740000     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
28750000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL;
28760000
28770000     SCAN_ARRAY.FILE(IFILE).SELECT_OPTION
28780000               = VALIDATE_SCAN_SELECT_OPTION
28790000                         (SCAN_ARRAY.FILE(IFILE).SELECT_OPTION);
28800000
28810000     DO IPLANE = IPLANE_MIN TO IPLANE_MAX;
28820000       SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION
28830000               = VALIDATE_SCAN_SELECT_OPTION
28840000                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION);
28850000
28860000       DO IROW = IROW_MIN TO IROW_MAX;
28870000         SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION
28880000               = VALIDATE_SCAN_SELECT_OPTION
28890000                         (SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION);
28900000
28910000         DO ICOL = ICOL_MIN TO ICOL_MAX;
28920000           SCAN_ARRAY_ELEMENT_ADDR
28930000                 =  ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
28940000           IF  LENGTH(SCAN_ARRAY_ELEMENT.STRING) <= 0
28950000             THEN   CALL RESET_ARRAY_ELEMENT;  /*RESET ELEMENT IF NO STRING*/
28960000             ELSE DO;               /*A STRING VALUE HAS BEEN SPECIFIED*/
28970000                    CALL VALIDATE_POSITION_BOUNDS;
28980000                    CALL SET_OP_POSITION_BOUNDS;
28990000                    CALL RESET_STRING_SIZE;
29000000                  END;     /*END OF ICOL ACTIVE ELEMENT DO GROUP*/
29010000         END;              /*END OF ICOL   DO GROUP*/
29020000
29030000       END;                /*END OF IROW   DO GROUP*/
29040000     END;                  /*END OF IPLANE DO GROUP*/
29050000  RETURN;           /*TO THE CALLER OF VALIDATE_SCAN_ARRAY*/
29060000 %PAGE;
29070000  VALIDATE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
29080000                            /*TO INITIALIZE ANY UNSUPPLIED FIELDS,                */
29090000                            /*VALIDATE THE BEGINNING AND ENDING COLUMN            */
29100000                            /*SPECIFICATIONS, AND FORCE THE BEGIN COLUMN VALUE    */
29110000                            /*TO BE <= THE ENDING COLUMN VALUE:                   */
29120000    PROC;
29130000       DCL  SAVE_POS                   FIXED BIN(15,0);
29140000       SCAN_ARRAY_ELEMENT.STR_LEN
29150000                   =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);
29160000
29170000       IF     SCAN_ARRAY_ELEMENT.BEG_POS
29180000           >  SCAN_ARRAY_ELEMENT.END_POS
29190000         THEN CALL SWAP_POSITION_BOUNDS;
29200000
29210000       IF    (SCAN_ARRAY_ELEMENT.POS_LEN > 000)                             /*IF SUPPLIED*/
29220000           & (SCAN_ARRAY_ELEMENT.BEG_POS >= LIST_LINE_DBGN)                 /*IF SUPPLIED*/
29230000           & (SCAN_ARRAY_ELEMENT.BEG_POS <= LIST_LINE_DEND)                  /*AND VALID */
29240000           & (SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND)               /*IF NOTSUPPLIED*/
29250000         THEN SCAN_ARRAY_ELEMENT.END_POS
29260000                         =    SCAN_ARRAY_ELEMENT.BEG_POS
29270000                            + SCAN_ARRAY_ELEMENT.POS_LEN - 1;
29280000
29290000       IF     SCAN_ARRAY_ELEMENT.BEG_POS
29300000           >  SCAN_ARRAY_ELEMENT.END_POS
29310000         THEN CALL SWAP_POSITION_BOUNDS;
29320000
29330000       RETURN;
29340000      %SKIP(3);
29350000       SWAP_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_POSITION_BOUNDS"   */
29360000                             /*TO SWAP THE BEGINNING AND ENDING COLUMN             */
29370000         PROC;               /*SPECIFICATIONS:                                     */
29380000            DCL  SAVE_POS                   FIXED BIN(15,0);
29390000            SAVE_POS                    =  SCAN_ARRAY_ELEMENT.BEG_POS;
29400000            SCAN_ARRAY_ELEMENT.BEG_POS  =  SCAN_ARRAY_ELEMENT.END_POS;
29410000            SCAN_ARRAY_ELEMENT.END_POS  =  SAVE_POS;
29420000         END SWAP_POSITION_BOUNDS;
29430000    END VALIDATE_POSITION_BOUNDS;
29440000 %PAGE;
29450000  SET_OP_POSITION_BOUNDS:   /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
29460000                            /*TO VALIDATE AND SET THE ENDING POSITION             */
29470000                            /*IN SCAN_ARRAY BASED ON THE TYPE OF SCAN OPERATION:  */
29480000    PROC;
29490000       SCAN_ARRAY_ELEMENT.OP = TRIM(SCAN_ARRAY_ELEMENT.OP);
29500000       SELECT(SCAN_ARRAY_ELEMENT.OP);
29510000         WHEN('EQENTRY','EQNTRY','EQN')              CALL SET_NTRY_POSITION_BOUNDS(12);
29520000         WHEN('NEENTRY','NENTRY','NEN')              CALL SET_NTRY_POSITION_BOUNDS(13);
29530000         WHEN('¬EQENTRY','¬EQNTRY','¬EQN')           CALL SET_NTRY_POSITION_BOUNDS(13);
29540000
29550000         WHEN('EQLINE','EQLIN','EQL')                CALL SET_LINE_POSITION_BOUNDS(22);
29560000         WHEN('NELINE','NELIN','NEL')                CALL SET_LINE_POSITION_BOUNDS(23);
29570000         WHEN('¬EQLINE','¬EQLIN','¬EQL')             CALL SET_LINE_POSITION_BOUNDS(23);
29580000
29590000         WHEN('EQGLINE','EQGLIN','EQGL')             CALL SET_GLIN_POSITION_BOUNDS(32);
29600000         WHEN('NEGLINE','NEGLIN','NEGL')             CALL SET_GLIN_POSITION_BOUNDS(33);
29610000         WHEN('¬EQGLINE','¬EQGLIN','¬EQGL')          CALL SET_GLIN_POSITION_BOUNDS(33);
29620000
29630000         WHEN('EQSCAN','EQSCN','EQS')                CALL SET_SCAN_POSITION_BOUNDS(42);
29640000         WHEN('NESCAN','NESCN','NES')                CALL SET_SCAN_POSITION_BOUNDS(43);
29650000         WHEN('¬EQSCAN','¬EQSCN','¬EQS')             CALL SET_SCAN_POSITION_BOUNDS(43);
29660000
29670000         WHEN('EQGSCAN','EQGSCN','EQGS')             CALL SET_GSCN_POSITION_BOUNDS(52);
29680000         WHEN('NEGSCAN','NEGSCN','NEGS')             CALL SET_GSCN_POSITION_BOUNDS(53);
29690000         WHEN('¬EQGSCAN','¬EQGSCN','¬EQGS')          CALL SET_GSCN_POSITION_BOUNDS(53);
29700000
29710000         WHEN('LTCMPR','LTCPR','LTC','LT')           CALL SET_CMPR_POSITION_BOUNDS(60);
29720000         WHEN('¬GECMPR','¬GECPR','¬GEC','¬GE')       CALL SET_CMPR_POSITION_BOUNDS(60);
29730000         WHEN('LECMPR','LECPR','LEC','LE')           CALL SET_CMPR_POSITION_BOUNDS(61);
29740000         WHEN('¬GTCMPR','¬GTCPR','¬GTC','¬GT')       CALL SET_CMPR_POSITION_BOUNDS(61);
29750000         WHEN('EQCMPR','EQCPR','EQC','EQ')           CALL SET_CMPR_POSITION_BOUNDS(62);
29760000         WHEN('NECMPR','NECPR','NEC','NE')           CALL SET_CMPR_POSITION_BOUNDS(63);
29770000         WHEN('¬EQCMPR','¬EQCPR','¬EQC','¬EQ')       CALL SET_CMPR_POSITION_BOUNDS(63);
29780000         WHEN('GECMPR','GECPR','GEC','GE')           CALL SET_CMPR_POSITION_BOUNDS(64);
29790000         WHEN('¬LTCMPR','¬LTCPR','¬LTC','¬LT')       CALL SET_CMPR_POSITION_BOUNDS(64);
29800000         WHEN('GTCMPR','GTCPR','GTC','GT')           CALL SET_CMPR_POSITION_BOUNDS(65);
29810000         WHEN('¬LECMPR','¬LTCPR','¬LTC','¬LT')       CALL SET_CMPR_POSITION_BOUNDS(65);
29820000
29830000         WHEN('EQGCMPR','EQGCPR','EQGC','EQG')       CALL SET_GCPR_POSITION_BOUNDS(72);
29840000         WHEN('NEGCMPR','NEGCPR','NEGC','NEG')       CALL SET_GCPR_POSITION_BOUNDS(73);
29850000         WHEN('¬EQGCMPR','¬EQGCPR','¬EQGC','¬EQG')   CALL SET_GCPR_POSITION_BOUNDS(73);
29860000
29870000         OTHERWISE
29880000           DO;
29890000               SCAN_ARRAY_ELEMENT.OP = 'EQSCAN';
29900000               CALL                              SET_SCAN_POSITION_BOUNDS(42);
29910000           END;
29920000       END;   /*END OF SCAN_ARRAY.OP   SELECT GROUP*/
29930000
29940000       RETURN;
29950000 %PAGE;
29960000  SET_NTRY_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
29970000                            /*TO VALIDATE AND SET THE ENDING POSITION             */
29980000                            /*IN SCAN_ARRAY FOR ENTRY TYPE COMPARE OPERATIONS:    */
29990000    PROC(OIX);
30000000       DCL  OIX                       FIXED BIN(15,0);
30010000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
30020000       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_DBGN;
30030000       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_DEND;
30040000       SCAN_ARRAY_ELEMENT.STR_NIX  =  ENTRY_INDEX(SCAN_ARRAY_ELEMENT.STRING);
30050000    END SET_NTRY_POSITION_BOUNDS;
30060000 %SKIP(3);
30070000  SET_LINE_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
30080000  SET_GLIN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */
30090000                            /*IN SCAN_ARRAY FOR LINE TYPE COMPARE OPERATIONS:     */
30100000    PROC(OIX);
30110000       DCL  OIX                       FIXED BIN(15,0);
30120000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
30130000       SCAN_ARRAY_ELEMENT.BEG_POS  =  LIST_LINE_LBGN;
30140000       SCAN_ARRAY_ELEMENT.END_POS  =  LIST_LINE_LEND;
30150000    END SET_LINE_POSITION_BOUNDS;
30160000 %PAGE;
30170000  SET_SCAN_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
30180000  SET_GSCN_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING COLUMN               */
30190000                            /*IN SCAN_ARRAY FOR LINE CONTENTS SCAN OPERATIONS:    */
30200000    PROC(OIX);
30210000       DCL  OIX                       FIXED BIN(15,0);
30220000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
30230000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
30240000           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
30250000         THEN
30260000           DO;
30270000              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;
30280000              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
30290000           END;
30300000       SCAN_ARRAY_ELEMENT.END_POS
30310000           = MIN(LIST_LINE_DEND,
30320000                 MAX( SCAN_ARRAY_ELEMENT.END_POS,
30330000                     (SCAN_ARRAY_ELEMENT.BEG_POS +
30340000                      SCAN_ARRAY_ELEMENT.STR_LEN - 1)));
30350000    END SET_SCAN_POSITION_BOUNDS;
30360000 %SKIP(3);
30370000  SET_CMPR_POSITION_BOUNDS: /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
30380000  SET_GCPR_POSITION_BOUNDS: /*TO VALIDATE AND SET THE ENDING POSITION             */
30390000                            /*IN SCAN_ARRAY FOR LINE CONTENTS COMPARE OPERATIONS: */
30400000    PROC(OIX);
30410000       DCL  OIX                       FIXED BIN(15,0);
30420000       SCAN_ARRAY_ELEMENT.OP_OIX   =  OIX;
30430000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
30440000           &  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
30450000         THEN
30460000           DO;
30470000              SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_SBGN;
30480000              SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
30490000           END;
30500000       SCAN_ARRAY_ELEMENT.END_POS
30510000         = MIN(LIST_LINE_DEND,
30520000               (SCAN_ARRAY_ELEMENT.BEG_POS +
30530000                SCAN_ARRAY_ELEMENT.STR_LEN - 1));
30540000    END SET_CMPR_POSITION_BOUNDS;
30550000   %SKIP(2);
30560000    END SET_OP_POSITION_BOUNDS;
30570000 %PAGE;
30580000  RESET_STRING_SIZE:        /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
30590000                      /*TO LIMIT THE SIZE OF THE SEARCH STRING TO                 */
30600000                      /*THE EXTENT OF THE  BEGIN AND END LINE POSTITIONS:         */
30610000    PROC;
30620000       IF     SCAN_ARRAY_ELEMENT.BEG_POS < LIST_LINE_DBGN
30630000           |  SCAN_ARRAY_ELEMENT.BEG_POS > LIST_LINE_DEND
30640000         THEN SCAN_ARRAY_ELEMENT.BEG_POS = LIST_LINE_DBGN;
30650000
30660000       IF     SCAN_ARRAY_ELEMENT.END_POS < LIST_LINE_DBGN
30670000           |  SCAN_ARRAY_ELEMENT.END_POS > LIST_LINE_DEND
30680000         THEN SCAN_ARRAY_ELEMENT.END_POS = LIST_LINE_DEND;
30690000
30700000       SCAN_ARRAY_ELEMENT.POS_LEN        =    SCAN_ARRAY_ELEMENT.END_POS
30710000                                            - SCAN_ARRAY_ELEMENT.BEG_POS + 1;
30720000
30730000       IF         SCAN_ARRAY_ELEMENT.POS_LEN
30740000               <  SCAN_ARRAY_ELEMENT.STR_LEN
30750000
30760000         THEN     SCAN_ARRAY_ELEMENT.STRING
30770000               =
30780000           SUBSTR(SCAN_ARRAY_ELEMENT.STRING,
30790000                  1,
30800000                  SCAN_ARRAY_ELEMENT.POS_LEN);
30810000
30820000       SCAN_ARRAY_ELEMENT.STR_LEN        =  LENGTH(SCAN_ARRAY_ELEMENT.STRING);
30830000
30840000    END RESET_STRING_SIZE;
30850000 %SKIP(3);
30860000  RESET_ARRAY_ELEMENT:      /*INTERNAL SUBROUTINE OF "VALIDATE_SCAN_ARRAY"        */
30870000                            /*TO RESET THE VALUES IN A SCAN_ARRAY ELEMENT         */
30880000                            /*WHEN THE STRING PROVIDED IS EMPTY OR NULL:          */
30890000    PROC;
30900000       SCAN_ARRAY_ELEMENT.BEG_POS  =  000;
30910000       SCAN_ARRAY_ELEMENT.END_POS  =  000;
30920000       SCAN_ARRAY_ELEMENT.POS_LEN  =  000;
30930000       SCAN_ARRAY_ELEMENT.OP       =  '';
30940000       SCAN_ARRAY_ELEMENT.OP_OIX   =  000;
30950000       SCAN_ARRAY_ELEMENT.STRING   =  '';
30960000       SCAN_ARRAY_ELEMENT.STR_LEN  =  000;
30970000       SCAN_ARRAY_ELEMENT.STR_NIX  =  NTRYINDX_MIN-1;
30980000    END RESET_ARRAY_ELEMENT;
30990000 %SKIP(3);
31000000  END VALIDATE_SCAN_ARRAY;
31010000 %PAGE;
31020000  VALIDATE_MATCH_TYPE_OPTION:
31030000  PROC(ENT_TYP)                   RETURNS(CHAR(016) VARYING);
31040000     DCL    ENT_TYP               CHAR(*) VARYING;
31050000     SELECT(TRIM(ENT_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31060000        WHEN('')                                      RETURN('NONE');
31070000        WHEN('ALL','A')                               RETURN('ALL');
31080000        WHEN('NONE','NO','N')                         RETURN('NONE');
31090000        OTHERWISE           RETURN(ENTRY_TYPE(ENTRY_INDEX(ENT_TYP)));
31100000     END;
31110000  END VALIDATE_MATCH_TYPE_OPTION; /*IN CONTROL_VALUE_INPUT*/
31120000 %SKIP(2);
31130000  VALIDATE_MATCH_TEST_OPTION:
31140000  PROC(TST_TYP)                   RETURNS(CHAR(008) VARYING);
31150000     DCL    TST_TYP               CHAR(*) VARYING;
31160000     SELECT(TRIM(TST_TYP));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31170000        WHEN('')                                      RETURN('ALL');
31180000        WHEN('ALL','AND','A','N')                     RETURN('ALL');
31190000        WHEN('ANY','OR','O')                          RETURN('ANY');
31200000        OTHERWISE                                     RETURN('ALL');
31210000     END;
31220000  END VALIDATE_MATCH_TEST_OPTION; /*IN CONTROL_VALUE_INPUT*/
31230000 %PAGE;
31240000  VALIDATE_MATCH_COMPARE_OPTION:
31250000  PROC(CPR_OPT)                   RETURNS(CHAR(012) VARYING);
31260000     DCL    CPR_OPT               CHAR(*) VARYING;
31270000     SELECT(TRIM(CPR_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31280000        WHEN('')                                      RETURN('IFCOMPARE');
31290000        WHEN('NOCOMPARE','NOCMPR','NOCPR','NOC')      RETURN('NOCOMPARE');
31300000        WHEN('COMPARE','CMPR','CPR','C')              RETURN('COMPARE');
31310000        WHEN('IFCOMPARE','IFCMPR','IFCPR','IFC')      RETURN('IFCOMPARE');
31320000        WHEN('IGCOMPARE','IGCMPR','IGCPR','IGC')      RETURN('IFCOMPARE');
31330000        WHEN('IGNORE','IGNR','IG')                    RETURN('IFCOMPARE');
31340000        OTHERWISE                                     RETURN('IFCOMPARE');
31350000     END;
31360000  END VALIDATE_MATCH_COMPARE_OPTION; /*IN CONTROL_VALUE_INPUT*/
31370000 %SKIP(2);
31380000  VALIDATE_MATCH_SELECT_OPTION:
31390000  PROC(SEL_OPT)                   RETURNS(CHAR(012) VARYING);
31400000     DCL    SEL_OPT               CHAR(*) VARYING;
31410000     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31420000        WHEN('')                                      RETURN('IGNORE');
31430000        WHEN('NOSELECT','NOSEL','NOS')                RETURN('NOSELECT');
31440000        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('NOSELECT');
31450000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
31460000        WHEN('IFSELECT','IFSEL','IFS')                RETURN('IGNORE');
31470000        WHEN('IGSELECT','IGSEL','IGS')                RETURN('IGNORE');
31480000        WHEN('IGNORE','IGNR','IG')                    RETURN('IGNORE');
31490000        OTHERWISE                                     RETURN('IGNORE');
31500000     END;
31510000  END VALIDATE_MATCH_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/
31520000 %SKIP(2);
31530000  VALIDATE_MATCH_WRITE_OPTION:
31540000  PROC(WRT_OPT)                   RETURNS(CHAR(012) VARYING);
31550000     DCL    WRT_OPT               CHAR(*) VARYING;
31560000     SELECT(TRIM(WRT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31570000        WHEN('')                                      RETURN('WRITE');
31580000        WHEN('NOWRITE','NOWRT','NOWR','NOW')          RETURN('NOWRITE');
31590000        WHEN('WRITE','WRT','WR','W')                  RETURN('WRITE');
31600000        OTHERWISE                                     RETURN('WRITE');
31610000     END;
31620000  END VALIDATE_MATCH_WRITE_OPTION; /*IN CONTROL_VALUE_INPUT*/
31630000 %PAGE;
31640000  VALIDATE_FILE_ACTIVE_OPTION:
31650000  PROC(ACT_OPT)                   RETURNS(CHAR(008) VARYING);
31660000     DCL    ACT_OPT               CHAR(*) VARYING;
31670000     SELECT(TRIM(ACT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31680000        WHEN('')                                      RETURN('INACTIVE');
31690000        WHEN('INACTIVE','INACT','NO','N','OFF')       RETURN('INACTIVE');
31700000        WHEN('ACTIVE','ACT','A','YES','Y','ON')       RETURN('ACTIVE');
31710000        OTHERWISE                                     RETURN('INACTIVE');
31720000     END;
31730000  END VALIDATE_FILE_ACTIVE_OPTION; /*IN CONTROL_VALUE_INPUT*/
31740000 %SKIP(2);
31750000  VALIDATE_SCAN_SELECT_OPTION:
31760000  PROC(SEL_OPT)                   RETURNS(CHAR(008) VARYING);
31770000     DCL    SEL_OPT               CHAR(*) VARYING;
31780000     SELECT(TRIM(SEL_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31790000        WHEN('')                                      RETURN('SELECT');
31800000        WHEN('EXCLUDE','EXCL','EXC','EX','E','X')     RETURN('EXCLUDE');
31810000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
31820000        OTHERWISE                                     RETURN('SELECT');
31830000     END;
31840000  END VALIDATE_SCAN_SELECT_OPTION; /*IN CONTROL_VALUE_INPUT*/
31850000 %SKIP(2);
31860000  VALIDATE_DATA_OUTPUT_OPTION:
31870000  PROC(OUT_OPT)                   RETURNS(CHAR(008) VARYING);
31880000     DCL    OUT_OPT               CHAR(*) VARYING;
31890000     SELECT(TRIM(OUT_OPT));     /*EVALUATE OPTION AND STANDARDIZE IT*/
31900000        WHEN('')                                      RETURN('NONE');
31910000        WHEN('NONE')                                  RETURN('NONE');
31920000        WHEN('ALL')                                   RETURN('ALL');
31930000        WHEN('ID')                                    RETURN('ID');
31940000        WHEN('ID1')                                   RETURN('ID1');
31950000        WHEN('SELECT','SEL','S')                      RETURN('SELECT');
31960000        OTHERWISE                                     RETURN('ID1');
31970000     END;
31980000  END VALIDATE_DATA_OUTPUT_OPTION; /*IN CONTROL_VALUE_INPUT*/
31990000 %SKIP(3);
32000000  END CONTROL_VALUE_INPUT;
32010000 %PAGE;
32020000 SMPLIST_OPEN:             /*************************************************************/
32030000                           /*                                                           */
32040000                           /*   INITIALIZE THE SMPLIST FILE MANAGEMENT ARRAY,           */
32050000                           /*   AND OPEN THE SMPLIST DATA SET(S).                       */
32060000                           /*                                                           */
32070000  PROC;                    /*************************************************************/
32080000     ALLOCATE     SMPLIST_CNTL,SMPLIST;            /*ALLOCATE INPUT  FILE STRUCTURES*/
32090000     ALLOCATE     SMPUT,SMPSCAN,SMPSOUT,SMPDATA;   /*ALLOCATE OUTPUT FILE STRUCTURES*/
32100000
32110000     CALL SMPLIST_CNTL_A_STAT_INIT;                /*INITIALIZE A_STAT  SUBSTRUCTURE*/
32120000     CALL SMPLIST_CNTL_E_CMPR_INIT;                /*INITIALIZE E_CMPR  SUBSTRUCTURE*/
32130000     CALL SMPLIST_CNTL_A_MATCH_INIT;               /*INITIALIZE A_MATCH SUBSTRUCTURE*/
32140000
32150000     DO    IFILE = IFILE_MIN TO IFILE_MAX;
32160000       CALL  SMPLIST_INIT;                   /*INITIALIZE SMPLIST(IFILE) MAJOR STRUCTURE*/
32170000       CALL  SMPUT_INIT;                     /*INITIALIZE SMPUT(IFILE)   MAJOR STRUCTURE*/
32180000       CALL  SMPSCAN_INIT;                   /*INITIALIZE SMPSCAN(IFILE) MAJOR STRUCTURE*/
32190000       CALL  SMPSOUT_INIT;                   /*INITIALIZE SMPSOUT(IFILE) MAJOR STRUCTURE*/
32200000       CALL  SMPDATA_INIT;                   /*INITIALIZE SMPDATA(IFILE) MAJOR STRUCTURE*/
32210000       IF FILE_ACTIVE_OPTION(IFILE) = 'ACTIVE'
32220000         THEN DO;                            /*IF THE FILE IS TO BE PROCESSED*/
32230000                 SMPLIST(IFILE).ACTIVE = '1'B;      /*INDICATE FILE ACTIVE*/
32240000                 CALL SMPLIST_SCAN_CUBE_BUILD;
32250000                 OPEN  FILE(SMPLIST(IFILE).FILEREF) INPUT
32260000                       TITLE(SMPLIST(IFILE).DDNAME);
32270000               END;
32280000         ELSE DO;                            /*IF THE FILE IS NOT TO BE PROCESSED*/
32290000                 CALL      SMPLIST_CURR_PAGE_EOF;   /*SIMULATE IMMEDIATE END-OF-FILE*/
32300000                 SMPLIST(IFILE).CURR_NTRY  =  SMPLIST(IFILE).CURR_PAGE,  BY NAME;
32310000              END;
32320000     END;
32330000
32340000     CALL  SMPLIST_CNTL_A_MATCH_BUILD;          /*BUILD SMPLIST_CNTL.A_MATCH SUBSTRUCTURE*/
32350000
32360000     DO    IFILE = IFILE_MIN TO IFILE_MAX;    /*READ FIRST LINES FOR ACTIVE SMPLIST FILES*/
32370000       IF (SMPLIST(IFILE).ACTIVE)                    /*IF FILE IS ACTIVE,                */
32380000         THEN
32390000           DO;
32400000             CALL SMPLIST_ENTRY_LINE_READ;                   /*READ 1ST LINE OF 1ST ENTRY*/
32410000             IF  (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))      /*IF A CANDIDATE FOR OUTPUT,*/
32420000               THEN DO;
32430000                       CALL SMPSCAN_ACTIVATE;                 /*ACTIVATE SCAN OUTPUT FILE*/
32440000                       CALL SMPSOUT_ACTIVATE;                 /*ACTIVATE LIST OUTPUT FILE*/
32450000                       CALL SMPDATA_ACTIVATE;                 /*ACTIVATE DATA OUTPUT FILE*/
32460000                    END;
32470000             SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = SMPLIST(IFILE).ACTIVE;/*FLAG 1ST READ*/
32480000           END;
32490000     END;
32500000
32510000     CALL  SMPLIST_CNTL_A_STAT_BUILD;           /*BUILD SMPLIST_CNTL.A_STAT  SUBSTRUCTURE*/
32520000
32530000     RETURN;                      /*TO THE CALLER OF SMPLIST_OPEN*/
32540000 %PAGE;
32550000  SMPLIST_CNTL_A_STAT_INIT:       /**************************************************/
32560000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
32570000                                  /*IT INITIALIZES VARIABLES IN THE A_STAT          */
32580000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
32590000  PROC;                           /**************************************************/
32600000     SMPLIST_CNTL.A_STAT.#_F_ACTIVE = 0;
32610000  END  SMPLIST_CNTL_A_STAT_INIT;
32620000 %SKIP(3);
32630000  SMPLIST_CNTL_A_STAT_BUILD:      /**************************************************/
32640000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
32650000                                  /*IT CALCULATES VALUES TO BE PLACED IN THE A_STAT */
32660000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
32670000  PROC;                           /**************************************************/
32680000     DO    IFILE = IFILE_MIN TO IFILE_MAX;
32690000       IF    SMPLIST(IFILE).ACTIVE                           /*PROCESS ONLY ACTIVE FILES*/
32700000         THEN
32710000           DO;
32720000             SMPLIST_CNTL.A_STAT.#_F_ACTIVE = SMPLIST_CNTL.A_STAT.#_F_ACTIVE + 1;
32730000           END;
32740000     END;
32750000  END  SMPLIST_CNTL_A_STAT_BUILD;
32760000 %SKIP(3);
32770000  SMPLIST_CNTL_E_CMPR_INIT:       /**************************************************/
32780000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
32790000                                  /*IT INITIALIZES VARIABLES IN THE E_CMPR          */
32800000                                  /*SUBSTRUCTURE OF THE SMPLIST_CNTL MAJOR STRUCTURE*/
32810000  PROC;                           /**************************************************/
32820000     SMPLIST_CNTL.HIGH_PAGE.NTRYNAME  =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYNAME));
32830000     SMPLIST_CNTL.HIGH_PAGE.NTRYINDX  =    NTRYINDX_MAX + 1;
32840000     SMPLIST_CNTL.HIGH_PAGE.PAGEKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.PAGEKEY));
32850000     SMPLIST_CNTL.HIGH_PAGE.NTRYKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.NTRYKEY));
32860000     SMPLIST_CNTL.HIGH_PAGE.CMPRKEY   =    HIGH(LENGTH(SMPLIST_CNTL.HIGH_PAGE.CMPRKEY));
32870000
32880000     SMPLIST_CNTL.HIGH_CMPR          =     SMPLIST_CNTL.HIGH_PAGE,    BY NAME;
32890000     SMPLIST_CNTL.HIGH_CMPR.RESULT   =     '0'B;
32900000
32910000     SMPLIST_CNTL.E_CMPR               =   SMPLIST_CNTL.HIGH_CMPR,    BY NAME;
32920000  END  SMPLIST_CNTL_E_CMPR_INIT;
32930000 %PAGE;
32940000  SMPLIST_CNTL_A_MATCH_INIT:      /**************************************************/
32950000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
32960000                                  /*IT INITIALIZES THE A_MATCH SUBSTRUCTURE         */
32970000                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */
32980000  PROC;                           /**************************************************/
32990000          SMPLIST_CNTL.A_MATCH.ACTIVE   =  '0'B;
33000000          SMPLIST_CNTL.A_MATCH.RESULT   =  '0'B;
33010000
33020000     DO     NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
33030000          SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '0'B;
33040000     END;           /*END OF NTRYINDX_IX DO GROUP*/
33050000
33060000     DO     IFILE   = IFILE_MIN  TO IFILE_MAX;
33070000          SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =  '0'B;
33080000     END;           /*END OF IFILE  DO GROUP*/
33090000
33100000     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;
33110000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =  NTRYINDX_MIN - 1;
33120000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE    =  '0'B;
33130000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST     =  '0'B;
33140000       DO   IFILE   = IFILE_MIN  TO IFILE_MAX;
33150000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR     =  '0'B;
33160000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR   =  '0'B;
33170000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR   =  '0'B;
33180000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL      =  '0'B;
33190000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL    =  '0'B;
33200000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL    =  '0'B;
33210000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT      =  '0'B;
33220000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL      =  '0'B;
33230000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL    =  '0'B;
33240000          SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL    =  '0'B;
33250000       END;         /*END OF IFILE  DO GROUP*/
33260000     END;           /*END OF IMATCH DO GROUP*/
33270000  END SMPLIST_CNTL_A_MATCH_INIT;
33280000 %PAGE;
33290000  SMPLIST_CNTL_A_MATCH_BUILD:     /**************************************************/
33300000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
33310000                                  /*IT SETS UP THE A_MATCH SUBSTRUCTURE             */
33320000                                  /*IN THE SMPLIST FILE CONTROL STRUCTURE.          */
33330000  PROC;                           /**************************************************/
33340000     DO     IMATCH  = IMATCH_MIN TO IMATCH_MAX;
33350000       SELECT(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
33360000         WHEN('NONE')  NTRYINDX_IX  =  NTRYINDX_MIN - 1;
33370000         WHEN('ALL')   NTRYINDX_IX  =  NTRYINDX_MAX + 1;
33380000         OTHERWISE     NTRYINDX_IX  =  ENTRY_INDEX(MATCH_ARRAY.ENTRY(IMATCH).TYPE);
33390000       END;
33400000       SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX = NTRYINDX_IX;
33410000
33420000       IF       (NTRYINDX_IX >= NTRYINDX_MIN)     /*IF A SPECIFIC ENTRY TYPE OR "ALL"*/
33430000         THEN                                          /*IF THE MATCH ENTRY IS ACTIVE*/
33440000           DO;
33450000             IF (NTRYINDX_IX <= NTRYINDX_MAX)
33460000               THEN                                  /*IF THE MATCH ENTRY TYPE IS ONE*/
33470000                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(NTRYINDX_IX) = '1'B;
33480000               ELSE                                /*IF THE MATCH ENTRY TYPE IS "ALL"*/
33490000                     SMPLIST_CNTL.A_MATCH.M_E_TYPE(*)           = '1'B;
33500000
33510000             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '1'B;             /*ACTIVE*/
33520000
33530000             SELECT(MATCH_ARRAY.ENTRY(IMATCH).COMPARE_TEST);
33540000               WHEN('ANY') SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '0'B;
33550000               OTHERWISE   SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST  = '1'B;
33560000             END;                        /*END OF COMPARE_TEST SELECT GROUP*/
33570000
33580000             DO      IFILE   = IFILE_MIN  TO IFILE_MAX;
33590000               IF   (SMPLIST(IFILE).ACTIVE)                         /*IF FILE IS ACTIVE*/
33600000                 THEN
33610000                     CALL      SMPLIST_CNTL_A_MATCH_F_BUILD;
33620000             END;                        /*END OF        IFILE  DO GROUP*/
33630000           END;                          /*END OF ACTIVE IMATCH    DO GROUP*/
33640000
33650000         ELSE
33660000             SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE  = '0'B;            /*INACTIVE*/
33670000
33680000       SMPLIST_CNTL.A_MATCH.ACTIVE   =     SMPLIST_CNTL.A_MATCH.ACTIVE
33690000                                        |  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE;
33700000     END;                                /*END OF        IMATCH DO GROUP*/
33710000    %PAGE;
33720000     IF  (SMPLIST_CNTL.A_MATCH.ACTIVE)
33730000       THEN                                        /*IF    MATCH ENTRIES WERE ACTIVE*/
33740000         DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*ACTIVE  FILES CAN PRODUCE OUTPUT*/
33750000               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE
33760000                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));
33770000         END;                         /*END OF        IFILE  DO GROUP*/
33780000
33790000       ELSE                                        /*IF NO MATCH ENTRIES WERE ACTIVE*/
33800000         DO;
33810000            SMPLIST_CNTL.A_MATCH.M_E_TYPE(*) = '1'B; /*CONSIDER ALL ENTRY TYPES ACTIVE */
33820000            DO   IFILE   = IFILE_MIN  TO IFILE_MAX;  /*SCANNED FILES CAN PRODUCE OUTPUT*/
33830000               SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)  =   (SMPLIST(IFILE).ACTIVE
33840000                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE);
33850000               SMPLIST(IFILE).M_E_TYPE(*)            =   (SMPLIST(IFILE).ACTIVE
33860000                                                        & SMPLIST(IFILE).SCAN_CUBE.ACTIVE
33870000                                                        & SMPLIST_CNTL.A_MATCH.M_E_TYPE(*));
33880000            END;                         /*END OF        IFILE  DO GROUP*/
33890000         END;
33900000     RETURN;                             /*TO THE CALLER OF SMPLIST_CNTL_A_MATCH_BUILD*/
33910000 %PAGE;
33920000  SMPLIST_CNTL_A_MATCH_F_BUILD:   /**************************************************/
33930000                                  /*THIS SUBROUTINE IS INTERNAL TO                  */
33940000                                  /*SMPLIST_CNTL_A_MATCH_BUILD IN SMPLIST_OPEN.     */
33950000                                  /*IT SETS THE MATCH/SCAN/WRITE BITS FOR A FILE.   */
33960000                                  /**************************************************/
33970000  PROC;                           /*IMATCH & IFILE ARE SET ON ENTRY                 */
33980000
33990000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
34000000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'COMPARE');
34010000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR
34020000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_OPTION = 'NOCOMPARE');
34030000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR
34040000              =    ¬ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
34050000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR);
34060000
34070000
34080000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
34090000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
34100000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
34110000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'SELECT');
34120000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL
34130000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
34140000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
34150000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).COMPARE_SELECT = 'NOSELECT');
34160000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL
34170000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
34180000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR)
34190000                &  ¬ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
34200000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL);
34210000
34220000
34230000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT
34240000              =      (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_OPTION   = 'WRITE');
34250000
34260000
34270000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
34280000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
34290000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'SELECT');
34300000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL
34310000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
34320000                &    (MATCH_ARRAY.ENTRY(IMATCH).FILE(IFILE).WRITE_SELECT   = 'NOSELECT');
34330000     SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL
34340000              =      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
34350000                &  ¬ (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
34360000                    | SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL);
34370000    %PAGE;
34380000     SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE)        /*IF FILE IS A CANDIDATE FOR OUTPUT*/
34390000              =      (SMPLIST_CNTL.A_MATCH.F_OUTPUT(IFILE))
34400000
34410000                |   ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ALL*/
34420000                 & (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR)
34430000                   | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))
34440000                   & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)))
34450000
34460000                |  ((¬SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST)              /*ANY*/
34470000                 &   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT));
34480000
34490000
34500000  END  SMPLIST_CNTL_A_MATCH_F_BUILD;
34510000 %SKIP(2);
34520000  END  SMPLIST_CNTL_A_MATCH_BUILD;
34530000 %PAGE;
34540000  SMPLIST_INIT:                   /**************************************************/
34550000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
34560000                                  /*IT INITIALIZES VARIABLES IN THE SMPLIST         */
34570000                                  /*MAJOR STRUCTURE.                                */
34580000                                  /**************************************************/
34590000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPLIST_INIT        */
34600000     SMPLIST(IFILE).FILEREF               =  DTFLIST_LIST(IFILE);   /*FILE REFERENCE*/
34610000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
34620000       WHEN(1)                          /*IF IN SINGLE DIGITS*/
34630000           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LIST',IFILE) (A,A,P'9'); /*DDN*/
34640000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
34650000           PUT STRING(SMPLIST(IFILE).DDNAME) EDIT(DDIPFX,'LST',IFILE) (A,A,P'99'); /*DDN*/
34660000     END;
34670000     SMPLIST(IFILE).ACTIVE                =  '0'B;      /*ASSUME FILE IS NOT ACTIVE */
34680000     SMPLIST(IFILE).EOF                   =  '0'B;      /*ASSUME FILE NOT AT EOF    */
34690000     SMPLIST(IFILE).LINE_SZ               =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE */
34700000
34710000     SMPLIST(IFILE).CURR_PAGE.PAGE_BS     =  00000;     /*INITIALIZE PAGE NMBR BASE */
34720000     SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  0000;      /*INITIALIZE PAGE NUMBER    */
34730000     SMPLIST(IFILE).CURR_PAGE.PAGE_HI     =  0000;      /*INITIALIZE PAGE NUMBER    */
34740000     SMPLIST(IFILE).CURR_PAGE.LINE_NO     =  0000;      /*INITIALIZE LINE NUMBER    */
34750000     SMPLIST(IFILE).CURR_PAGE.FLUSH       =  '0'B;      /*INITIALIZE PAGE FLUSH IND.*/
34760000     SMPLIST(IFILE).CURR_PAGE.LINE_CT     =  0000;      /*INITIALIZE LINE COUNT     */
34770000     SMPLIST(IFILE).CURR_PAGE.WRITE_OUT   = '0'B;       /*INITIALIZE WRITE_OUT  IND.*/
34780000     SMPLIST(IFILE).CURR_PAGE.CMPR_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/
34790000     SMPLIST(IFILE).CURR_PAGE.SCAN_RESULT = '0'B;       /*INITIALIZE CMPR_RESULTIND.*/
34800000     SMPLIST(IFILE).CURR_PAGE.ZONENAME    = ' ';        /*INITIALIZE ZONE NAME      */
34810000     SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =  0;         /*INITIALIZE ZONE INDEX     */
34820000     SMPLIST(IFILE).CURR_PAGE.ZONETYPE    = ' ';        /*INITIALIZE ZONE TYPE      */
34830000     SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  = ' ';        /*INITIALIZE ZONE TYPE CHR  */
34840000     SMPLIST(IFILE).CURR_PAGE.NTRYNAME    = ' ';        /*INITIALIZE ENTRY NAME     */
34850000     SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =  0;         /*INITIALIZE ENTRY INDEX    */
34860000     SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    = ' ';        /*INITIALIZE ENTRY TYPE     */
34870000     SMPLIST(IFILE).CURR_PAGE.FMID        = ' ';        /*INITIALIZE ENTRY FMID     */
34880000     SMPLIST(IFILE).CURR_PAGE.SOURCEID    = ' ';        /*INITIALIZE ENTRY SOURCE ID*/
34890000     SMPLIST(IFILE).CURR_PAGE.SYSLIB1     = ' ';        /*INITIALIZE ENTRY SYSLIB1  */
34900000     SMPLIST(IFILE).CURR_PAGE.SYSLIB2     = ' ';        /*INITIALIZE ENTRY SYSLIB2  */
34910000     SMPLIST(IFILE).CURR_PAGE.PAGEKEY     = ' ';        /*INITIALIZE PAGE KEY FOR NEWPAGE*/
34920000     SMPLIST(IFILE).CURR_PAGE.NTRYKEY     = ' ';        /*INITIALIZE ENTRY KEY FOR CMPR*/
34930000     SMPLIST(IFILE).CURR_PAGE.CMPRKEY     = ' ';        /*INITIALIZE COMPARE KEY    */
34940000     SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
34950000     SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
34960000     SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
34970000
34980000     STRING(SMPLIST(IFILE).CURR_LINE)     = ' ';        /*INITIALIZE LINE DATA      */
34990000
35000000     SMPLIST(IFILE).CURR_NTRY             =   SMPLIST(IFILE).CURR_PAGE,   BY NAME;
35010000
35020000     SMPLIST(IFILE).M_E_TYPE(*)           = '0'B;
35030000
35040000     CALL  SMPLIST_SCAN_CUBE_INIT;               /*INITIALIZE SCAN_CUBE SUBSTRUCTURE*/
35050000    %PAGE;
35060000     SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE                 = 0; /*INITIALIZE FILE TOTALS*/
35070000     SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT                 = 0; /*INITIALIZE FILE TOTALS*/
35080000     SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND                = 0; /*INITIALIZE FILE TOTALS*/
35090000     SMPLIST(IFILE).FILE_TOTALS.RCRD_CT                    = 0; /*INITIALIZE FILE TOTALS*/
35100000
35110000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT  = 0; /*INITIALIZE NTRY TOTALS*/
35120000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO = 0;
35130000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI = 0;
35140000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT   = 0; /*INITIALIZE NTRY TOTALS*/
35150000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME   = ' ';
35160000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE   = 0; /*INITIALIZE NTRY TOTALS*/
35170000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE   = 0; /*INITIALIZE NTRY TOTALS*/
35180000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT = 0; /*INITIALIZE NTRY TOTALS*/
35190000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT  = 0; /*INITIALIZE NTRY TOTALS*/
35200000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT  = 0; /*INITIALIZE NTRY TOTALS*/
35210000
35220000     DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
35230000       SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX)            =
35240000                                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1), BY NAME;
35250000     END;                  /*END OF NTRYINDX_IX DO GROUP*/
35260000
35270000  END  SMPLIST_INIT;
35280000 %PAGE;
35290000  SMPLIST_SCAN_CUBE_INIT:         /**************************************************/
35300000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
35310000                                  /*IT INITIALIZES THE SCAN_CUBE SUBSTRUCTURE       */
35320000                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */
35330000                                  /**************************************************/
35340000  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_INIT  */
35350000         SMPLIST(IFILE).SCAN_CUBE.RESULT   = '0'B;
35360000         SMPLIST(IFILE).SCAN_CUBE.SELECT   = '0'B;
35370000         SMPLIST(IFILE).SCAN_CUBE.ACTIVE   = '0'B;
35380000     DO  IPLANE = IPLANE_MIN TO IPLANE_MAX;
35390000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   = '0'B;
35400000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT   = '0'B;
35410000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE   = '0'B;
35420000       DO  IROW = IROW_MIN   TO IROW_MAX;
35430000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT   = '0'B;
35440000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT   = '0'B;
35450000         SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE   = '0'B;
35460000       END;                /*END OF IROW DO GROUP*/
35470000     END;                  /*END OF IPLANE DO GROUP*/
35480000
35490000  END  SMPLIST_SCAN_CUBE_INIT;
35500000 %PAGE;
35510000  SMPLIST_SCAN_CUBE_BUILD:        /**************************************************/
35520000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
35530000                                  /*IT SETS UP THE SCAN_CUBE SUBSTRUCTURE           */
35540000                                  /*IN THE SMPLIST FILE MANAGEMENT STRUCTURE.       */
35550000                                  /**************************************************/
35560000  PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPLIST_SCAN_CUBE_BUILD */
35570000     DO     IPLANE  = IPLANE_MIN TO IPLANE_MAX;
35580000       DO     IROW  = IROW_MIN   TO IROW_MAX;
35590000         DO   ICOL  = ICOL_MIN   TO ICOL_MAX;
35600000
35610000           IF SCAN_ARRAY(IFILE).STR_LEN(IPLANE,IROW,ICOL) > 0   /*IF STRING SUPPLIED*/
35620000             THEN      /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW ACTIVE IND.*/
35630000               DO;
35640000                SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE = '1'B;
35650000                SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
35660000                               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
35670000               END;
35680000
35690000         END;              /*END OF ICOL DO GROUP*/
35700000
35710000         IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
35720000           THEN       /*IF ANY COLUMN IN THE ROW IS ACTIVE, SET THE ROW SELECT OPTION*/
35730000             DO;      /*AND THE PLANE ACTIVE OPTION                                  */
35740000               SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE = '1'B;
35750000               IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).ROW(IROW).SELECT_OPTION = 'SELECT'
35760000                 THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT  = '1'B;
35770000               SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
35780000                              SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
35790000             END;
35800000
35810000       END;                /*END OF IROW DO GROUP*/
35820000
35830000       IF    (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)
35840000         THEN         /*IF ANY ROW IN THE PLANE IS ACTIVE, SET THE PLANE SELECT OPTION*/
35850000           DO;        /*AND THE CUBE  ACTIVE OPTION                                   */
35860000             SMPLIST(IFILE).SCAN_CUBE.ACTIVE = '1'B;
35870000             IF SCAN_ARRAY.FILE(IFILE).PLANE(IPLANE).SELECT_OPTION = 'SELECT'
35880000               THEN SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT  = '1'B;
35890000             SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
35900000                            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
35910000           END;
35920000
35930000     END;                  /*END OF IPLANE DO GROUP*/
35940000
35950000     IF    (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)
35960000       THEN           /*IF ANY PLANE IN THE CUBE IS ACTIVE, SET THE CUBE SELECT OPTION*/
35970000         DO;
35980000            IF SCAN_ARRAY.FILE(IFILE).SELECT_OPTION = 'SELECT'
35990000              THEN SMPLIST(IFILE).SCAN_CUBE.SELECT  = '1'B;
36000000            SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  =
36010000                           SMPLIST(IFILE).FILE_TOTALS.#_S_ACTIVE  + 1;
36020000           END;
36030000
36040000  END  SMPLIST_SCAN_CUBE_BUILD;
36050000 %PAGE;
36060000  SMPUT_INIT:                     /**************************************************/
36070000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
36080000                                  /*IT INITIALIZES VARIABLES IN THE SMPUT MAJOR     */
36090000                                  /*STRUCTURE.                                      */
36100000                                  /**************************************************/
36110000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPUT_INIT          */
36120000     SMPUT(IFILE).FILEREF             =  DTFUT_LIST(IFILE);         /*FILE REFERENCE*/
36130000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
36140000       WHEN(1)                          /*IF IN SINGLE DIGITS*/
36150000           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)     (A,A,P'9'); /*DDN*/
36160000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
36170000           PUT STRING(SMPUT(IFILE).DDNAME) EDIT(DDIPFX,'UT',IFILE)    (A,A,P'99'); /*DDN*/
36180000     END;
36190000     SMPUT(IFILE).WRITE.SAVE_CT       =  0000;         /*INITIALIZE WRITE SAVE COUNT*/
36200000     SMPUT(IFILE).WRITE.OPEN_CT       =  0000;         /*INITIALIZE WRITE OPEN COUNT*/
36210000     SMPUT(IFILE).WRITE.LINE_CT       =  0000;         /*INITIALIZE WRITE LINE COUNT*/
36220000
36230000     SMPUT(IFILE).READ                =  SMPUT(IFILE).WRITE,  BY NAME;
36240000  END  SMPUT_INIT;
36250000 %PAGE;
36260000  SMPSCAN_INIT:                   /**************************************************/
36270000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
36280000                                  /*IT INITIALIZES VARIABLES IN THE SMPSCAN MAJOR   */
36290000                                  /*STRUCTURE.                                      */
36300000                                  /**************************************************/
36310000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSCAN_INIT        */
36320000     SMPSCAN(IFILE).FILEREF           =  DTFSCAN_LIST(IFILE);       /*FILE REFERENCE*/
36330000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
36340000       WHEN(1)                          /*IF IN SINGLE DIGITS*/
36350000           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCAN',IFILE) (A,A,P'9'); /*DDN*/
36360000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
36370000           PUT STRING(SMPSCAN(IFILE).DDNAME) EDIT(DDOPFX,'SCN',IFILE) (A,A,P'99'); /*DDN*/
36380000     END;
36390000     SMPSCAN(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
36400000     SMPSCAN(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
36410000     SMPSCAN(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/
36420000     SMPSCAN(IFILE).LINE_SZ           =  LIST_LINE_SIZE + 012; /*INITIALIZE LINE SIZE*/
36430000     SMPSCAN(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/
36440000     SMPSCAN(IFILE).CURR_PAGE.PAGEKEY = ' ';            /*INITIALIZE PAGE KEY FOR NEWPAGE*/
36450000     SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36460000     SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36470000     SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36480000
36490000     SMPSCAN(IFILE).CURR_NTRY         =   SMPSCAN(IFILE).CURR_PAGE, BY NAME;
36500000  END  SMPSCAN_INIT;
36510000 %SKIP(3);
36520000  SMPSOUT_INIT:                   /**************************************************/
36530000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
36540000                                  /*IT INITIALIZES VARIABLES IN THE SMPSOUT MAJOR   */
36550000                                  /*STRUCTURE.                                      */
36560000                                  /**************************************************/
36570000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPSOUT_INIT        */
36580000     SMPSOUT(IFILE).FILEREF           =  DTFSOUT_LIST(IFILE);       /*FILE REFERENCE*/
36590000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
36600000       WHEN(1)                          /*IF IN SINGLE DIGITS*/
36610000           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOUT',IFILE) (A,A,P'9'); /*DDN*/
36620000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
36630000           PUT STRING(SMPSOUT(IFILE).DDNAME) EDIT(DDOPFX,'SOU',IFILE) (A,A,P'99'); /*DDN*/
36640000     END;
36650000     SMPSOUT(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
36660000     SMPSOUT(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
36670000     SMPSOUT(IFILE).PAGE_SZ           =  060;           /*INITIALIZE PAGE SIZE*/
36680000     SMPSOUT(IFILE).LINE_SZ           =  LIST_LINE_SIZE; /*INITIALIZE LINE SIZE*/
36690000     SMPSOUT(IFILE).CURR_PAGE.PAGE_NO =  0000;          /*INITIALIZE PAGE NUMBER*/
36700000     SMPSOUT(IFILE).CURR_PAGE.PAGEKEY =  ' ';           /*INITIALIZE PAGE KEY FOR NEWPAGE*/
36710000     SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36720000     SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36730000     SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA = ' ';        /*INITIALIZE TITLE LINES    */
36740000
36750000     SMPSOUT(IFILE).CURR_NTRY         =   SMPSOUT(IFILE).CURR_PAGE, BY NAME;
36760000  END  SMPSOUT_INIT;
36770000 %PAGE;
36780000  SMPDATA_INIT:                   /**************************************************/
36790000                                  /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.    */
36800000                                  /*IT INITIALIZES VARIABLES IN THE SMPDATA MAJOR   */
36810000                                  /*STRUCTURE.                                      */
36820000                                  /**************************************************/
36830000  PROC;                           /*IFILE IS PRESET ON ENTRY TO SMPDATA_INIT        */
36840000     SMPDATA(IFILE).FILEREF           =  DTFDATA_LIST(IFILE);       /*FILE REFERENCE*/
36850000     SELECT(FLOOR(1+LOG10(IFILE)));     /*NUMBER OF SIGNIFICANT DECIMAL DIGITS IN "IFILE"*/
36860000       WHEN(1)                          /*IF IN SINGLE DIGITS*/
36870000           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DATA',IFILE) (A,A,P'9'); /*DDN*/
36880000       WHEN(2)                          /*IF IN DOUBLE DIGITS*/
36890000           PUT STRING(SMPDATA(IFILE).DDNAME) EDIT(DDOPFX,'DAT',IFILE) (A,A,P'99'); /*DDN*/
36900000     END;
36910000     SMPDATA(IFILE).ACTIVE            =  '0'B;          /*FILE NOT YET ACTIVATED*/
36920000     SMPDATA(IFILE).OPEN              =  '0'B;          /*FILE NOT YET OPENED*/
36930000     SMPDATA(IFILE).LINE_SZ           =  LIST_LINE_RCZD; /*INITIALIZE LINE(RECORD SIZE*/
36940000     SMPDATA(IFILE).CURR_CARD.DATA    =  ' ';           /*CLEAR DATA OUTPUT AREA*/
36950000     SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  000000000;     /*INITIALIZE SEQUENCE NUMBER*/
36960000
36970000     SMPDATA(IFILE).CURR_NTRY         =   SMPDATA(IFILE).CURR_CARD, BY NAME;
36980000  END  SMPDATA_INIT;
36990000 %PAGE;
37000000     SMPSCAN_ACTIVATE:           /***************************************************/
37010000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
37020000                                 /*IT ACTIVATES THE SMPSCAN DATA SET FOR THIS IFILE.*/
37030000                                 /***************************************************/
37040000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSCAN_ACTIVATE   */
37050000
37060000          SMPSCAN(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
37070000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
37080000
37090000       END SMPSCAN_ACTIVATE;
37100000     %SKIP(3);
37110000     SMPSOUT_ACTIVATE:           /***************************************************/
37120000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
37130000                                 /*IT ACTIVATES THE SMPSOUT DATA SET FOR THIS IFILE.*/
37140000                                 /***************************************************/
37150000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPSOUT_ACTIVATE   */
37160000
37170000          SMPSOUT(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
37180000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
37190000
37200000       END SMPSOUT_ACTIVATE;
37210000     %SKIP(3);
37220000     SMPDATA_ACTIVATE:           /***************************************************/
37230000                                 /*THIS SUBROUTINE IS INTERNAL TO SMPLIST_OPEN.     */
37240000                                 /*IT ACTIVATES THE SMPDATA DATA SET FOR THIS IFILE.*/
37250000                                 /***************************************************/
37260000       PROC;                     /*IFILE IS SET PRIOR TO CALLING SMPDATA_ACTIVATE   */
37270000          IF  DATA_OUTPUT_OPTION(IFILE)  ¬=  'NONE'
37280000            THEN           /*IF DATA_OUTPUT_OPTION = 'ID1' | 'ID' | 'SELECT' | 'ALL'*/
37290000              DO;
37300000                SMPDATA(IFILE).ACTIVE  =   '1'B;          /*INDICATE FILE IS ACTIVE*/
37310000              END;
37320000          SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT = SMPLIST(IFILE).FILE_TOTALS.#_F_OUTPUT + 1;
37330000       END SMPDATA_ACTIVATE;
37340000 %SKIP(5);
37350000  END SMPLIST_OPEN;
37360000 %PAGE;
37370000  SMPLIST_CURR_PAGE_EOF:    /********************************************************/
37380000                            /*THE SMPLIST_CURR_PAGE_EOF SUBROUTINE IS CALLED BY     */
37390000                            /*SMPLIST_OPEN FOR INACTIVE FILES, AND BY               */
37400000                            /*SMPLIST_ENTRY_LINE_READ WHEN ATTEMPTING TO BEGIN A    */
37410000                            /*NEW ENTRY AT END-OF-FILE.  THIS SUBROUTINE SETS HIGH  */
37420000                            /*KEY VALUES AND OTHERWISE RESETS VALUES IN THE         */
37430000                            /*CURR_PAGE SUBSTRUCTURE OF THE SMPLIST MAJOR STRUCTURE.*/
37440000                            /********************************************************/
37450000  PROC;                        /*IFILE IS SET PRIOR TO CALLING SMPLIST_CURR_PAGE_EOF*/
37460000
37470000     STRING(SMPLIST(IFILE).CURR_LINE)                 =  ' ';      /*CLEAR LINE DATA*/
37480000     SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID)
37490000                                           = HIGH(LIST_LINE_NWID);/*ENTRY NAME FIELD*/
37500000
37510000     SMPLIST(IFILE).CURR_PAGE           =  SMPLIST_CNTL.HIGH_PAGE,  BY NAME;
37520000
37530000  END  SMPLIST_CURR_PAGE_EOF;
37540000 %PAGE;
37550000  SMPLIST_ENTRY_LINE_READ:
37560000  /********************************************************/
37570000  /*READ THE NEXT LINE FROM THE CURRENT SMPLIST DATA SET, */
37580000  /********************************************************/
37590000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_READ*/
37600000     DCL    ENTRY_DATA_LINE         BIT(1);               /*ASSUME NOT A DATA LINE  */
37610000
37620000     ON ENDFILE(SMPLIST(IFILE).FILEREF)
37630000        BEGIN;
37640000           SMPLIST(IFILE).EOF = '1'B;                 /*SIGNAL END-OF-FILE ON INPUT */
37650000        END;
37660000
37670000     SMPLIST_TITLE1_MAP_ADDR,
37680000     SMPLIST_TITLE2_MAP_ADDR,
37690000     SMPLIST_TITLE3_MAP_ADDR  = ADDR(SMPLIST(IFILE).CURR_LINE.IN.DATA);
37700000    %PAGE;
37710000     READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
37720000     ENTRY_DATA_LINE = '0'B;              /*ASSUME NOT A DATA LINE*/
37730000
37740000     DO WHILE(¬(SMPLIST(IFILE).EOF))      /*IF EOF WAS NOT RECOGNIZED       */
37750000                                          /*  (AN INPUT LINE WAS JUST READ),*/
37760000                                          /*DETERMINE WHETHER THE LINE      */
37770000        UNTIL(ENTRY_DATA_LINE);           /*IS PART OF AN ENTRY LISTING.    */
37780000
37790000        SMPLIST(IFILE).FILE_TOTALS.RCRD_CT = SMPLIST(IFILE).FILE_TOTALS.RCRD_CT + 1;
37800000
37810000        SELECT(SMPLIST(IFILE).CURR_LINE.IN.PRTCTL); /*UPDATE LINE NUMBER ON PAGE*/
37820000          WHEN('1') SMPLIST(IFILE).CURR_PAGE.LINE_NO = 01;         /*TOP-OF-PAGE*/
37830000          WHEN('+') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 0;
37840000          WHEN(' ') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 1;
37850000          WHEN('0') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 2;
37860000          WHEN('-') SMPLIST(IFILE).CURR_PAGE.LINE_NO = SMPLIST(IFILE).CURR_PAGE.LINE_NO + 3;
37870000          OTHERWISE;
37880000        END;
37890000
37900000        SELECT;            /*PROCESS THE LISTING LINE JUST READ FROM SMPLIST:*/
37910000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 01       /*IF TITLE1 LINE*/
37920000              & SMPLIST_TITLE1_MAP.EDATE         =  'DATE'
37930000              & SMPLIST_TITLE1_MAP.ETIME         =  'TIME'
37940000              & SMPLIST_TITLE1_MAP.EGIMSMP       =  'GIMSMP'
37950000              & SMPLIST_TITLE1_MAP.ESMPLIST      =  'SMPLIST'
37960000              & SMPLIST_TITLE1_MAP.EOUTPUT       =  'OUTPUT' )
37970000            DO;
37980000                IF      SMPLIST_TITLE1_MAP.PAGE_NO   = '0000'    /*PAGE NUMBER RECYCLE?*/
37990000                  THEN  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
38000000                                                     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
38010000                                                     +  10000;
38020000                SMPLIST(IFILE).CURR_PAGE.PAGE_NO     =  SMPLIST(IFILE).CURR_PAGE.PAGE_BS
38030000                                                     +  SMPLIST_TITLE1_MAP.PAGE_NO;
38040000                SMPLIST(IFILE).CURR_PAGE.FLUSH       = '0'B;     /*SET TO PROCESS PAGE*/
38050000                IF      SMPLIST_TITLE1_MAP.ZONETYPE  = 'GLOBAL'
38060000                  THEN  SMPLIST(IFILE).CURR_PAGE.ZONENAME
38070000                                                     = 'GLOBAL';
38080000                  ELSE  SMPLIST(IFILE).CURR_PAGE.ZONENAME
38090000                                                     =  TRIM(SMPLIST_TITLE1_MAP.ZONENAME);
38100000                SMPLIST(IFILE).CURR_PAGE.ZONEINDX    =
38110000                                                 ZONE_INDEX(SMPLIST_TITLE1_MAP.ZONETYPE);
38120000                SMPLIST(IFILE).CURR_PAGE.ZONETYPE    =
38130000                                            ZONE_TYPE(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);
38140000                SMPLIST(IFILE).CURR_PAGE.ZONETYPE_C  =
38150000                                          ZONE_TYPE_C(SMPLIST(IFILE).CURR_PAGE.ZONEINDX);
38160000                SMPLIST(IFILE).CURR_PAGE.TITLE1_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
38170000                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA,
38180000                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = ' ';      /*CLEAR TITLE2 & 3*/
38190000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
38200000            END;
38210000    %PAGE;
38220000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF TITLE2 LINE*/
38230000              & SMPLIST_TITLE2_MAP.ZONENAME      =  SMPLIST(IFILE).CURR_PAGE.ZONENAME
38240000                                                             /*IF VALID ENTRY TYPE*/
38250000              & ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001))) > 0)
38260000            DO;
38270000                SMPLIST(IFILE).CURR_PAGE.TITLE2_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
38280000                SMPLIST(IFILE).CURR_PAGE.NTRYINDX    =
38290000                   ENTRY_INDEX(ENTRY_TYPE_TRIM(SUBSTR(SMPLIST_TITLE2_MAP.NTRYTYPE,001)));
38300000                SMPLIST(IFILE).CURR_PAGE.NTRYTYPE    =
38310000                                           ENTRY_TYPE(SMPLIST(IFILE).CURR_PAGE.NTRYINDX);
38320000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
38330000            END;
38340000
38350000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 03       /*IF MASS SUMMARY REPORT   */
38360000                                                             /*OR SELECT SUMMARY REPORT */
38370000            & ( SMPLIST_TITLE2_MAP.ZONENAME      =  'LIST'   /*BYPASS THE PAGE ENTIRELY.*/
38380000            &  (INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'MASS SUMMARY REPORT') > 0
38390000              | INDEX(SMPLIST_TITLE2_MAP.NTRYTYPE,'SELECT SUMMARY REPORT') > 0)) )
38400000            DO;
38410000                SMPLIST(IFILE).CURR_PAGE.FLUSH  =  '1'B;
38420000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
38430000            END;
38440000
38450000         WHEN(  SMPLIST(IFILE).CURR_PAGE.LINE_NO <= 06       /*IF TITLE3 LINE*/
38460000              & SMPLIST_TITLE3_MAP.FILL01        =  ' '
38470000              & SMPLIST_TITLE3_MAP.ENAME         =  'NAME'
38480000              & SMPLIST_TITLE3_MAP.FILL02        =  ' ' )
38490000            DO;
38500000                SMPLIST(IFILE).CURR_PAGE.TITLE3_DATA = SMPLIST(IFILE).CURR_LINE.IN.DATA;
38510000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
38520000            END;
38530000
38540000         WHEN(  SMPLIST(IFILE).CURR_PAGE.FLUSH              /*IF PAGE IS BEING SKIPPED*/
38550000              | SMPLIST(IFILE).CURR_LINE.IN.DATA = ' ')     /*OR THE LINE IS BLANK*/
38560000            DO;                                             /*THEN SKIP PAST THE LINE*/
38570000                READ FILE(SMPLIST(IFILE).FILEREF) INTO(SMPLIST(IFILE).CURR_LINE.IN);
38580000            END;
38590000
38600000         OTHERWISE                 /*IF ALL OF THE PRECEEDING TESTS FAILED,          */
38610000            DO;                    /*THE LINE JUST READ IS AN ENTRY LISTING LINE.    */
38620000                ENTRY_DATA_LINE = '1'B;          /*INDICATE THAT A DATA LINE WAS READ*/
38630000            END;
38640000
38650000        END;           /*END OF SELECT GROUP FOR IDENTIFYING THE TYPE OF LINE READ*/
38660000
38670000     END;              /*END OF DO WHILE(¬SMPLIST(IFILE).EOF) UNTIL(ENTRY_DATA_LINE) GROUP*/
38680000    %PAGE;
38690000                                     /*AN ENTRY LISTING LINE HAS JUST BEEN READ.    */
38700000                                     /*CHECK FOR THE START OF A NEW ENTRY LISTING.  */
38710000                                     /*WE HAVE REACHED THE END OF THE CURRENT ENTRY */
38720000                                     /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,    */
38730000                                     /*OR IF END-OF-FILE WAS ENCOUNTERED.           */
38740000                                     /*IN EITHER CASE, WE WRAP UP PROCESSING OF     */
38750000                                     /*THE CURRENT ENTRY AND PREPARE TO BEGIN       */
38760000                                     /*PROCESSING THE NEW ENTRY.                    */
38770000
38780000     IF ( ¬(SMPLIST(IFILE).EOF)      /*IF THE FIRST LINE OF A NEW ENTRY,            */
38790000         & (SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,LIST_LINE_NBGN,LIST_LINE_NWID) ¬= ' '))
38800000      |    (SMPLIST(IFILE).EOF)      /*OR IF END-OF-FILE                            */
38810000        THEN
38820000          DO;          /*THE LINE JUST READ OR E-O-F ENDS THE PREVIOUS ENTRY LISTING*/
38830000             /*---------------------------------------------*/
38840000             /*PREPARE FOR PROCESSING A NEW ENTRY OR E-O-F  */
38850000             /*---------------------------------------------*/
38860000             IF  ¬(SMPLIST(IFILE).EOF)
38870000               THEN                                         /*FIRST LINE OF A NEW ENTRY */
38880000                 DO;
38890000                   SMPLIST(IFILE).CURR_LINE.LINETYPE   = ' ';  /*INITIALIZE FOR NEW ENTRY*/
38900000                   SMPLIST(IFILE).CURR_LINE.LINETYPE   =
38910000                                    LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,
38920000                                              SMPLIST(IFILE).CURR_LINE.IN.DATA);
38930000                   SMPLIST(IFILE).CURR_PAGE.NTRYNAME   =
38940000                                              TRIM(SUBSTR(SMPLIST(IFILE).CURR_LINE.IN.DATA,
38950000                                                          LIST_LINE_NBGN,LIST_LINE_NWID));
38960000                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.PAGEKEY)
38970000                       EDIT('0')                                  (A(1))
38980000                           (SMPLIST(IFILE).CURR_PAGE.ZONEINDX)    (P'9')
38990000                           (SMPLIST(IFILE).CURR_PAGE.ZONENAME)    (A(007))
39000000                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99');
39010000                   SMPLIST(IFILE).CURR_PAGE.NTRYKEY  =   SMPLIST(IFILE).CURR_PAGE.PAGEKEY
39020000                                                      || SMPLIST(IFILE).CURR_PAGE.NTRYNAME;
39030000                   PUT STRING(SMPLIST(IFILE).CURR_PAGE.CMPRKEY)
39040000                       EDIT('0')                                  (A(1))
39050000                           (SMPLIST(IFILE).CURR_PAGE.NTRYINDX)    (P'99')
39060000                           (SMPLIST(IFILE).CURR_PAGE.NTRYNAME)    (A(008));
39070000                 END;
39080000               ELSE                              /*IF ENTRY TERMINATED BY END-OF-FILE  */
39090000                 DO;
39100000                   CALL SMPLIST_CURR_PAGE_EOF;   /*SET CURR_PAGE VALUES FOR END-OF-FILE*/
39110000                 END;
39120000          END;
39130000        ELSE
39140000          DO;     /*THE LINE JUST READ IS A CONTINUATION OF THE CURRENT ENTRY LISTING*/
39150000            SMPLIST(IFILE).CURR_LINE.LINETYPE  =      /*DETERMINE LINETYPE*/
39160000                           LINE_TYPE(SMPLIST(IFILE).CURR_LINE.LINETYPE,
39170000                                     SMPLIST(IFILE).CURR_LINE.IN.DATA);
39180000          END;
39190000     RETURN;
39200000  END SMPLIST_ENTRY_LINE_READ;
39210000 %PAGE;
39220000  SMPLIST_ENTRY_READ:
39230000  /********************************************************/
39240000  /*READ THE NEXT ENTRY FROM THE ACTIVE SMPLIST DATA SETS */
39250000  /********************************************************/
39260000  PROC;
39270000
39280000      DO      IFILE = IFILE_MIN TO IFILE_MAX;
39290000        IF   (SMPLIST(IFILE).ACTIVE)                     /*PROCESS ONLY THE ACTIVE FILES */
39300000          &  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)      /*THAT WERE PROCESSED LAST TIME.*/
39310000          THEN
39320000            DO;                                   /*UPDATE CURR_NTRY FOR NEW ENTRY OR EOF*/
39330000              SMPLIST(IFILE).CURR_NTRY = SMPLIST(IFILE).CURR_PAGE   , BY NAME;
39340000
39350000              IF   (SMPLIST(IFILE).EOF)              /*IF THE FILE IS AT ITS END,        */
39360000                THEN;                                /*THEN FILE PROCESSING IS COMPLETE  */
39370000                ELSE CALL SMPLIST_ENTRY_FILE_READ;   /*OTHERWISE READ THE NEXT ENTRY.    */
39380000
39390000            END;            /*END OF ACTIVE IFILE/CMPR_RESULT DO GROUP*/
39400000      END;                  /*END OF IFILE                    DO GROUP*/
39410000
39420000      CALL SMPLIST_ENTRY_COMPARE;   /*COMPARE KEYS FOR ENTRIES READ*/
39430000
39440000      CALL SMPLIST_ENTRY_MATCH;     /*SEE IF THESE ENTRIES SHOULD BE PROCESSED FURTHER*/
39450000
39460000      RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_READ*/
39470000 %PAGE;
39480000  SMPLIST_ENTRY_FILE_READ:
39490000                              /***********************************************************/
39500000                              /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_READ".      */
39510000                              /*IT READS THE NEXT ENTRY FROM THE CURRENT SMPLIST         */
39520000                              /*DATA SET:                                                */
39530000                              /***********************************************************/
39540000  PROC;                       /*IFILE IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_READ         */
39550000     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
39560000       THEN
39570000         DO;
39580000              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/
39590000                THEN CALL  SMPLIST_ENTRY_SCAN_INIT;            /*INIT SCAN_CUBE FOR ENTRY*/
39600000         END;
39610000
39620000     DO WHILE(SMPLIST(IFILE).CURR_PAGE.NTRYKEY = SMPLIST(IFILE).CURR_NTRY.NTRYKEY);
39630000        CALL               SMPLIST_ENTRY_LINE_EVAL;       /*EVALUATE THE CURRENT LINE    */
39640000        IF   (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
39650000          THEN
39660000            DO;
39670000              IF  (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)       /*IF ENTRIES ARE BEING SCANNED,*/
39680000                THEN CALL  SMPLIST_ENTRY_LINE_SCAN;       /*SCAN THE CURRENT LINE        */
39690000              CALL         SMPLIST_ENTRY_LINE_SAVE;       /*SAVE THE CURRENT LINE        */
39700000            END;
39710000        CALL               SMPLIST_ENTRY_LINE_READ;       /*READ THE NEXT    LINE        */
39720000     END;
39730000     CALL                  SMPLIST_ENTRY_FILE_READ_WRAPUP;    /*CALC. CURR_NTRY FINAL VALS*/
39740000
39750000     IF      (SMPLIST(IFILE).M_E_TYPE(SMPLIST(IFILE).CURR_NTRY.NTRYINDX))
39760000       THEN
39770000         DO;
39780000           IF (SMPLIST(IFILE).CURR_NTRY.LINE_CT > LINE_SAVE_LIMIT)/*IF SPILL FILE OPENED,*/
39790000             THEN CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);   /*CLOSE IT.            */
39800000
39810000           IF (SMPLIST(IFILE).SCAN_CUBE.ACTIVE)            /*FINAL SCAN RESULTS FOR ENTRY*/
39820000             THEN SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT = SMPLIST_ENTRY_SCAN_RESULT;
39830000
39840000           IF (SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
39850000             THEN
39860000               DO;        /*IF THE SCAN_RESULT IS POSITIVE, UPDATE SELECT_CT TOTALS*/
39870000                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT  =
39880000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).SELECT_CT + 1;
39890000                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT =
39900000                 SMPLIST(IFILE).ENTRY_TOTALS(SMPLIST(IFILE).CURR_NTRY.NTRYINDX).SELECT_CT
39910000                                                                                    + 1;
39920000               END;
39930000         END;
39940000
39950000     RETURN;                       /*TO THE CALLER OF SMPLIST_ENTRY_FILE_READ*/
39960000 %PAGE;
39970000  SMPLIST_ENTRY_SCAN_INIT:    /********************************************************/
39980000                              /*INITIALIZE THE SCAN_CUBE IN SMPLIST FOR SCANNING THE  */
39990000                              /*ENTRY.                                                */
40000000                              /********************************************************/
40010000  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */
40020000                              /*SMPLIST_ENTRY_SCAN_INIT IS CALLED ONLY IF             */
40030000                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */
40040000                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */
40050000                   SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;
40060000     DO            IPLANE  = IPLANE_MIN TO IPLANE_MAX;
40070000       IF          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE ACTIVE*/
40080000         THEN
40090000           DO;
40100000                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;
40110000             DO    IROW  = IROW_MIN   TO IROW_MAX;
40120000               IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE
40130000                 THEN
40140000                   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT = '0'B;
40150000             END;                  /*END OF IROW          DO GROUP*/
40160000           END;                    /*END OF ACTIVE IPLANE DO GROUP*/
40170000     END;                          /*END OF IPLANE        DO GROUP*/
40180000  END SMPLIST_ENTRY_SCAN_INIT;
40190000 %SKIP(2);
40200000  SMPLIST_ENTRY_LINE_SCAN:    /********************************************************/
40210000                              /*SCAN THE CURRENT LINE AND SET ROW RESULTS.            */
40220000                              /*PLANE AND CUBE SCAN RESULTS ARE CALCULATED LATER ON,  */
40230000                              /*IN SMPLIST_ENTRY_SCAN_RESULT, AFTER ALL LINES         */
40240000                              /*FOR AN ENTRY HAVE BEEN SCANNED.                       */
40250000                              /********************************************************/
40260000  PROC;                       /*IFILE IS SET PRIOR TO ENTRY.                          */
40270000                              /*SMPLIST_ENTRY_LINE_SCAN IS CALLED ONLY IF             */
40280000                              /*SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.            */
40290000                              /*I.E., THERE IS AT LEAST ONE ACTIVE SCAN PLANE.        */
40300000
40310000     DO         IPLANE  = IPLANE_MIN TO IPLANE_MAX;
40320000       IF       SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE /*IF PLANE IS ACTIVE*/
40330000         THEN
40340000           DO     IROW  = IROW_MIN   TO IROW_MAX;
40350000             IF                           /*IF THE ROW IS ACTIVE AND STILL NO LINE HIT*/
40360000                 (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
40370000              & ¬(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT)
40380000
40390000               THEN
40400000                 SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT
40410000                   =  SMPLIST_SCAN_LINE_DATA(SMPLIST(IFILE).CURR_NTRY.NTRYINDX,
40420000                                             SMPLIST(IFILE).CURR_LINE.LINETYPE,
40430000                                             SMPLIST(IFILE).CURR_LINE.IN.DATA);
40440000
40450000           END;                  /*END OF IROW   DO GROUP*/
40460000     END;                       /*END OF IPLANE DO GROUP*/
40470000
40480000  END SMPLIST_ENTRY_LINE_SCAN;
40490000 %PAGE;
40500000  SMPLIST_ENTRY_LINE_EVAL:
40510000  /***********************************************************/
40520000  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_FILE_READ". */
40530000  /*IT CALCULATES ANY CURR_NTRY VALUES THAT ARE BASED ON     */
40540000  /*THE CURRENT LINE.                                        */
40550000  /***********************************************************/
40560000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_EVAL*/
40570000
40580000     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
40590000
40600000     SMPLIST(IFILE).CURR_NTRY.LINE_CT = SMPLIST(IFILE).CURR_NTRY.LINE_CT + 1;
40610000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     =
40620000                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LINE_CT     + 1;
40630000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  =
40640000                    SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LINE_CT  + 1;
40650000
40660000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT = 0001)        /*FIRST LINE OF A NEW ENTRY*/
40670000       THEN
40680000         DO;
40690000           SMPLIST(IFILE).CURR_NTRY.PAGE_NO =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;
40700000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    =
40710000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT    + 1;
40720000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT =
40730000                                 SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT + 1;
40740000
40750000           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT         = 0001)
40760000             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGELO      =
40770000                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
40780000           IF    (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).ENTRY_CT      = 0001)
40790000             THEN SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGELO   =
40800000                                 SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
40810000         END;
40820000
40830000     SMPLIST(IFILE).CURR_NTRY.PAGE_HI =  SMPLIST(IFILE).CURR_PAGE.PAGE_NO;
40840000
40850000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'FMID')
40860000       THEN
40870000           SMPLIST(IFILE).CURR_NTRY.FMID      =
40880000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,007);
40890000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SOURCEID')
40900000       THEN
40910000           SMPLIST(IFILE).CURR_NTRY.SOURCEID  =
40920000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);
40930000     IF   (SMPLIST(IFILE).CURR_LINE.LINETYPE  = 'SYSTEM LIBRARY')
40940000       THEN
40950000         DO;
40960000           SMPLIST(IFILE).CURR_NTRY.SYSLIB1   =
40970000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN,008);
40980000           SMPLIST(IFILE).CURR_NTRY.SYSLIB2   =
40990000                              SUBSTR(SMPLIST(IFILE).CURR_LINE.DATA,LIST_LINE_SBGN+010,008);
41000000         END;
41010000  END SMPLIST_ENTRY_LINE_EVAL;
41020000 %PAGE;
41030000  SMPLIST_ENTRY_LINE_SAVE:
41040000  /***********************************************************/
41050000  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_READ".      */
41060000  /*IT SAVES THE CURRENT LINE OF THE CURRENT ENTRY FROM      */
41070000  /*THE CURRENT SMPLIST DATA SET.  IF THE CAPACITY OF THE    */
41080000  /*IN-STORAGE SAVE AREA HAS BEEN EXCEEDED, THE SPILL FILE   */
41090000  /*(SMPUT?) IS OPENED, AND THE LINE IS WRITTEN TO THE       */
41100000  /*SPILL FILE.                                              */
41110000  /*                                                         */
41120000  /***********************************************************/
41130000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_LINE_SAVE*/
41140000
41150000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  0001)
41160000       THEN
41170000         DO;
41180000             SMPUT(IFILE).WRITE.SAVE_CT = SMPUT(IFILE).WRITE.SAVE_CT + 1;
41190000         END;
41200000
41210000     IF     (SMPLIST(IFILE).CURR_NTRY.LINE_CT  =  LINE_SAVE_LIMIT+1)
41220000       THEN
41230000         DO;
41240000             SMPUT(IFILE).WRITE.OPEN_CT = SMPUT(IFILE).WRITE.OPEN_CT + 1;
41250000             OPEN  FILE(SMPUT(IFILE).FILEREF) OUTPUT TITLE(SMPUT(IFILE).DDNAME);
41260000         END;
41270000
41280000     IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT <=   LINE_SAVE_LIMIT
41290000
41300000       THEN  SMPUT(IFILE).LINE_SAVE(SMPLIST(IFILE).CURR_NTRY.LINE_CT)
41310000               =  SMPLIST(IFILE).CURR_LINE.IN.DATA;
41320000       ELSE
41330000         DO;
41340000             SMPUT(IFILE).WRITE.LINE_CT = SMPUT(IFILE).WRITE.LINE_CT + 1;
41350000             WRITE FILE(SMPUT(IFILE).FILEREF)  FROM(SMPLIST(IFILE).CURR_LINE.IN.DATA);
41360000         END;
41370000
41380000  END SMPLIST_ENTRY_LINE_SAVE;
41390000 %PAGE;
41400000  SMPLIST_ENTRY_FILE_READ_WRAPUP:
41410000  /***********************************************************/
41420000  /*THIS PROCEDURE IS INTERNAL TO "SMPLIST_ENTRY_FILE_READ". */
41430000  /*IT CALCULATES ANY FINAL CURR_NTRY VALUES FOR THE CURRENT */
41440000  /*ENTRY JUST ENDED.                                        */
41450000  /***********************************************************/
41460000  PROC;     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_FILE_READ_WRAPUP*/
41470000
41480000     NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
41490000
41500000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).LIST_PAGEHI,
41510000     SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).LIST_PAGEHI
41520000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_HI;
41530000
41540000     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >
41550000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE)
41560000       THEN
41570000         DO;
41580000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXLINE
41590000                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;
41600000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXNAME
41610000                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;
41620000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MAXPAGE
41630000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
41640000         END;
41650000
41660000     IF   (SMPLIST(IFILE).CURR_NTRY.LINE_CT    >
41670000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE)
41680000       THEN
41690000         DO;
41700000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXLINE
41710000                                               = SMPLIST(IFILE).CURR_NTRY.LINE_CT;
41720000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXNAME
41730000                                               = SMPLIST(IFILE).CURR_NTRY.NTRYNAME;
41740000           SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MAXPAGE
41750000                                               = SMPLIST(IFILE).CURR_NTRY.PAGE_NO;
41760000         END;
41770000  END SMPLIST_ENTRY_FILE_READ_WRAPUP;
41780000 %PAGE;
41790000  SMPLIST_ENTRY_SCAN_RESULT:    /**************************************************/
41800000                                /*CALCULATE THE FINAL SCAN RESULT FOR THE ENTRY   */
41810000                                /**************************************************/
41820000
41830000  PROC   RETURNS(BIT(01));     /*IFILE IS SET PRIOR TO CALLING SMPLIST_ENTRY_SCAN_RESULT,*/
41840000                               /*AND SMPLIST(IFILE).SCAN_CUBE.ACTIVE IS SET ON.   */
41850000
41860000              SMPLIST(IFILE).SCAN_CUBE.RESULT = '0'B;           /*PRESET TO '0'B*/
41870000     DO      IPLANE = IPLANE_MIN TO IPLANE_MAX;
41880000       IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)
41890000         THEN
41900000            DO;                /*ANY ACTIVE PLANE FOR THE FILE CAN MATCH*/
41910000                               /*ALL ACTIVE ROWS IN A PLANE   MUST MATCH*/
41920000
41930000              SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT = '1'B;
41940000              DO     IROW  = IROW_MIN   TO IROW_MAX
41950000                WHILE(SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);
41960000
41970000                IF   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE)
41980000                  THEN
41990000                      SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT   /*ALL ACTIVE ROWS*/
42000000                       =  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT
42010000                       & (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).SELECT =
42020000                          SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT);
42030000
42040000              END;             /*END OF IROW DO GROUP*/
42050000
42060000              SMPLIST(IFILE).SCAN_CUBE.RESULT                       /*ANY ACTIVE PLANES*/
42070000               =  SMPLIST(IFILE).SCAN_CUBE.RESULT
42080000               | (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT =
42090000                  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT);
42100000
42110000            END;               /*END OF ACTIVE IPLANE DO GROUP*/
42120000     END;                      /*END OF IPLANE DO GROUP*/
42130000
42140000     RETURN((SMPLIST(IFILE).SCAN_CUBE.SELECT = SMPLIST(IFILE).SCAN_CUBE.RESULT));
42150000
42160000  END SMPLIST_ENTRY_SCAN_RESULT;
42170000 %SKIP(2);
42180000  END SMPLIST_ENTRY_FILE_READ;
42190000 %PAGE;
42200000  SMPLIST_ENTRY_COMPARE:         /********************************************************/
42210000                                 /*COMPARE THE ENTRY KEYS FOR ALL ACTIVE SMPLIST FILES,  */
42220000                                 /*AND IDENTIFY THOSE THAT ARE LOWEST IN COLLATING SEQ:  */
42230000                                 /********************************************************/
42240000  PROC;
42250000
42260000      SMPLIST_CNTL.E_CMPR  =  SMPLIST_CNTL.HIGH_CMPR,    BY NAME;          /*RESET VALUES*/
42270000
42280000      DO    IFILE = IFILE_MIN TO IFILE_MAX; /*THE FIRST PASS FINDS THE LOWEST COMPARE KEY*/
42290000        IF   (SMPLIST(IFILE).ACTIVE)                          /*PROCESS ONLY ACTIVE FILES*/
42300000           & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY < SMPLIST_CNTL.E_CMPR.CMPRKEY)
42310000          THEN
42320000            DO;
42330000              SMPLIST_CNTL.E_CMPR         =  SMPLIST(IFILE).CURR_NTRY,  BY NAME;
42340000              SMPLIST_CNTL.E_CMPR.RESULT  = '1'B;
42350000            END;
42360000      END;
42370000
42380000      IF     (SMPLIST_CNTL.E_CMPR.RESULT)             /*IF ALL FILES WERE NOT AT E-O-F,  */
42390000        THEN                                          /*THE SECOND PASS IDENTIFIES       */
42400000          DO    IFILE = IFILE_MIN TO IFILE_MAX;       /*ENTRIES MATCHING THE COMPARE KEY.*/
42410000            IF   (SMPLIST(IFILE).ACTIVE)
42420000               & (SMPLIST(IFILE).CURR_NTRY.CMPRKEY     =  SMPLIST_CNTL.E_CMPR.CMPRKEY)
42430000              THEN
42440000                  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT = '1'B;   /*SET FOR MATCHING KEYS */
42450000          END;
42460000
42470000  END SMPLIST_ENTRY_COMPARE;
42480000 %PAGE;
42490000  SMPLIST_ENTRY_MATCH:           /********************************************************/
42500000                                 /*                                                      */
42510000  PROC;                          /********************************************************/
42520000     SMPLIST_CNTL.A_MATCH.RESULT  = '0'B;
42530000     DO      IFILE = IFILE_MIN TO IFILE_MAX;
42540000       SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =  '0'B;
42550000     END;
42560000
42570000     IF    (SMPLIST_CNTL.E_CMPR.RESULT)            /*IF ANY FILES HAVE ENTRIES TO PROCESS*/
42580000       THEN CALL SMPLIST_ENTRY_NTRY_MATCH;         /*MATCH THEM UP AND DETERMINE RESULTS */
42590000
42600000     IF    (SMPLIST_CNTL.A_MATCH.RESULT)
42610000       THEN                 /*IF THE MATCH_RESULT IS POSITIVE, UPDATE MATCH_CT TOTALS*/
42620000         DO IFILE = IFILE_MIN TO IFILE_MAX;
42630000            IF  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
42640000              THEN
42650000                DO;
42660000                  NTRYINDX_IX  =  SMPLIST(IFILE).CURR_NTRY.NTRYINDX;
42670000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    =
42680000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).MATCH_CT    + 1;
42690000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT =
42700000                  SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).MATCH_CT + 1;
42710000                END;             /*END OF CMPR_RESULT IFILE DO GROUP*/
42720000         END;                    /*END OF IFILE DO GROUP*/
42730000     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_MATCH*/
42740000 %PAGE;
42750000  SMPLIST_ENTRY_NTRY_MATCH:      /********************************************************/
42760000                                 /*                                                      */
42770000                                 /********************************************************/
42780000  PROC;
42790000
42800000     IF    (SMPLIST_CNTL.A_MATCH.ACTIVE)        /*TEST FOR ENTRY MATCH TESTS PROVIDED*/
42810000       THEN                             /*IF ANY ENTRY MATCH TESTS HAVE BEEN PROVIDED*/
42820000         DO IMATCH = IMATCH_MIN TO IMATCH_MAX;  /*APPLY ALL ACTIVE ONES FOR THIS TYPE*/
42830000
42840000           IF      (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).ACTIVE)                 /*ACTIVE*/
42850000
42860000              &  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX  =
42870000                                                  SMPLIST_CNTL.E_CMPR.NTRYINDX)
42880000                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >= NTRYINDX_MIN)
42890000                 & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX <= NTRYINDX_MAX))
42900000
42910000                |  (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).NTRYINDX >  NTRYINDX_MAX)) /*ALL*/
42920000
42930000             THEN          /*SMPLIST_ENTRY_FILE_MATCH SETS SMPLIST(*).CURR_NTRY.WRITE_OUT*/
42940000
42950000                SMPLIST_CNTL.A_MATCH.RESULT  =    SMPLIST_CNTL.A_MATCH.RESULT
42960000                                               |  SMPLIST_ENTRY_FILE_MATCH;
42970000
42980000         END;                    /*END OF IMATCH DO GROUP*/
42990000
43000000       ELSE                          /*IF NO MATCHING ENTRY TESTS HAVE BEEN PROVIDED,*/
43010000         DO IFILE = IFILE_MIN TO IFILE_MAX;       /*SUCCESSFUL SCAN/CMPRS ARE MATCHES*/
43020000            IF     (SMPLIST(IFILE).ACTIVE)
43030000              THEN
43040000                DO;
43050000                    SMPLIST(IFILE).CURR_NTRY.WRITE_OUT
43060000                                                  =  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT
43070000                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);
43080000                    SMPLIST_CNTL.A_MATCH.RESULT   =   SMPLIST_CNTL.A_MATCH.RESULT
43090000                                                  |  (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT
43100000                                                    & SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT);
43110000                END;
43120000         END;                    /*END OF  NO-MATCHING-ENTRY-TESTS IFILE DO GROUP*/
43130000
43140000     RETURN;                     /*TO THE CALLER OF SMPLIST_ENTRY_NTRY_MATCH*/
43150000 %PAGE;
43160000  SMPLIST_ENTRY_FILE_MATCH:      /********************************************************/
43170000                                 /*                                                      */
43180000                                 /********************************************************/
43190000  PROC RETURNS(BIT(1));          /*IMATCH IS SET ON ENTRY TO SMPLIST_ENTRY_FILE_MATCH    */
43200000     DCL (FILE_MATCH_RESULT,C_TST_CNTL)          BIT(01);
43210000
43220000     FILE_MATCH_RESULT,C_TST_CNTL  =  SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).C_TST;
43230000
43240000     DO         IFILE = IFILE_MIN TO IFILE_MAX   WHILE(FILE_MATCH_RESULT = C_TST_CNTL);
43250000        IF     (SMPLIST(IFILE).ACTIVE)
43260000          THEN  FILE_MATCH_RESULT  =
43270000
43280000                  (((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_CMPR
43290000                                             &  SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
43300000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGCMPR))
43310000
43320000                &  ((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_SEL
43330000                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
43340000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOSEL
43350000                                             & ¬SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
43360000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_IGSEL)))
43370000
43380000                |   (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).M_NOCMPR
43390000                                             & ¬SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT);
43400000
43410000     END;        /*END OF IFILE DO GROUP*/
43420000
43430000     IF       (FILE_MATCH_RESULT)                    /*IF THE FILE MATCH CRITERIA       */
43440000       THEN                                       /*WERE SATISFIED FOR THIS MATCH ENTRY,*/
43450000         DO         IFILE = IFILE_MIN TO IFILE_MAX;  /*SET REQUIRED WRITE_OUT INDICATORS*/
43460000           IF      (SMPLIST(IFILE).ACTIVE)
43470000                 & (SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
43480000             THEN
43490000                SMPLIST(IFILE).CURR_NTRY.WRITE_OUT  =
43500000                    (SMPLIST(IFILE).CURR_NTRY.WRITE_OUT)
43510000                |
43520000                   ((SMPLIST(IFILE).CURR_NTRY.CMPR_RESULT)
43530000                  & (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_OUT)
43540000                  &((SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_SEL
43550000                                             &  SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
43560000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_NOSEL
43570000                                             & ¬SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT)
43580000                  | (SMPLIST_CNTL.A_MATCH.E_MATCH(IMATCH).F_MATCH(IFILE).W_IGSEL)));
43590000
43600000         END;    /*END OF IFILE DO GROUP*/
43610000
43620000     RETURN(FILE_MATCH_RESULT);
43630000  END SMPLIST_ENTRY_FILE_MATCH;
43640000 %SKIP(1);
43650000  END SMPLIST_ENTRY_NTRY_MATCH;
43660000 %SKIP(1);
43670000  END SMPLIST_ENTRY_MATCH;
43680000 %SKIP(1);
43690000  END SMPLIST_ENTRY_READ;
43700000 %PAGE;
43710000  SMPLIST_ENTRY_WRITE:          /********************************************************/
43720000                                /*                                                      */
43730000                                /*                                                      */
43740000  PROC;                         /********************************************************/
43750000     DCL   ENTRY_NTRYINDX_ADDR   POINTER,
43760000           ENTRY_NTRYINDX        FIXED BIN(15,0) BASED(ENTRY_NTRYINDX_ADDR),
43770000           ENTRY_LINE_LINETYPE   CHAR(015),
43780000           ENTRY_LINE_DATA_ADDR  POINTER,
43790000           ENTRY_LINE_DATA       CHAR(120) BASED(ENTRY_LINE_DATA_ADDR),
43800000           ENTRY_LINE_SELECT     BIT(01),
43810000        01 ENTRY_LINE_UNDR,              /*UNDERLINE LINE FOR LISTING LINE BEING WRITTEN*/
43820000           05 PRTCTL             CHAR(001),                  /*SET TO "+" IF UNDERSCORES*/
43830000           05 DATA,
43840000              09 U_SCORE         CHAR(LIST_LINE_SIZE),       /*UNDERSCORES*/
43850000              09 FILL01          CHAR(001),                  /*BLANKS*/
43860000              09 A_FLAG          CHAR(011);                  /*ASTERISKS*/
43870000    %PAGE;
43880000     DO    IFILE = IFILE_MIN TO IFILE_MAX;
43890000       IF  SMPLIST(IFILE).CURR_NTRY.WRITE_OUT    /*PROCESS ONLY THOSE FILES THAT */
43900000                                                   /*HAVE DATA TO BE WRITTEN OUT.*/
43910000         THEN                                    /*IF THE FILE IS TO BE PROCESSED*/
43920000           DO;                                  /*WRITE THE CURRENT ENTRY LISTING*/
43930000             ENTRY_LINE_SELECT      = '0'B;    /*ASSUME NO LINES WILL BE SELECTED*/
43940000             STRING(ENTRY_LINE_UNDR) = ' ';    /*ASSUME UNDERLINES AREN'T PRESENT*/
43950000             ENTRY_NTRYINDX_ADDR    = ADDR(SMPLIST(IFILE).CURR_NTRY.NTRYINDX);
43960000             ENTRY_LINE_LINETYPE    = ' ';     /*INITIALIZE LINETYPE FOR ENTRY START*/
43970000             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT =
43980000             SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_MAX+1).WRITE_CT + 1;
43990000             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT =
44000000             SMPLIST(IFILE).ENTRY_TOTALS(ENTRY_NTRYINDX).WRITE_CT + 1;
44010000
44020000             IF      SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT
44030000               THEN                 /*IF THE SPILL FILE WILL BE NEEDED, OPEN IT FOR INPUT*/
44040000                 DO;
44050000                     SMPUT(IFILE).READ.OPEN_CT = SMPUT(IFILE).READ.OPEN_CT + 1;
44060000                     OPEN  FILE(SMPUT(IFILE).FILEREF) INPUT TITLE(SMPUT(IFILE).DDNAME);
44070000                 END;
44080000
44090000             DO        ILINE  =  001  TO   SMPLIST(IFILE).CURR_NTRY.LINE_CT;
44100000
44110000                IF     ILINE <=  LINE_SAVE_LIMIT    /*GET ADDRESS OF THE NEXT ENTRY LINE*/
44120000                  THEN     ENTRY_LINE_DATA_ADDR = ADDR(SMPUT(IFILE).LINE_SAVE(ILINE));
44130000                  ELSE DO;
44140000                           SMPUT(IFILE).READ.LINE_CT = SMPUT(IFILE).READ.LINE_CT + 1;
44150000                           READ FILE(SMPUT(IFILE).FILEREF) SET(ENTRY_LINE_DATA_ADDR);
44160000                       END;
44170000                ENTRY_LINE_LINETYPE = LINE_TYPE(ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA);
44180000
44190000                IF SMPLIST(IFILE).CURR_NTRY.SCAN_RESULT    /*IF THIS FILE'S ENTRIES ARE */
44200000                                                            /*BEING SCANNED, AND THE SCAN*/
44210000                                                            /*WAS SUCCESSFUL,            */
44220000                                                            /*ASSEMBLE THE UNDERLINE LINE*/
44230000                                           THEN CALL  SMPLIST_ENTRY_LINE_UNDRLINE;
44240000                IF SMPSCAN(IFILE).ACTIVE   THEN CALL  SMPSCAN_ENTRY_LINE_WRITE;
44250000                IF SMPSOUT(IFILE).ACTIVE   THEN CALL  SMPSOUT_ENTRY_LINE_WRITE;
44260000                IF SMPDATA(IFILE).ACTIVE   THEN CALL  SMPDATA_ENTRY_LINE_WRITE;
44270000             END;              /*END OF ILINE DO GROUP*/
44280000
44290000             IF        SMPLIST(IFILE).CURR_NTRY.LINE_CT >  LINE_SAVE_LIMIT
44300000               THEN                   /*IF THE SPILL FILE WAS OPENED FOR INPUT, CLOSE IT*/
44310000                       CLOSE FILE(SMPUT(IFILE).FILEREF) ENV(REREAD);
44320000
44330000           END;                /*END OF WRITE_OUT IFILE DO GROUP*/
44340000     END;                      /*END OF IFILE DO GROUP*/
44350000
44360000     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_WRITE*/
44370000 %PAGE;
44380000  SMPLIST_ENTRY_LINE_UNDRLINE:   /********************************************************/
44390000                                 /*                                                      */
44400000                                 /*                                                      */
44410000                                 /********************************************************/
44420000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
44430000
44440000     DCL 01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
44450000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,
44460000            STRING                  BUILTIN;
44470000
44480000     ENTRY_LINE_SELECT       = '0'B;                          /*RESET LINE SELECT CONTROL*/
44490000     STRING(ENTRY_LINE_UNDR) = ' ';                                /*CLEAR UNDERLINE LINE*/
44500000
44510000     DO          IPLANE  = IPLANE_MIN TO IPLANE_MAX  WHILE(ENTRY_LINE_UNDR.PRTCTL ¬= '+');
44520000       IF       (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ACTIVE)/*IF PLANE ACTIVE, AND*/
44530000            &   (SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).SELECT /*PLANE RESULTS SUCCESSFUL*/
44540000               = SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).RESULT)
44550000         THEN
44560000           DO     IROW  = IROW_MIN   TO IROW_MAX     WHILE(ENTRY_LINE_UNDR.PRTCTL ¬= '+');
44570000            IF  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE    /*IF ROW ACTIVE*/
44580000             &  SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).RESULT    /*WITH RESULTS*/
44590000             &  SMPLIST_SCAN_LINE_DATA(ENTRY_NTRYINDX,                   /*FROM THIS LINE*/
44600000                                        ENTRY_LINE_LINETYPE,ENTRY_LINE_DATA)
44610000               THEN
44620000                 DO;
44630000                   ENTRY_LINE_SELECT           = '1'B;     /*LINE IS SELECTED BY THIS ROW*/
44640000                   ENTRY_LINE_UNDR.PRTCTL      = '+';               /*LINE IS HIGHLIGHTED*/
44650000                   DO    ICOL  = ICOL_MIN   TO ICOL_MAX;             /*UNDERSCORE STRINGS*/
44660000                     SCAN_ARRAY_ELEMENT_ADDR
44670000                         = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
44680000                     IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                   /*IF STR SUPPL*/
44690000                       THEN
44700000                         CALL UNDERLINE_STRING_OP;
44710000                   END;        /*END OF ICOL   DO GROUP*/
44720000                   PUT STRING(ENTRY_LINE_UNDR.DATA.A_FLAG)
44730000                         EDIT('**',IPLANE,',',IROW,'**')           (A,P'999',A,P'999',A);
44740000                 END;          /*END OF ACTIVE/SELECTED IROW DO GROUP*/
44750000           END;                /*END OF IROW   DO GROUP*/
44760000     END;                      /*END OF IPLANE DO GROUP*/
44770000
44780000     RETURN;                   /*TO THE CALLER OF SMPLIST_ENTRY_LINE_UNDRLINE*/
44790000    %PAGE;
44800000     UNDERLINE_STRING_OP:
44810000     PROC;  /*UNDERLINE THE MATCHING STRINGS BASED ON                           */
44820000            /*THE TYPE OF SCAN OPERATION:                                       */
44830000        SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);
44840000          WHEN(12,13);  /* EQENTRY | NEENTRY */          /*NO UNDERLINES*/
44850000
44860000          WHEN(22)      /* EQLINE  */       CALL UNDERLINE_STRING_OKLINE;
44870000          WHEN(23)      /* NELINE  */       CALL UNDERLINE_STRING_OKLINE;
44880000
44890000          WHEN(32)      /* EQGLINE */       CALL UNDERLINE_STRING_OKGLIN;
44900000          WHEN(33)      /* NEGLINE */       CALL UNDERLINE_STRING_OKGLIN;
44910000
44920000          WHEN(42)      /* EQSCAN  */       CALL UNDERLINE_STRING_EQSCAN;
44930000          WHEN(43)      /* NESCAN  */       CALL UNDERLINE_STRING_NESCAN;
44940000
44950000          WHEN(52)      /* EQGSCAN */       CALL UNDERLINE_STRING_EQGSCN;
44960000          WHEN(53)      /* NEGSCAN */       CALL UNDERLINE_STRING_NEGSCN;
44970000
44980000          WHEN(60)      /* LTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
44990000          WHEN(61)      /* LECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
45000000          WHEN(62)      /* EQCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
45010000          WHEN(63)      /* NECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
45020000          WHEN(64)      /* GECMPR  */       CALL UNDERLINE_STRING_OKCMPR;
45030000          WHEN(65)      /* GTCMPR  */       CALL UNDERLINE_STRING_OKCMPR;
45040000
45050000          WHEN(72)      /* EQGCMPR */       CALL UNDERLINE_STRING_OKGCPR;
45060000          WHEN(73)      /* NEGCMPR */       CALL UNDERLINE_STRING_OKGCPR;
45070000
45080000        END;  /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/
45090000        RETURN;
45100000    %PAGE;
45110000     UNDERLINE_STRING_EQSCAN:
45120000     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */
45130000            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */
45140000            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */
45150000            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */
45160000            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */
45170000
45180000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
45190000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
45200000
45210000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
45220000
45230000        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
45240000               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);
45250000          IF   SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN)
45260000                   =  SCAN_ARRAY_ELEMENT.STRING
45270000            THEN
45280000              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/
45290000                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
45300000                US_IX = US_IX + US_LN - 1;
45310000              END;
45320000        END;
45330000     END UNDERLINE_STRING_EQSCAN;
45340000    %SKIP(3);
45350000     UNDERLINE_STRING_EQGSCN:
45360000     PROC;  /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS      */
45370000            /*FOR THE SEARCH STRING.  WHEREVER THE SCAN STRING APPEARS,         */
45380000            /*INSERT UNDERSCORE CHARACTERS INTO ENTRY_LINE_UNDR.DATA.U_SCORE    */
45390000            /*A DO LOOP IS USED TO UNDERSCORE ALL OCCURRENCES OF THE SEARCH     */
45400000            /*STRING WITHIN THE SCAN POSITIONS, AND NOT JUST THE FIRST.         */
45410000
45420000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
45430000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
45440000
45450000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
45460000
45470000        DO   US_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
45480000               TO    (SCAN_ARRAY_ELEMENT.END_POS - US_LN + 1);
45490000          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,US_IX,US_LN),
45500000                      SCAN_ARRAY_ELEMENT.STRING)
45510000            THEN
45520000              DO;   /*INSERT UNDERSCORES AND ADJUST POSITION INDEX FOR NEXT ATTEMPT*/
45530000                SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
45540000                US_IX = US_IX + US_LN - 1;
45550000              END;
45560000        END;
45570000     END UNDERLINE_STRING_EQGSCN;
45580000    %PAGE;
45590000     UNDERLINE_STRING_NESCAN:
45600000     UNDERLINE_STRING_NEGSCN:
45610000     PROC;  /*FOR A SUCCESSFULL "¬EQSCAN" OR "¬EQGSCN" THAT SCANNED POSITIONS   */
45620000            /*IN THE LISTING LINE WITHOUT FINDING THE SEARCH STRING, UNDERSCORE */
45630000            /*THE SEARCH AREA UNLESS IT IS THE ENTIRE LINE.                     */
45640000
45650000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
45660000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
45670000
45680000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
45690000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
45700000
45710000        IF (US_IX > LIST_LINE_DBGN) | (US_LN < LIST_LINE_SIZE) /*IF AREA NOT ENTIRE LINE*/
45720000          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
45730000
45740000     END UNDERLINE_STRING_NESCAN;
45750000    %PAGE;
45760000     UNDERLINE_STRING_OKCMPR:
45770000     UNDERLINE_STRING_OKGCPR:
45780000     PROC;  /*FOR A COMPARE THAT WAS SUCCESSFUL, UNDERLINE THE STRING           */
45790000            /*THAT COMPARED SUCCESSFULLY.  ONLY THE ONE OCCURRENCE              */
45800000            /*IS UNDERSCORED.                                                   */
45810000
45820000        DCL  US_IX               FIXED BIN(15,0),    /*UNDERSCORE POSITION INDEX*/
45830000             US_LN               FIXED BIN(15,0);    /*UNDERSCORE STRING  LENGTH*/
45840000
45850000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
45860000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
45870000
45880000        SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
45890000
45900000     END UNDERLINE_STRING_OKCMPR;
45910000    %SKIP(3);
45920000     UNDERLINE_STRING_OKLINE:
45930000     UNDERLINE_STRING_OKGLIN:
45940000     PROC;  /*FOR A SUCCESSFULL LINE TYPE COMPARISON, UNDERLINE THE LINE TYPE   */
45950000            /*FIELD IN THE LISTING LINE UNLESS THE FIELD IS ALL BLANK.          */
45960000
45970000        DCL  US_IX               FIXED BIN(15,0),   /*UNDERSCORE POSITION INDEX*/
45980000             US_PS               FIXED BIN(15,0),   /*UNDERSCORE POSITION LENGTH*/
45990000             US_LN               FIXED BIN(15,0);   /*UNDERSCORE STRING   LENGTH*/
46000000
46010000        US_IX      =  SCAN_ARRAY_ELEMENT.BEG_POS;
46020000        US_PS      =  SCAN_ARRAY_ELEMENT.POS_LEN;
46030000        US_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
46040000
46050000        IF     SUBSTR(ENTRY_LINE_DATA,US_IX,US_PS) ¬= ' ' /*IF LINETYPE FIELD NON-BLANK*/
46060000          THEN SUBSTR(ENTRY_LINE_UNDR.DATA.U_SCORE,US_IX,US_LN) = REPEAT( '_',US_LN - 1);
46070000
46080000     END UNDERLINE_STRING_OKLINE;
46090000    %SKIP(1);
46100000     END UNDERLINE_STRING_OP;
46110000    %SKIP(2);
46120000  END SMPLIST_ENTRY_LINE_UNDRLINE;
46130000 %PAGE;
46140000  SMPSCAN_ENTRY_LINE_WRITE:      /********************************************************/
46150000                                 /*                                                      */
46160000                                 /*                                                      */
46170000                                 /********************************************************/
46180000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
46190000     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);
46200000
46210000     IF    ¬(SMPSCAN(IFILE).OPEN)     THEN CALL SMPSCAN_OPEN;
46220000     ON    ENDPAGE(SMPSCAN(IFILE).FILEREF) CALL SMPSCAN_NEWPAGE;
46230000
46240000     IF       ILINE <= 001
46250000
46260000       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/
46270000         IF   (SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  <  0001)
46280000           |  (SMPSCAN(IFILE).CURR_PAGE.PAGEKEY  ¬= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)
46290000
46300000           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/
46310000             DO;
46320000               SAVE_PAGE_NO                      =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;
46330000               SMPSCAN(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;
46340000               SMPSCAN(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;
46350000               SIGNAL  ENDPAGE(SMPSCAN(IFILE).FILEREF);
46360000             END;
46370000           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/
46380000             IF LINENO(SMPSCAN(IFILE).FILEREF)      <  (SMPSCAN(IFILE).PAGE_SZ - 1)
46390000               THEN
46400000                 PUT FILE(SMPSCAN(IFILE).FILEREF)
46410000                     EDIT(' ')                        (SKIP(1),A);
46420000
46430000     PUT FILE(SMPSCAN(IFILE).FILEREF)                  SKIP(1)
46440000         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);
46450000
46460000     IF     ENTRY_LINE_UNDR.PRTCTL = '+'           /*IF A LINE OF UNDERSCORES IS PRESENT*/
46470000       THEN  PUT FILE(SMPSCAN(IFILE).FILEREF)          SKIP(0)
46480000             EDIT(STRING(ENTRY_LINE_UNDR.DATA))       (COL(001),A);
46490000
46500000     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/
46510000       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */
46520000               SMPSCAN(IFILE).CURR_NTRY          =  SMPSCAN(IFILE).CURR_PAGE  ,  BY NAME;
46530000
46540000     RETURN;                           /*TO THE CALLER OF SMPSCAN_ENTRY_LINE_WRITE*/
46550000     %PAGE;
46560000     SMPSCAN_OPEN:       /***********************************************************/
46570000                         /*THIS SUBROUTINE IS INTERNAL TO SMPSCAN_ENTRY_LINE_WRITE. */
46580000                         /*IT OPENS THE SMPSCAN DATA SET FOR THIS IFILE.            */
46590000                         /***********************************************************/
46600000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSCAN_OPEN               */
46610000
46620000          OPEN   FILE(SMPSCAN(IFILE).FILEREF) OUTPUT
46630000                 PAGESIZE(SMPSCAN(IFILE).PAGE_SZ) LINESIZE(SMPSCAN(IFILE).LINE_SZ)
46640000                 TITLE(SMPSCAN(IFILE).DDNAME);
46650000
46660000          SMPSCAN(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
46670000
46680000       END SMPSCAN_OPEN;
46690000     %SKIP(3);
46700000     SMPSCAN_NEWPAGE:
46710000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_NEWPAGE*/
46720000
46730000          SMPSCAN_TITLE1_MAP_ADDR = ADDR(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA);
46740000
46750000          IF LINENO(SMPSCAN(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSCAN(IFILE).FILEREF) PAGE;
46760000          SMPSCAN(IFILE).CURR_PAGE.PAGE_NO = SMPSCAN(IFILE).CURR_PAGE.PAGE_NO + 1;
46770000
46780000          SMPSCAN_TITLE1_MAP.ESMPLIST =  'SMPSCAN';
46790000          SMPSCAN_TITLE1_MAP.PAGE_NO  =  SMPSCAN(IFILE).CURR_PAGE.PAGE_NO;
46800000
46810000          PUT FILE(SMPSCAN(IFILE).FILEREF)
46820000              EDIT(SMPSCAN(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)
46830000                  (' ')                                   (SKIP(1),A)
46840000                  (SMPSCAN(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)
46850000                  (' ')                                   (SKIP(1),A)
46860000                  (' ')                                   (SKIP(1),A)
46870000                  (SMPSCAN(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)
46880000                  (' ')                                   (SKIP(1),A);
46890000
46900000       END SMPSCAN_NEWPAGE;
46910000      %SKIP(3);
46920000  END SMPSCAN_ENTRY_LINE_WRITE;
46930000 %PAGE;
46940000  SMPSOUT_ENTRY_LINE_WRITE:      /********************************************************/
46950000                                 /*                                                      */
46960000                                 /*                                                      */
46970000                                 /********************************************************/
46980000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
46990000     DCL   SAVE_PAGE_NO          FIXED BINARY(31,0);
47000000
47010000     IF    ¬(SMPSOUT(IFILE).OPEN)     THEN CALL SMPSOUT_OPEN;
47020000     ON    ENDPAGE(SMPSOUT(IFILE).FILEREF) CALL SMPSOUT_NEWPAGE;
47030000
47040000     IF       ILINE <= 001
47050000
47060000       THEN                            /*IF THIS IS THE FIRST LINE OF A NEW ENTRY*/
47070000         IF   (SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  <  0001)
47080000           |  (SMPSOUT(IFILE).CURR_PAGE.PAGEKEY  ¬= SMPLIST(IFILE).CURR_NTRY.PAGEKEY)
47090000
47100000           THEN           /*IF FIRST PAGE OF OUTPUT, OR FIRST ENTRY OF A NEW TYPE*/
47110000             DO;
47120000               SAVE_PAGE_NO                      =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;
47130000               SMPSOUT(IFILE).CURR_PAGE          =  SMPLIST(IFILE).CURR_NTRY  ,  BY NAME;
47140000               SMPSOUT(IFILE).CURR_PAGE.PAGE_NO  =  SAVE_PAGE_NO;
47150000               SIGNAL  ENDPAGE(SMPSOUT(IFILE).FILEREF);
47160000             END;
47170000           ELSE         /*IF NOT FIRST PAGE OF OUTPUT, AND NOT FIRST ENTRY OF A NEW TYPE*/
47180000             IF LINENO(SMPSOUT(IFILE).FILEREF)      <  (SMPSOUT(IFILE).PAGE_SZ - 1)
47190000               THEN
47200000                 PUT FILE(SMPSOUT(IFILE).FILEREF)
47210000                     EDIT(' ')                        (SKIP(1),A);
47220000
47230000     PUT FILE(SMPSOUT(IFILE).FILEREF)                  SKIP(1)
47240000         EDIT(ENTRY_LINE_DATA)                        (COL(001),A);
47250000
47260000     IF       ILINE <= 001             /*IF THIS IS THE FIRST LINE OF A NEW ENTRY,*/
47270000       THEN                            /*SAVE LOCATOR INFORMATION FOR SMPDCTRY.   */
47280000               SMPSOUT(IFILE).CURR_NTRY          =  SMPSOUT(IFILE).CURR_PAGE  ,  BY NAME;
47290000
47300000     RETURN;                           /*TO THE CALLER OF SMPSOUT_ENTRY_LINE_WRITE*/
47310000     %PAGE;
47320000     SMPSOUT_OPEN:       /***********************************************************/
47330000                         /*THIS SUBROUTINE IS INTERNAL TO SMPSOUT_ENTRY_LINE_WRITE. */
47340000                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */
47350000                         /***********************************************************/
47360000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPSOUT_OPEN               */
47370000
47380000          OPEN   FILE(SMPSOUT(IFILE).FILEREF) OUTPUT
47390000                 PAGESIZE(SMPSOUT(IFILE).PAGE_SZ) LINESIZE(SMPSOUT(IFILE).LINE_SZ)
47400000                 TITLE(SMPSOUT(IFILE).DDNAME);
47410000
47420000          SMPSOUT(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
47430000
47440000       END SMPSOUT_OPEN;
47450000     %SKIP(3);
47460000     SMPSOUT_NEWPAGE:
47470000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_NEWPAGE*/
47480000
47490000          SMPSOUT_TITLE1_MAP_ADDR = ADDR(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA);
47500000
47510000          IF LINENO(SMPSOUT(IFILE).FILEREF) > 1 THEN PUT FILE(SMPSOUT(IFILE).FILEREF) PAGE;
47520000          SMPSOUT(IFILE).CURR_PAGE.PAGE_NO = SMPSOUT(IFILE).CURR_PAGE.PAGE_NO + 1;
47530000
47540000          SMPSOUT_TITLE1_MAP.PAGE_NO  =  SMPSOUT(IFILE).CURR_PAGE.PAGE_NO;
47550000
47560000          PUT FILE(SMPSOUT(IFILE).FILEREF)
47570000              EDIT(SMPSOUT(IFILE).CURR_PAGE.TITLE1_DATA)  (COL(001),A)
47580000                  (' ')                                   (SKIP(1),A)
47590000                  (SMPSOUT(IFILE).CURR_PAGE.TITLE2_DATA)  (SKIP(1),A)
47600000                  (' ')                                   (SKIP(1),A)
47610000                  (' ')                                   (SKIP(1),A)
47620000                  (SMPSOUT(IFILE).CURR_PAGE.TITLE3_DATA)  (SKIP(1),A)
47630000                  (' ')                                   (SKIP(1),A);
47640000
47650000       END SMPSOUT_NEWPAGE;
47660000      %SKIP(3);
47670000  END SMPSOUT_ENTRY_LINE_WRITE;
47680000 %PAGE;
47690000  SMPDATA_ENTRY_LINE_WRITE:      /********************************************************/
47700000                                 /*                                                      */
47710000                                 /*                                                      */
47720000                                 /********************************************************/
47730000  PROC;                          /*IFILE, ILINE, & ENTRY_LINE_DATA_ADDR ARE SET ON ENTRY */
47740000
47750000     IF    ¬(SMPDATA(IFILE).OPEN)     THEN CALL SMPDATA_OPEN;
47760000
47770000     IF   (DATA_OUTPUT_OPTION(IFILE) = 'ID1'    &  ILINE = 001)   /*IF LINE TO BE WRITTEN*/
47780000        | (DATA_OUTPUT_OPTION(IFILE) = 'ID'     &  ILINE = 001)
47790000        | (DATA_OUTPUT_OPTION(IFILE) = 'SELECT' & (ILINE = 001 | ENTRY_LINE_SELECT))
47800000        | (DATA_OUTPUT_OPTION(IFILE) = 'ALL')
47810000
47820000       THEN           /*FORMAT THE LINE BASED ON TYPE OF ENTRY, AND LINETYPE WITHIN ENTRY*/
47830000
47840000         SELECT(ENTRY_NTRYINDX);     /*DETERMINE FORMATTING BY TYPE OF ENTRY AND LINETYPE*/
47850000
47860000           WHEN(ENTRY_INDEX('ASSEM'))             /*ENTRY TYPE = ASSEMBLER*/
47870000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));
47880000               WHEN('ASSEMBLER INPUT')        CALL WRITE_DATA_FORMAT2_LINE;
47890000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
47900000             END;               /*END OF ASSEM      ENTRY_LINE_LINETYPE SELECT GROUP*/
47910000
47920000           WHEN(ENTRY_INDEX('LMOD'))              /*ENTRY TYPE = LOAD MODULE*/
47930000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,012));
47940000               WHEN('LKED CONTROL')           CALL WRITE_DATA_FORMAT2_LINE;
47950000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
47960000             END;               /*END OF LMOD       ENTRY_LINE_LINETYPE SELECT GROUP*/
47970000
47980000           WHEN(ENTRY_INDEX('SYSMOD'))            /*ENTRY TYPE = SYSMOD*/
47990000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,004));
48000000               WHEN('HOLD')                   CALL WRITE_DATA_FORMAT3_LINE;
48010000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
48020000             END;               /*END OF SYSMOD     ENTRY_LINE_LINETYPE SELECT GROUP*/
48030000
48040000           WHEN(ENTRY_INDEX('M.C.S.'))            /*ENTRY TYPE = M.C.S.*/
48050000                                              CALL WRITE_DATA_FORMAT2_LINE;
48060000
48070000           OTHERWISE                              /*ENTRY TYPE = ALL OTHERS*/
48080000             SELECT(SUBSTR(ENTRY_LINE_LINETYPE,001,015));
48090000               WHEN('SYSMOD HISTORY')         CALL WRITE_DATA_FORMAT4_LINE;
48100000               OTHERWISE                      CALL WRITE_DATA_FORMAT1_LINE;
48110000             END;               /*END OF OTHERWISE  ENTRY_LINE_LINETYPE SELECT GROUP*/
48120000
48130000         END;                   /*END OF ENTRY_NTRYINDX                 SELECT GROUP*/
48140000     RETURN;
48150000     %PAGE;
48160000     SMPDATA_OPEN:       /***********************************************************/
48170000                         /*THIS SUBROUTINE IS INTERNAL TO SMPDATA_ENTRY_LINE_WRITE. */
48180000                         /*IT OPENS THE SMPSOUT DATA SET FOR THIS IFILE.            */
48190000                         /***********************************************************/
48200000       PROC;             /*IFILE IS SET PRIOR TO CALLING SMPDATA_OPEN               */
48210000
48220000          OPEN   FILE(SMPDATA(IFILE).FILEREF) OUTPUT
48230000                 LINESIZE(SMPDATA(IFILE).LINE_SZ)
48240000                 TITLE(SMPDATA(IFILE).DDNAME);
48250000
48260000          SMPDATA(IFILE).OPEN    =   '1'B;          /*INDICATE FILE IS OPEN*/
48270000
48280000       END SMPDATA_OPEN;
48290000    %PAGE;
48300000     WRITE_DATA_FORMAT1_LINE:
48310000     PROC;
48320000
48330000        DCL  LDATA          FIXED BIN(15,0),         /*DATA RECORD # FOR CURRENT LINE*/
48340000             LPOS(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,069,109),
48350000             LGTH(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(068,040,012),
48360000             LCOL(001:003)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029,029);
48370000
48380000        DO   LDATA = 001 TO 003;
48390000          IF    (SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA))  ¬= ' ')
48400000            &  ((DATA_OUTPUT_OPTION(IFILE) ¬= 'ID1') | (LDATA = 001))
48410000            THEN
48420000              DO;
48430000                SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
48440000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(LDATA),LGTH(LDATA)) =
48450000                                          SUBSTR(ENTRY_LINE_DATA,LPOS(LDATA),LGTH(LDATA));
48460000
48470000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
48480000                SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
48490000
48500000                SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
48510000
48520000                PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
48530000                    EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
48540000                        (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
48550000
48560000                IF   ((LDATA = 001) & (ILINE = 001))
48570000                  THEN
48580000                         SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
48590000
48600000              END;
48610000        END;                    /*END OF LDATA DO GROUP*/
48620000
48630000     END WRITE_DATA_FORMAT1_LINE;
48640000    %PAGE;
48650000     WRITE_DATA_FORMAT2_LINE:
48660000     PROC;
48670000
48680000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),
48690000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,072),
48700000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);
48710000
48720000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ¬= ' ')
48730000          THEN
48740000            DO;
48750000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
48760000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
48770000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
48780000
48790000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
48800000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
48810000
48820000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
48830000
48840000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
48850000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
48860000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
48870000
48880000              IF      (ILINE = 001)
48890000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
48900000
48910000            END;
48920000
48930000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ¬= ' ')
48940000            &   (DATA_OUTPUT_OPTION(IFILE) ¬= 'ID1')
48950000          THEN
48960000            DO;
48970000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
48980000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
48990000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
49000000
49010000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
49020000
49030000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
49040000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
49050000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
49060000
49070000            END;
49080000
49090000     END WRITE_DATA_FORMAT2_LINE;
49100000    %PAGE;
49110000     WRITE_DATA_FORMAT3_LINE:
49120000     PROC;
49130000
49140000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,039),
49150000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(038,072),
49160000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,001);
49170000
49180000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ¬= ' ')
49190000          THEN
49200000            DO;
49210000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
49220000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
49230000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
49240000
49250000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
49260000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
49270000
49280000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
49290000
49300000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
49310000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
49320000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
49330000
49340000              IF      (ILINE = 001)
49350000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
49360000
49370000            END;
49380000
49390000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ¬= ' ')
49400000            &   (DATA_OUTPUT_OPTION(IFILE) ¬= 'ID1')
49410000          THEN
49420000            DO;
49430000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
49440000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
49450000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
49460000
49470000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
49480000
49490000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
49500000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
49510000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
49520000
49530000            END;
49540000
49550000     END WRITE_DATA_FORMAT3_LINE;
49560000    %PAGE;
49570000     WRITE_DATA_FORMAT4_LINE:
49580000     PROC;
49590000
49600000        DCL  LPOS(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,029),
49610000             LGTH(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(028,065),
49620000             LCOL(001:002)  FIXED BIN(15,0) STATIC INTERNAL INIT(001,004);
49630000
49640000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001))  ¬= ' ')
49650000          THEN
49660000            DO;
49670000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
49680000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(001),LGTH(001)) =
49690000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(001),LGTH(001));
49700000
49710000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,009,002)  = '/*';
49720000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
49730000
49740000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
49750000
49760000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
49770000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
49780000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
49790000
49800000              IF      (ILINE = 001)
49810000                THEN   SMPDATA(IFILE).CURR_NTRY = SMPDATA(IFILE).CURR_CARD, BY NAME;
49820000
49830000            END;
49840000
49850000        IF      (SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002))  ¬= ' ')
49860000            &   (DATA_OUTPUT_OPTION(IFILE) ¬= 'ID1')
49870000          THEN
49880000            DO;
49890000              SMPDATA(IFILE).CURR_CARD.DATA    = ' ';    /*CLEAR OUTPUT AREA TO BLANKS*/
49900000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,LCOL(002),LGTH(002)) =
49910000                                        SUBSTR(ENTRY_LINE_DATA,LPOS(002),LGTH(002));
49920000
49930000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,002,002)  = '/*';
49940000              SUBSTR(SMPDATA(IFILE).CURR_CARD.DATA,069,002)  = '*/';
49950000
49960000              SMPDATA(IFILE).CURR_CARD.SEQ_NO  =  SMPDATA(IFILE).CURR_CARD.SEQ_NO + 100;
49970000
49980000              PUT FILE(SMPDATA(IFILE).FILEREF)              SKIP(1)
49990000                  EDIT(SMPDATA(IFILE).CURR_CARD.DATA)      (COL(001),A)
50000000                      (SMPDATA(IFILE).CURR_CARD.SEQ_NO)    (P'99999999');
50010000
50020000            END;
50030000
50040000     END WRITE_DATA_FORMAT4_LINE;
50050000    %SKIP (1);
50060000  END SMPDATA_ENTRY_LINE_WRITE;
50070000  %SKIP(2);
50080000  END SMPLIST_ENTRY_WRITE;
50090000 %PAGE;
50100000  SMPLIST_SCAN_LINE_DATA:     /********************************************************/
50110000                              /*SCAN THE CURRENT LINE AND RETURN ROW RESULTS.         */
50120000                              /*THIS SUBROUTINE IS CALLED FROM BOTH                   */
50130000                              /*SMPLIST_ENTRY_LINE_SCAN IN SMPLIST_ENTRY_READ, AND    */
50140000                              /*SMPLIST_ENTRY_LINE_UNDRLINE IN SMPLIST_ENTRY_WRITE.   */
50150000                              /********************************************************/
50160000  PROC(ENTRY_NTRYINDX,            /*IFILE, IPLANE, IROW ARE SET PRIOR TO ENTRY.       */
50170000       ENTRY_LINE_LINETYPE,
50180000       ENTRY_LINE_DATA)             RETURNS(BIT(01));
50190000     DCL    ENTRY_NTRYINDX          FIXED BIN(15,0),
50200000            ENTRY_LINE_LINETYPE     CHAR(*),
50210000            ENTRY_LINE_DATA         CHAR(*),
50220000         01 SCAN_ARRAY_ELEMENT      BASED(SCAN_ARRAY_ELEMENT_ADDR)
50230000                                     LIKE SCAN_ARRAY.PLANE.ROW.COL,
50240000            LINE_SCAN_RESULT        BIT(1);
50250000    %PAGE;
50260000     IF   SMPLIST(IFILE).SCAN_CUBE.PLANE(IPLANE).ROW(IROW).ACTIVE
50270000       THEN
50280000         DO;                 /*ALL ACTIVE COLUMNS IN A ROW MUST MATCH ON THE SAME LINE*/
50290000             LINE_SCAN_RESULT = '1'B;
50300000             DO    ICOL  = ICOL_MIN   TO ICOL_MAX   WHILE(LINE_SCAN_RESULT);
50310000               SCAN_ARRAY_ELEMENT_ADDR
50320000                   = ADDR(SCAN_ARRAY(IFILE).PLANE(IPLANE).ROW(IROW).COL(ICOL));
50330000               IF (SCAN_ARRAY_ELEMENT.STR_LEN > 0)                 /*IF STRING SUPPLIED*/
50340000                 THEN
50350000                   SELECT(SCAN_ARRAY_ELEMENT.OP_OIX);
50360000                     WHEN(12) /* EQENTRY */   LINE_SCAN_RESULT =  RESULT_STRING_NTRY;
50370000                     WHEN(13) /* NEENTRY */   LINE_SCAN_RESULT = ¬RESULT_STRING_NTRY;
50380000
50390000                     WHEN(22) /* EQLINE  */   LINE_SCAN_RESULT =  RESULT_STRING_LINE;
50400000                     WHEN(23) /* NELINE  */   LINE_SCAN_RESULT = ¬RESULT_STRING_LINE;
50410000
50420000                     WHEN(32) /* EQGLINE */   LINE_SCAN_RESULT =  RESULT_STRING_GLIN;
50430000                     WHEN(33) /* NEGLINE */   LINE_SCAN_RESULT = ¬RESULT_STRING_GLIN;
50440000
50450000                     WHEN(42) /* EQSCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN >  0);
50460000                     WHEN(43) /* NESCAN  */   LINE_SCAN_RESULT = (RESULT_STRING_SCAN <= 0);
50470000
50480000                     WHEN(52) /* EQGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN >  0);
50490000                     WHEN(53) /* NEGSCAN */   LINE_SCAN_RESULT = (RESULT_STRING_GSCN <= 0);
50500000
50510000                     WHEN(60) /* LTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <  0);
50520000                     WHEN(61) /* LECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR <= 0);
50530000                     WHEN(62) /* EQCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR =  0);
50540000                     WHEN(63) /* NECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR ¬= 0);
50550000                     WHEN(64) /* GECMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >= 0);
50560000                     WHEN(65) /* GTCMPR  */   LINE_SCAN_RESULT = (RESULT_STRING_CMPR >  0);
50570000
50580000                     WHEN(72) /* EQGCMPR */   LINE_SCAN_RESULT =  RESULT_STRING_GCPR;
50590000                     WHEN(73) /* NEGCMPR */   LINE_SCAN_RESULT = ¬RESULT_STRING_GCPR;
50600000                   END;    /*END OF SELECT GROUP ON SCAN_ARRAY_ELEMENT.OP_OIX*/
50610000             END;          /*END OF ICOL   DO GROUP*/
50620000         END;            /*END OF ACTIVE IROW DO GROUP*/
50630000       ELSE  LINE_SCAN_RESULT = '0'B;
50640000     RETURN (LINE_SCAN_RESULT);               /*TO THE CALLER OF SCAN_ENTRY_LINE*/
50650000    %PAGE;
50660000     RESULT_STRING_NTRY:
50670000     PROC RETURNS(BIT(1));
50680000            /*COMPARE THE ENTRY TYPE FOR THE CURRENT ENTRY                      */
50690000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
50700000            /*INDICATING THE RESULT OF THE COMPARE:                             */
50710000
50720000        IF  (ENTRY_NTRYINDX = SCAN_ARRAY_ELEMENT.STR_NIX)
50730000
50740000          THEN RETURN('1'B);                /*SAME ENTRY TYPE*/
50750000          ELSE RETURN('0'B);                /*DIFF ENTRY TYPE*/
50760000
50770000     END RESULT_STRING_NTRY;
50780000    %SKIP(2);
50790000     RESULT_STRING_LINE:
50800000     PROC RETURNS(BIT(1));
50810000            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */
50820000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
50830000            /*INDICATING THE RESULT OF THE COMPARE:                             */
50840000
50850000        IF     SUBSTR(ENTRY_LINE_LINETYPE,001,SCAN_ARRAY_ELEMENT.STR_LEN)
50860000           =   SCAN_ARRAY_ELEMENT.STRING
50870000
50880000          THEN RETURN('1'B);                /*SAME LINE TYPE*/
50890000          ELSE RETURN('0'B);                /*DIFF LINE TYPE*/
50900000
50910000     END RESULT_STRING_LINE;
50920000    %SKIP(2);
50930000     RESULT_STRING_GLIN:
50940000     PROC RETURNS(BIT(1));
50950000            /*COMPARE THE LINE TYPE FOR THE CURRENT LINE                        */
50960000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
50970000            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */
50980000            /*                      1: GENERIC COMPARE SUCCESSFUL               */
50990000            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */
51000000
51010000        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_LINETYPE,
51020000                               001,
51030000                               SCAN_ARRAY_ELEMENT.STR_LEN
51040000                              ),
51050000                        SCAN_ARRAY_ELEMENT.STRING
51060000                       )
51070000              );
51080000
51090000     END RESULT_STRING_GLIN;
51100000    %PAGE;
51110000     RESULT_STRING_SCAN:
51120000     PROC RETURNS(FIXED BIN(15,0));
51130000            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */
51140000            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/
51150000            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */
51160000
51170000        DCL STRING_INDEX            FIXED BIN(15,0);
51180000
51190000        STRING_INDEX = INDEX(SUBSTR(ENTRY_LINE_DATA,
51200000                                    SCAN_ARRAY_ELEMENT.BEG_POS,
51210000                                    SCAN_ARRAY_ELEMENT.POS_LEN
51220000                                   ),
51230000                             SCAN_ARRAY_ELEMENT.STRING
51240000                            );
51250000
51260000        IF     STRING_INDEX > 0            /*ADJUST VALUE TO THE BEGINNING OF THE LINE*/
51270000          THEN
51280000               STRING_INDEX = STRING_INDEX + SCAN_ARRAY_ELEMENT.BEG_POS - 1;
51290000        RETURN(STRING_INDEX);
51300000
51310000     END RESULT_STRING_SCAN;
51320000    %SKIP(2);
51330000     RESULT_STRING_GSCN:
51340000     PROC RETURNS(FIXED BIN(15,0));
51350000            /*SCAN THE INPUT LINE BETWEEN THE BEGIN AND END SCAN POSITIONS         */
51360000            /*FOR THE SEARCH STRING AND RETURN THE STRING LOCATION (1ST OCCURRENCE)*/
51370000            /*RELATIVE TO THE BEGINNING OF THE LINE:                               */
51380000
51390000        DCL STRING_INDEX         FIXED BIN(15,0),
51400000            GS_IX                FIXED BIN(15,0),  /*GENERIC SCAN POSITION INDEX*/
51410000            GS_LN                FIXED BIN(15,0);  /*GENERIC SCAN STRING  LENGTH*/
51420000
51430000        STRING_INDEX  = 0;
51440000        GS_LN      =  SCAN_ARRAY_ELEMENT.STR_LEN;
51450000
51460000        DO   GS_IX =  SCAN_ARRAY_ELEMENT.BEG_POS
51470000               TO    (SCAN_ARRAY_ELEMENT.END_POS - GS_LN + 1)
51480000                WHILE(STRING_INDEX=0);
51490000
51500000          IF GCOMPARE(SUBSTR(ENTRY_LINE_DATA,GS_IX,GS_LN),
51510000                      SCAN_ARRAY_ELEMENT.STRING)
51520000
51530000            THEN      STRING_INDEX  =  GS_IX;
51540000        END;
51550000
51560000        RETURN(STRING_INDEX);
51570000
51580000     END RESULT_STRING_GSCN;
51590000    %PAGE;
51600000     RESULT_STRING_CMPR:
51610000     PROC RETURNS(FIXED BIN(15,0));
51620000            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */
51630000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BINARY       */
51640000            /*FIXED POINT VALUE INDICATING THE RESULT OF THE COMPARE:           */
51650000            /*                     -1: INPUT LINE DATA < STRING                 */
51660000            /*                      0: INPUT LINE DATA = STRING                 */
51670000            /*                     +1: INPUT LINE DATA > STRING                 */
51680000
51690000        IF          SUBSTR(ENTRY_LINE_DATA,
51700000                           SCAN_ARRAY_ELEMENT.BEG_POS,
51710000                           SCAN_ARRAY_ELEMENT.STR_LEN
51720000                          )
51730000                 <  SCAN_ARRAY_ELEMENT.STRING
51740000          THEN             RETURN(-1);                            /*LESS THAN*/
51750000          ELSE IF   SUBSTR(ENTRY_LINE_DATA,
51760000                           SCAN_ARRAY_ELEMENT.BEG_POS,
51770000                           SCAN_ARRAY_ELEMENT.STR_LEN
51780000                          )
51790000                 =  SCAN_ARRAY_ELEMENT.STRING
51800000                 THEN      RETURN(0);                             /*EQUAL TO*/
51810000                 ELSE      RETURN(+1);                            /*GREATER THAN*/
51820000
51830000     END RESULT_STRING_CMPR;
51840000    %SKIP(3);
51850000     RESULT_STRING_GCPR:
51860000     PROC RETURNS(BIT(1));
51870000            /*COMPARE THE INPUT LINE STARTING AT THE BEGIN POSITION             */
51880000            /*AGAINST THE SCAN_ARRAY CHARACTER STRING AND RETURN A BIT VALUE    */
51890000            /*INDICATING THE RESULT OF THE GENERIC COMPARE:                     */
51900000            /*                      1: GENERIC COMPARE SUCCESSFUL               */
51910000            /*                      0: GENERIC COMPARE UNSUCCESSFUL             */
51920000
51930000        RETURN(GCOMPARE(SUBSTR(ENTRY_LINE_DATA,
51940000                               SCAN_ARRAY_ELEMENT.BEG_POS,
51950000                               SCAN_ARRAY_ELEMENT.STR_LEN
51960000                              ),
51970000                        SCAN_ARRAY_ELEMENT.STRING
51980000                       )
51990000              );
52000000
52010000     END RESULT_STRING_GCPR;
52020000    %SKIP(3);
52030000  END SMPLIST_SCAN_LINE_DATA;
52040000 %PAGE;
52050000 SMPLIST_WRAPUP:           /*************************************************************/
52060000                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */
52070000                           /*   AND CALCULATE VALUES FOR FINAL TOTALS.                  */
52080000                           /*************************************************************/
52090000  PROC;
52100000     DO    IFILE = IFILE_MIN TO IFILE_MAX;
52110000       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/
52120000         THEN
52130000           DO;
52140000             DO  NTRYINDX_IX = NTRYINDX_MIN TO NTRYINDX_MAX;
52150000               IF (SMPLIST(IFILE).ENTRY_TOTALS(NTRYINDX_IX).ENTRY_CT >  0)
52160000                 THEN  SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND =
52170000                                      SMPLIST(IFILE).FILE_TOTALS.#_E_T_FOUND + 1;
52180000             END;     /*END OF NTRYINDX_IX DO GROUP*/
52190000           END;       /*END OF IFILE       DO GROUP*/
52200000     END;
52210000     RETURN;                      /*TO THE CALLER OF SMPLIST_WRAPUP*/
52220000  END SMPLIST_WRAPUP;
52230000 %PAGE;
52240000 SMPLIST_CLOSE:            /*************************************************************/
52250000                           /*   PERFORM FINAL INPUT FILE PROCESSING,                    */
52260000                           /*   AND CLOSE THE SMPLIST DATA SET(S).                      */
52270000                           /*************************************************************/
52280000  PROC;
52290000     DO    IFILE = IFILE_MIN TO IFILE_MAX;
52300000       IF (SMPLIST(IFILE).ACTIVE)             /*IF THE INPUT FILE WAS ACTIVE*/
52310000         THEN
52320000           DO;
52330000             CLOSE FILE(SMPLIST(IFILE).FILEREF) ENV(LEAVE);
52340000             IF  SMPSCAN(IFILE).OPEN THEN CALL SMPSCAN_CLOSE;
52350000             IF  SMPSOUT(IFILE).OPEN THEN CALL SMPSOUT_CLOSE;
52360000             IF  SMPDATA(IFILE).OPEN THEN CALL SMPDATA_CLOSE;
52370000           END;
52380000     END;
52390000     RETURN;                      /*TO THE CALLER OF SMPLIST_CLOSE*/
52400000     %SKIP(2);
52410000     SMPSCAN_CLOSE:
52420000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSCAN_CLOSE*/
52430000          CLOSE  FILE(SMPSCAN(IFILE).FILEREF) ENV(LEAVE);
52440000          SMPSCAN(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
52450000       END SMPSCAN_CLOSE;
52460000     %SKIP(2);
52470000     SMPSOUT_CLOSE:
52480000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPSOUT_CLOSE*/
52490000          CLOSE  FILE(SMPSOUT(IFILE).FILEREF) ENV(LEAVE);
52500000          SMPSOUT(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
52510000       END SMPSOUT_CLOSE;
52520000     %SKIP(2);
52530000     SMPDATA_CLOSE:
52540000       PROC;                      /*IFILE IS SET PRIOR TO CALLING SMPDATA_CLOSE*/
52550000          CLOSE  FILE(SMPDATA(IFILE).FILEREF) ENV(LEAVE);
52560000          SMPDATA(IFILE).OPEN    =   '0'B;          /*INDICATE FILE IS NO LONGER OPEN*/
52570000       END SMPDATA_CLOSE;
52580000  %SKIP(5);
52590000  END SMPLIST_CLOSE;
52600000 %PAGE;
52610000 ZONE_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE TYPE OF ZONE TO                    */
52620000              /*A BINARY SUBSCRIPT THAT CAN BE SORTED TO PRODUCE                  */
52630000              /*THE ORDER:  GLOBAL < DLIB < TARGET.                               */
52640000    PROC(ZONETYPE)                    /*RECEIVES THE ZONE TYPE IN EBCDIC          */
52650000        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */
52660000        DCL  ZONETYPE CHAR(*);
52670000        SELECT(TRIM(ZONETYPE));
52680000           WHEN('GLOBAL')               RETURN(1);   /*GLOBAL  ZONE               */
52690000           WHEN('DLIB')                 RETURN(2);   /*DLIB    ZONE               */
52700000           WHEN('TARGET')               RETURN(3);   /*TARGET  ZONE               */
52710000           OTHERWISE                    RETURN(0);   /*UNKNOWN ZONE TYPE          */
52720000        END;
52730000    END ZONE_INDEX;
52740000 %SKIP(3);
52750000 ZONE_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */
52760000              /*"ZONE_INDEX" FUNCTION AND RETURN THE ZONE TYPE NAME               */
52770000              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */
52780000    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */
52790000        RETURNS(CHAR(007) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */
52800000        DCL    ZONEINDX        FIXED BINARY(15,0);
52810000        SELECT(ZONEINDX);
52820000           WHEN(0)             RETURN('UNKNOWN');    /*UNKNOWN ZONE INDEX         */
52830000           WHEN(1)             RETURN('GLOBAL');     /*GLOBAL  ZONE INDEX         */
52840000           WHEN(2)             RETURN('DLIB');       /*DLIB    ZONE INDEX         */
52850000           WHEN(3)             RETURN('TARGET');     /*TARGET  ZONE INDEX         */
52860000           OTHERWISE           RETURN('INVALID');    /*INVALID ZONE INDEX         */
52870000        END;
52880000    END ZONE_TYPE;
52890000 %SKIP(3);
52900000 ZONE_TYPE_C: /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                 */
52910000              /*"ZONE_INDEX" FUNCTION AND RETURN A ONE-CHARACTER ZONE TYPE        */
52920000              /*CORRESPONDING TO THE ZONE INDEX SUBSCRIPT.                        */
52930000    PROC(ZONEINDX)                    /*RECEIVES THE ZONE INDEX IN BINARY         */
52940000        RETURNS(CHAR(001));           /*RETURNS A ONE_BYTE CHARACTER VALUE:       */
52950000        DCL    ZONEINDX        FIXED BINARY(15,0);
52960000        SELECT(ZONEINDX);
52970000           WHEN(0)             RETURN('U');          /*UNKNOWN ZONE INDEX         */
52980000           WHEN(1)             RETURN('G');          /*GLOBAL  ZONE INDEX         */
52990000           WHEN(2)             RETURN('D');          /*DLIB    ZONE INDEX         */
53000000           WHEN(3)             RETURN('T');          /*TARGET  ZONE INDEX         */
53010000           OTHERWISE           RETURN('?');          /*INVALID ZONE INDEX         */
53020000        END;
53030000    END ZONE_TYPE_C;
53040000 %PAGE;
53050000 ENTRY_INDEX:  /*FUNCTION SUBROUTINE TO MAP THE LISTED ENTRY TYPE TO              */
53060000               /*A BINARY SUBSCRIPT THAT IS IN ASCENDING ORDER                    */
53070000               /*CORRESPONDING TO THE ORDER THAT ENTRIES ARE LISTED               */
53080000               /*ON THE SMPLIST REPORT PRODUCED BY SMP/E.                         */
53090000    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */
53100000        RETURNS(FIXED BINARY(15,0));  /*RETURNS A BINARY NUMERIC VALUE:           */
53110000
53120000        DCL  NTRYTYPE          CHAR(*) VAR;
53130000
53140000        SELECT(ENTRY_TYPE_TRIM(NTRYTYPE));
53150000           WHEN('ZONE','GZONE','DZONE','TZONE')  RETURN(01);  /*ZONE     ENTRY    */
53160000           WHEN('OPTIONS')                       RETURN(02);  /*OPTIONS  ENTRY    */
53170000           WHEN('UTILITY')                       RETURN(03);  /*UTILITY  ENTRY    */
53180000           WHEN('FMIDSET')                       RETURN(04);  /*FMIDSET  ENTRY    */
53190000           WHEN('DDDEF')                         RETURN(05);  /*DDDEF    ENTRY    */
53200000           WHEN('ZONESET')                       RETURN(06);  /*ZONESET  ENTRY    */
53210000           WHEN('ASSEM','ASSEMBLER')             RETURN(07);  /*ASSEM    ENTRY    */
53220000           WHEN('LMOD','LOAD MODULE')            RETURN(08);  /*LMOD     ENTRY    */
53230000           WHEN('MAC','MACRO')                   RETURN(09);  /*MACRO    ENTRY    */
53240000           WHEN('MOD','MODULE')                  RETURN(10);  /*MODULE   ENTRY    */
53250000           WHEN('SRC','SOURCE')                  RETURN(11);  /*SOURCE   ENTRY    */
53260000           WHEN('DLIB')                          RETURN(12);  /*DLIB     ENTRY    */
53270000           WHEN('SYSMOD','HOLDDATA')             RETURN(13);  /*SYSMOD / HOLDDATA */
53280000           WHEN('M.C.S.')                        RETURN(14);  /*M.C.S.   ENTRY    */
53290000           OTHERWISE                             RETURN(00);  /*UNKNOWN  ENTRY    */
53300000        END;
53310000    END ENTRY_INDEX;
53320000 %PAGE;
53330000 ENTRY_TYPE:   /*FUNCTION SUBROUTINE TO REVERSE THE MAPPING OF THE                */
53340000               /*"ENTRY_INDEX" FUNCTION AND RETURN THE ENTRY TYPE NAME            */
53350000               /*CORRESPONDING TO THE ENTRY INDEX SUBSCRIPT.                      */
53360000    PROC(NTRYINDX)                    /*RECEIVES THE ENTRY INDEX IN BINARY        */
53370000        RETURNS(CHAR(016) VAR);       /*RETURNS A CHARACTER STRING VALUE:         */
53380000
53390000        DCL    NTRYINDX         FIXED BINARY(15,0);
53400000
53410000        SELECT(NTRYINDX);
53420000           WHEN(00)             RETURN('UNKNOWN');         /*UNKNOWN ENTRY INDEX  */
53430000           WHEN(01)             RETURN('ZONE');            /*ZONE    ENTRY INDEX  */
53440000           WHEN(02)             RETURN('OPTIONS');         /*OPTIONS ENTRY INDEX  */
53450000           WHEN(03)             RETURN('UTILITY');         /*UTILITY ENTRY INDEX  */
53460000           WHEN(04)             RETURN('FMIDSET');         /*FMIDSET ENTRY INDEX  */
53470000           WHEN(05)             RETURN('DDDEF');           /*DDDEF   ENTRY INDEX  */
53480000           WHEN(06)             RETURN('ZONESET');         /*ZONESET ENTRY INDEX  */
53490000           WHEN(07)             RETURN('ASSEMBLER');       /*ASSEM   ENTRY INDEX  */
53500000           WHEN(08)             RETURN('LOAD MODULE');     /*LMOD    ENTRY INDEX  */
53510000           WHEN(09)             RETURN('MACRO');           /*MACRO   ENTRY INDEX  */
53520000           WHEN(10)             RETURN('MODULE');          /*MODULE  ENTRY INDEX  */
53530000           WHEN(11)             RETURN('SOURCE');          /*SOURCE  ENTRY INDEX  */
53540000           WHEN(12)             RETURN('DLIB');            /*DLIB    ENTRY INDEX  */
53550000           WHEN(13)             RETURN('SYSMOD');          /*SYSMOD  ENTRY INDEX  */
53560000           WHEN(14)             RETURN('M.C.S.');          /*M.C.S.  ENTRY INDEX  */
53570000           OTHERWISE            RETURN('INVALID');         /*INVALID ENTRY INDEX  */
53580000        END;
53590000    END ENTRY_TYPE;
53600000 %PAGE;
53610000 ENTRY_TYPE_TRIM:   /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS,  */
53620000                    /*AND EXTRANEOUS WORDS FROM AN "ENTRY_TYPE" CHARACTER STRING. */
53630000
53640000    PROC(NTRYTYPE)                    /*RECEIVES THE ENTRY TYPE IN EBCDIC         */
53650000         RECURSIVE                    /*RETURNS A CHARACTER STRING VALUE          */
53660000         RETURNS(CHAR(064) VARYING);  /*WITH LEADING AND TRAILING BLANKS REMOVED. */
53670000
53680000       DCL  NTRYTYPE          CHAR(*)   VARYING,
53690000            NTRYTYPE_TRIM     CHAR(064) VARYING;
53700000
53710000       NTRYTYPE_TRIM  = TRIM(NTRYTYPE);    /*ELIMINATE LEADING AND TRAILING BLANKS*/
53720000
53730000       IF               LENGTH(NTRYTYPE_TRIM) >  8
53740000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-8+1) = ' ENTRIES'
53750000         THEN           NTRYTYPE_TRIM
53760000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-8));
53770000         ELSE
53780000       IF               LENGTH(NTRYTYPE_TRIM) >  6
53790000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-6+1) = ' ENTRY'
53800000         THEN           NTRYTYPE_TRIM
53810000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-6));
53820000         ELSE
53830000       IF               LENGTH(NTRYTYPE_TRIM) >  1
53840000                     &  SUBSTR(NTRYTYPE_TRIM,LENGTH(NTRYTYPE_TRIM)-1+1) = ':'
53850000         THEN           NTRYTYPE_TRIM
53860000                      = ENTRY_TYPE_TRIM(SUBSTR(NTRYTYPE_TRIM,1,LENGTH(NTRYTYPE_TRIM)-1));
53870000
53880000       RETURN(NTRYTYPE_TRIM);
53890000
53900000    END ENTRY_TYPE_TRIM;
53910000 %PAGE;
53920000 LINE_TYPE:    /*FUNCTION SUBROUTINE TO DETERMINE THE LINE TYPE CHARACTER STRING  */
53930000               /*ASSOCIATED WITH THE CURRENT SMPLIST ENTRY LISTING LINE.          */
53940000
53950000    PROC(PREV_LINETYPE,                 /*STRING FOR PREVIOUS LINETYPE            */
53960000         LINE_DATA)                     /*CURRENT ENTRY LISTING LINE              */
53970000         RETURNS(CHAR(015));            /*RETURNS THE CURRENT LINE'S LINETYPE.    */
53980000
53990000        DCL (LENGTH,MAX,MIN,SUBSTR,VERIFY)        BUILTIN,
54000000             PREV_LINETYPE           CHAR(*),
54010000             LINE_DATA               CHAR(*),
54020000             LINE_LINETYPE           CHAR(LIST_LINE_LWID),
54030000             VF_IX                   FIXED BINARY(15,0);
54040000
54050000        LINE_LINETYPE  =  SUBSTR(LINE_DATA,LIST_LINE_LBGN,LIST_LINE_LWID);
54060000
54070000        VF_IX          =  MIN(VERIFY(LINE_LINETYPE,' '),      /*LOCATE FIRST NON_BLANK*/
54080000                              LENGTH(PREV_LINETYPE) + 1);     /*AND TEST FOR ALL BLANK*/
54090000
54100000        SELECT;                             /*SELECT TO TEST THE VALUE OF VF_IX*/
54110000          WHEN(VF_IX < 1) LINE_LINETYPE = PREV_LINETYPE; /*LINE_LINETYPE IS  ALL BLANKS*/
54120000          WHEN(VF_IX = 1);                        /*LINE_LINETYPE HAS NO LEADING BLANKS*/
54130000          WHEN(VF_IX > 1) LINE_LINETYPE =         /*LINE_LINETYPE HAS    LEADING BLANKS*/
54140000                                   SUBSTR(PREV_LINETYPE,1,VF_IX-1)     /*MERGE PREVIOUS*/
54150000                                || SUBSTR(LINE_LINETYPE,VF_IX);        /*WITH  CURRENT */
54160000        END;                                /*END OF VF_IX SELECT GROUP*/
54170000
54180000        RETURN(LINE_LINETYPE);              /*NEW LINETYPE VALUE TO THE CALLER*/
54190000
54200000    END LINE_TYPE;
54210000 %PAGE;
54220000 GCOMPARE:    /****************************************************************************/
54230000              /*FUNCTION SUBROUTINE TO GENERICALLY COMPARE A CHARACTER STRING AGAINST     */
54240000              /*A PATTERN STRING AND RETURN THE RESULT AS A BIT STRING:                   */
54250000              /*EQUAL('1'B) OR NOT-EQUAL('0'B).                                           */
54260000              /*                                                                          */
54270000              /*THE CHARACTER STRING IS COMPARED CHARACTER BY CHARACTER WITH THE PATTERN  */
54280000              /*STRING, MOVING FROM LEFT TO RIGHT.  THE FIRST CHARACTER STRING CHARACTER  */
54290000              /*NOT SATISFYING THE REQUIREMENTS OF ITS CORRESPONDING PATTERN STRING       */
54300000              /*CHARACTER STOPS THE COMPARISON AND RESULTS IN A NOT-EQUAL RESULT BEING    */
54310000              /*RETURNED.  A CHARACTER STRING LONGER THAN THE PATTERN STRING IS CHECKED   */
54320000              /*TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT BEYOND THE LENGTH OF THE  */
54330000              /*PATTERN STRING ARE BLANK.  A PATTERN STRING LONGER THAN THE CHARACTER     */
54340000              /*STRING IS ALSO CHECKED TO VERIFY THAT ALL BYTES EXTENDING ON THE RIGHT    */
54350000              /*BEYOND THE LENGTH OF THE CHARACTER STRING ARE EITHER BLANK, OR THE "ANY"  */
54360000              /*CHARACTER SELECTION BYTE("*").                                            */
54370000              /*                                                                          */
54380000              /*THE FOLLOWING CHARACTERS HAVE SPECIAL SIGNIFICANCE IN PATTERN STRINGS,    */
54390000              /*AND ARE USED TO SELECT CLASSES OF CHARACTERS:                             */
54400000              /*            "*" - THE CORRESPONDING CHARACTER STRING CHARACTER CAN BE     */
54410000              /*                  ANY CHARACTER.                                          */
54420000              /*                                                                          */
54430000              /*            "#" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54440000              /*                  NUMERIC AND CAN BE EITHER UPPER OR LOWER CASE.          */
54450000              /*                                                                          */
54460000              /*            "@" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54470000              /*                  ALPHABETIC AND CAN BE EITHER UPPER OR LOWER CASE.       */
54480000              /*                                                                          */
54490000              /*            "¢" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54500000              /*                  ONE OF THE NATIONAL CHARACTERS: "$", "#", OR "@".       */
54510000              /*                  BECAUSE OF THEIR BIT REPRESENTATIONS, NATIONAL          */
54520000              /*                  CHARACTERS ARE UPPERCASE.                               */
54530000              /*                                                                          */
54540000              /*            "%" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54550000              /*                  ALPHABETIC OR ONE OF THE NATIONAL CHARACTERS.           */
54560000              /*                                                                          */
54570000              /*            "_" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54580000              /*                  ALPHABETIC, NUMERIC,  OR ONE OF THE NATIONAL CHARACTERS.*/
54590000              /*                                                                          */
54600000              /*            ">" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54610000              /*                  ONE OF THE NATIONAL CHARACTERS, OR AN UPPERCASE         */
54620000              /*                  ALPHABETIC OR NUMERIC CHARACTER.                        */
54630000              /*                                                                          */
54640000              /*            "<" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54650000              /*                  A LOWERCASE ALPHABETIC OR NUMERIC CHARACTER.            */
54660000              /*                                                                          */
54670000              /*            "!" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54680000              /*                  ONE OF THE SPECIAL CHARACTERS.                          */
54690000              /*                                                                          */
54700000              /*            "-" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54710000              /*                  NON-NUMERIC.                                            */
54720000              /*                                                                          */
54730000              /*            "¬" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54740000              /*                  NON-BLANK.                                              */
54750000              /*                                                                          */
54760000              /*            "?" - THE CORRESPONDING CHARACTER STRING CHARACTER MUST BE    */
54770000              /*                  ONE OF THE INVALID CHARACTERS.                          */
54780000              /*                                                                          */
54790000              /*ALL OTHER CHARACTERS IN A PATTERN STRING (BLANKS, ALPHABETICS, NUMERIC    */
54800000              /*DIGITS, AND ESPECIALLY THE CHARACTERS "=" "." "," ":" "$" "(" AND ")" )   */
54810000              /*REPRESENT THEMSELVES.  THE CORRESPONDING CHARACTER STRING CHARACTER MUST  */
54820000              /*BE THE SAME AS THE PATTERN CHARACTER.  EVERY ATTEMPT WAS MADE TO CHOOSE   */
54830000              /*GENERIC SELECTION CHARACTERS THAT WOULD BE UNLIKELY TO APPEAR IN THE      */
54840000              /*DATA EXCEPT WHERE TRADITION STRONGLY DICTATED OTHERWISE.                  */
54850000              /****************************************************************************/
54860000
54870000    PROC(C_STRING,                  /*CHARACTER STRING TO BE COMPARED                     */
54880000         P_STRING)                  /*PATTERN (GENERIC) CHARACTER STRING                  */
54890000         RETURNS(BIT(01));          /*RETURNS EQUAL/NOT EQUAL INDICATOR                   */
54900000
54910000        DCL (LENGTH,MAX,MIN,SIGN,SUBSTR,VERIFY)     BUILTIN,
54920000             C_STRING                  CHAR(*),            /*CHARACTER STRING PARAMETER   */
54930000             CS_IX                     FIXED BINARY(15,0), /*CHARACTER STRING INDEX VALUE */
54940000             CS_CH                     CHAR(001),          /*CHARACTER STRING CHARACTER   */
54950000             CS_CX                     FIXED BINARY(15,0), /*CHAR STRING CHAR BINARY VALUE*/
54960000             CS_LN                     FIXED BINARY(15,0), /*CHARACTER STRING LENGTH      */
54970000
54980000             P_STRING                  CHAR(*) VARYING,    /*PATTERN STRING PARAMETER     */
54990000             PS_LN                     FIXED BINARY(15,0), /*PATTERN STRING LENGTH        */
55000000
55010000             G_RESULT                  BIT(01);
55020000       %SKIP(2);
55030000        DCL     CH_TYPE_ADDR           POINTER;   /*DEFINE CH_TABLE BIT MEANINGS*/
55040000        DCL  01 CH_TYPE                BASED(CH_TYPE_ADDR),
55050000                05 INVALID             UNALIGNED     BIT(01),   /*BIT 0*/
55060000                05 UPCASE              UNALIGNED     BIT(01),   /*BIT 1*/
55070000                05 BIT2  /*RESERVED*/  UNALIGNED     BIT(01),   /*BIT 2*/
55080000                05 SPECIAL             UNALIGNED     BIT(01),   /*BIT 3*/
55090000                05 NATIONAL            UNALIGNED     BIT(01),   /*BIT 4*/
55100000                05 ALPHABETIC          UNALIGNED     BIT(01),   /*BIT 5*/
55110000                05 Z_NUM               UNALIGNED     BIT(01),   /*BIT 6*/
55120000                05 NUMERIC             UNALIGNED     BIT(01);   /*BIT 7*/
55130000       %SKIP(2);
55140000        CS_LN = LENGTH(C_STRING);
55150000        PS_LN = LENGTH(P_STRING);
55160000        G_RESULT = '1'B;                               /*INITIALIZE FOR ENTERING DO GROUP*/
55170000       %PAGE;
55180000        DO  CS_IX = 001 TO MIN(CS_LN,PS_LN) WHILE(G_RESULT);
55190000
55200000          CS_CH         =  SUBSTR(C_STRING,CS_IX,001);   /*SELECT CHARACTER FROM C_STRING*/
55210000          UNSPEC(CS_CX) = '00000000'B || UNSPEC(CS_CH);  /*CONVERT CHARACTER TO AN INDEX */
55220000          CH_TYPE_ADDR  =  ADDR(CH_TABLE(CS_CX));        /*-> ENTRY IN CHARACTER TYPE TBL*/
55230000
55240000          SELECT(SUBSTR(P_STRING,CS_IX,001));     /*CONTROL WITH PATTERN STRING CHARACTER*/
55250000            WHEN('*');                                           /*ANY CHARACTER IS VALID*/
55260000            WHEN('#') IF     ¬(CH_TYPE.NUMERIC)                  /*NUMERIC CHARACTER     */
55270000                        THEN   G_RESULT = '0'B;
55280000            WHEN('@') IF     ¬(CH_TYPE.ALPHABETIC)               /*ALPHABETIC CHARACTER  */
55290000                        THEN   G_RESULT = '0'B;
55300000            WHEN('¢') IF     ¬(CH_TYPE.NATIONAL)                  /*NATIONAL CH ($#@)    */
55310000                        THEN   G_RESULT = '0'B;
55320000            WHEN('%') IF     ¬(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC)
55330000                        THEN   G_RESULT = '0'B;
55340000            WHEN('_') IF     ¬(CH_TYPE.NATIONAL | CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)
55350000                        THEN   G_RESULT = '0'B;
55360000            WHEN('>') IF     ¬(CH_TYPE.NATIONAL |
55370000                              (CH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC)))
55380000                        THEN   G_RESULT = '0'B;
55390000            WHEN('<') IF    ¬(¬CH_TYPE.UPCASE & (CH_TYPE.ALPHABETIC | CH_TYPE.NUMERIC))
55400000                        THEN   G_RESULT = '0'B;
55410000            WHEN('!') IF     ¬(CH_TYPE.SPECIAL)                   /*SPECIAL CHARACTER    */
55420000                        THEN   G_RESULT = '0'B;
55430000            WHEN('-') IF      (CH_TYPE.NUMERIC)                   /*NON-NUMERIC CHARACTER*/
55440000                        THEN   G_RESULT = '0'B;
55450000            WHEN('¬') IF      (CS_CH    = ' ')                    /*NON_BLANK CHARACTER  */
55460000                        THEN   G_RESULT = '0'B;
55470000            WHEN('?') IF     ¬(CH_TYPE.INVALID)                   /*INVALID CHARACTER    */
55480000                        THEN   G_RESULT = '0'B;
55490000            WHEN(CS_CH);           /*A PATTERN CHARACTER NOT APPEARING IN THE ABOVE LIST,*/
55500000                                                                   /*REPRESENTS ITSELF.  */
55510000            OTHERWISE          G_RESULT = '0'B; /*IF ALL TESTS FAILED, THE COMPARE FAILED*/
55520000          END;                       /*END OF PATTERN CHARACTER SELECT GROUP*/
55530000
55540000        END;
55550000
55560000        IF          (G_RESULT) & (CS_LN ¬= PS_LN)        /*IF RESULT SO FAR IS SUCCESSFUL*/
55570000          THEN
55580000            IF                   (CS_LN < PS_LN)   /*BASE RESULT ON TAIL OF LONGER STRING*/
55590000               THEN  G_RESULT = (VERIFY(SUBSTR(P_STRING,CS_LN+1),'* ')  <= 0);
55600000               ELSE  G_RESULT = (VERIFY(SUBSTR(C_STRING,PS_LN+1),' ')   <= 0);
55610000          ELSE;
55620000
55630000        RETURN(G_RESULT);            /*RETURN COMPARISON RESULTS*/
55640000       %PAGE;
55650000        DCL  CH_TABLE(000:255)         BIT(08) ALIGNED  STATIC  INTERNAL
55660000                INIT((01)('10000000'B),                                      /*   X'00'   */
55670000                     (63)('10000000'B),                                      /*X'01'-X'3F'*/
55680000                     (01)('01000000'B),    /*BLANK*/                         /*   X'40'   */
55690000                     (09)('11000000'B),                                      /*X'41'-X'49'*/
55700000                     (01)('01010000'B),    /*  ¢  */                         /*   X'4A'   */
55710000                     (01)('01010000'B),    /*  .  */                         /*   X'4B'   */
55720000                     (01)('01010000'B),    /*  <  */                         /*   X'4C'   */
55730000                     (01)('01010000'B),    /*  (  */                         /*   X'4D'   */
55740000                     (01)('01010000'B),    /*  +  */                         /*   X'4E'   */
55750000                     (01)('01010000'B),    /*  |  */                         /*   X'4F'   */
55760000                     (01)('01010000'B),    /*  &  */                         /*   X'50'   */
55770000                     (09)('11000000'B),                                      /*X'51'-X'59'*/
55780000                     (01)('01010000'B),    /*  !  */                         /*   X'5A'   */
55790000                     (01)('01001000'B),    /*  $  */                         /*   X'5B'   */
55800000                     (01)('01010000'B),    /*  *  */                         /*   X'5C'   */
55810000                     (01)('01010000'B),    /*  )  */                         /*   X'5D'   */
55820000                     (01)('01010000'B),    /*SEMICOLON*/                     /*   X'5E'   */
55830000                     (01)('01010000'B),    /*  ¬  */                         /*   X'5F'   */
55840000                     (01)('01010000'B),    /*  -  */                         /*   X'60'   */
55850000                     (01)('01010000'B),    /*  /  */                         /*   X'61'   */
55860000                     (08)('11000000'B),                                      /*X'62'-X'69'*/
55870000                     (01)('01010000'B),    /*  ¦  */                         /*   X'6A'   */
55880000                     (01)('01010000'B),    /*  ,  */                         /*   X'6B'   */
55890000                     (01)('01010000'B),    /*  %  */                         /*   X'6C'   */
55900000                     (01)('01010000'B),    /*  _  */                         /*   X'6D'   */
55910000                     (01)('01010000'B),    /*  >  */                         /*   X'6E'   */
55920000                     (01)('01010000'B),    /*  ?  */                         /*   X'6F'   */
55930000                     (09)('11000000'B),                                      /*X'70'-X'78'*/
55940000                     (01)('01010000'B),    /*  `  */                         /*   X'79'   */
55950000                     (01)('01010000'B),    /*  :  */                         /*   X'7A'   */
55960000                     (01)('01001000'B),    /*  #  */                         /*   X'7B'   */
55970000                     (01)('01001000'B),    /*  @  */                         /*   X'7C'   */
55980000                     (01)('01010000'B),    /*  '  */                         /*   X'7D'   */
55990000                     (01)('01010000'B),    /*  =  */                         /*   X'7E'   */
56000000                     (01)('01010000'B),    /*  "  */                         /*   X'7F'   */
56010000                     (01)('00000010'B),                                      /*   X'80'   */
56020000                     (09)('00000110'B),    /*LOWERCASE "A" - "I"*/           /*X'81'-X'89'*/
56030000                     (06)('10000000'B),                                      /*X'8A'-X'8F'*/
56040000                     (01)('00000010'B),                                      /*   X'90'   */
56050000                     (09)('00000110'B),    /*LOWERCASE "J" - "R"*/           /*X'91'-X'99'*/
56060000                     (06)('10000000'B),                                      /*X'9A'-X'9F'*/
56070000                     (01)('00000010'B),                                      /*   X'A0'   */
56080000                     (01)('00010010'B),    /*  ~  */                         /*   X'A1'   */
56090000                     (08)('00000110'B),    /*LOWERCASE "S" - "Z"*/           /*X'A2'-X'A9'*/
56100000                     (06)('10000000'B),                                      /*X'AA'-X'AF'*/
56110000                     (10)('00000001'B),    /*LOWERCASE "0" - "9"*/           /*X'B0'-X'B9'*/
56120000                     (06)('10000000'B),                                      /*X'BA'-X'BF'*/
56130000                     (01)('01010010'B),    /*  {  */                         /*   X'C0'   */
56140000                     (09)('01000110'B),    /*UPPERCASE "A" - "I"*/           /*X'C1'-X'C9'*/
56150000                     (06)('11000000'B),                                      /*X'CA'-X'CF'*/
56160000                     (01)('01010010'B),    /*  }  */                         /*   X'D0'   */
56170000                     (09)('01000110'B),    /*UPPERCASE "J" - "R"*/           /*X'D1'-X'D9'*/
56180000                     (06)('11000000'B),                                      /*X'DA'-X'DF'*/
56190000                     (01)('01010010'B),    /*  \  */                         /*   X'E0'   */
56200000                     (01)('01000010'B),                                      /*   X'E1'   */
56210000                     (08)('01000110'B),    /*UPPERCASE "S" - "Z"*/           /*X'E2'-X'E9'*/
56220000                     (06)('11000000'B),                                      /*X'EA'-X'EF'*/
56230000                     (10)('01000001'B),    /*UPPERCASE "0" - "9"*/           /*X'F0'-X'F9'*/
56240000                     (06)('11000000'B));                                     /*X'FA'-X'FF'*/
56250000       %SKIP(2);
56260000    END GCOMPARE;
56270000 %PAGE;
56280000 DECLARE    /*ASSOCIATE SUBROUTINES AND ENTRY POINTS BASED ON PARAMETER ATTRIBUTES*/
56290000
56300000         TRIM          GENERIC(CV_TRIM   WHEN(CHARACTER VARYING),
56310000                               CF_TRIM   WHEN(CHARACTER));
56320000 %SKIP(2);
56330000 CF_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */
56340000              /*FROM A FIXED LENGTH CHARACTER STRING.                             */
56350000    PROC(CF_STRING)                 /*RECEIVES THE CHARACTER STRING               */
56360000         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */
56370000
56380000        DCL  LENGTH            BUILTIN,
56390000             CF_STRING         CHAR(*),
56400000            (I,J,L)            FIXED BINARY(15,0);
56410000
56420000        L = LENGTH(CF_STRING);
56430000        IF  L > 0
56440000          THEN DO;
56450000                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CF_STRING,I,1) = ' '); END;
56460000                 DO J = L TO I BY -1 WHILE(SUBSTR(CF_STRING,J,1) = ' '); END;
56470000                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */
56480000                   THEN RETURN(SUBSTR(CF_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/
56490000                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/
56500000               END;
56510000          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */
56520000    END CF_TRIM;
56530000 %SKIP(2);
56540000 CV_TRIM:     /*FUNCTION SUBROUTINE TO REMOVE LEADING AND TRAILING BLANKS         */
56550000              /*FROM A VARYING LENGTH CHARACTER STRING.                           */
56560000    PROC(CV_STRING)                 /*RECEIVES THE CHARACTER STRING               */
56570000         RETURNS(CHAR(256) VAR);    /*RETURNS A VARYING LENGTH STRING             */
56580000
56590000        DCL  LENGTH            BUILTIN,
56600000             CV_STRING         CHAR(*) VARYING,
56610000            (I,J,L)            FIXED BINARY(15,0);
56620000
56630000        L = LENGTH(CV_STRING);
56640000        IF  L > 0
56650000          THEN DO;
56660000                 DO I = 1 TO L BY +1 WHILE(SUBSTR(CV_STRING,I,1) = ' '); END;
56670000                 DO J = L TO I BY -1 WHILE(SUBSTR(CV_STRING,J,1) = ' '); END;
56680000                 IF I <= J                /* I -> FIRST NON-BLANK, J -> LAST NON-BLANK */
56690000                   THEN RETURN(SUBSTR(CV_STRING,I,J-I+1)); /*STRING CONTAINS NON-BLANKS*/
56700000                   ELSE RETURN('');                        /*STRING IS COMPLETELY BLANK*/
56710000               END;
56720000          ELSE RETURN('');                                 /*STRING IS NULL (LENGTH 0) */
56730000    END CV_TRIM;
56740000    %SKIP(05);
56750000 END SMPSCAN;              /*END OF THE MAIN PROCEDURE*/
